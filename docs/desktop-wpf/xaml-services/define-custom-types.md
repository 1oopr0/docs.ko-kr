---
title: .NET XAML 서비스에서 사용할 사용자 지정 형식 정의
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551780"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="57998-102">.NET XAML 서비스에서 사용할 사용자 지정 형식 정의</span><span class="sxs-lookup"><span data-stu-id="57998-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="57998-103">비즈니스 개체 이거나 특정 프레임 워크에 대 한 종속성이 없는 형식인 사용자 지정 형식을 정의 하는 경우 XAML에 대 한 특정 모범 사례를 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="57998-104">이러한 방법을 따르는 경우 .NET XAML 서비스 및 XAML 판독기와 XAML 작성기는 형식의 XAML 특성을 검색 하 고 xaml 형식 시스템을 사용 하 여 XAML 노드 스트림에 적절 한 표현을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="57998-105">이 항목에서는 형식 정의, 멤버 정의 및 형식 또는 멤버의 CLR 특성에 대 한 모범 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="57998-106">XAML에 대 한 생성자 패턴 및 형식 정의</span><span class="sxs-lookup"><span data-stu-id="57998-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="57998-107">XAML에서 개체 요소로 인스턴스화하려면 사용자 지정 클래스는 다음 요구 사항을 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="57998-108">사용자 지정 클래스는 public 이어야 하며 매개 변수가 없는 public 생성자를 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="57998-109">구조체에 대한 자세한 내용은 다음 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="57998-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="57998-110">사용자 지정 클래스는 중첩 된 클래스가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="57998-111">전체 이름 경로에서 추가 "점"을 사용 하면 클래스 네임 스페이스 나누기가 모호해 집니다. 연결 된 속성과 같은 다른 XAML 기능을 방해 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="57998-112">개체를 개체 요소로 인스턴스화할 수 있는 경우 만들어진 개체는 개체를 내부 형식으로 사용 하는 속성의 속성 요소 형식을 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="57998-113">값 변환기를 사용 하는 경우 이러한 조건을 충족 하지 않는 형식에 대 한 개체 값을 계속 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="57998-114">자세한 내용은 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="57998-115">구조체</span><span class="sxs-lookup"><span data-stu-id="57998-115">Structures</span></span>

<span data-ttu-id="57998-116">구조체는 항상 CLR 정의에 의해 XAML로 생성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="57998-117">이는 CLR 컴파일러가 구조체에 대해 매개 변수가 없는 생성자를 암시적으로 만들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="57998-118">이 생성자는 모든 속성 값을 기본값으로 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="57998-119">일부 경우에는 구조에 대 한 기본 생성 동작이 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="57998-120">구조체는 값을 채우고 개념적으로 개념적으로 함수를 사용 하기 위한 것 이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="57998-121">공용 구조체로 포함 된 값에는 상호 배타적인 해석이 있을 수 있으므로 해당 속성을 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="57998-122">WPF 어휘의 이러한 구조체의 예는 <xref:System.Windows.GridLength> 입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="57998-123">이러한 구조체는 구조체 값의 다른 해석 또는 모드를 만드는 문자열 규칙을 사용 하 여 값을 특성 형식으로 표현할 수 있도록 형식 변환기를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="57998-124">또한 구조체는 매개 변수가 없는 생성자를 통해 코드 생성에 대해 비슷한 동작을 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="57998-125">인터페이스</span><span class="sxs-lookup"><span data-stu-id="57998-125">Interfaces</span></span>

<span data-ttu-id="57998-126">인터페이스는 멤버의 기본 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="57998-127">XAML 형식 시스템은 할당 가능한 목록을 검사 하 고 값으로 제공 된 개체를 인터페이스에 할당할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="57998-128">관련 할당 가능한 형식이 XAML 생성 요구 사항을 지 원하는 경우 인터페이스를 XAML 형식으로 표시 하는 방법에 대 한 개념이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="57998-129">팩터리 메서드</span><span class="sxs-lookup"><span data-stu-id="57998-129">Factory Methods</span></span>

<span data-ttu-id="57998-130">팩터리 메서드는 XAML 2009 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="57998-131">개체에 매개 변수가 없는 생성자가 있어야 하는 XAML 원칙을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="57998-132">팩터리 메서드는이 문서에 설명 되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="57998-133">[X:FactoryMethod 지시문](xfactorymethod-directive.md)을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="57998-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="57998-134">열거형</span><span class="sxs-lookup"><span data-stu-id="57998-134">Enumerations</span></span>

<span data-ttu-id="57998-135">열거형에는 XAML 네이티브 형식 변환 동작이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="57998-136">XAML로 지정 된 열거형 상수 이름은 기본 열거형 형식에 대해 확인 되 고 열거형 값을 XAML 개체 작성기로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="57998-137">XAML은 적용 된 열거형의 플래그 스타일 사용을 지원 <xref:System.FlagsAttribute> 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="57998-138">자세한 내용은 [XAML 구문 정보](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="57998-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="57998-139">[Xaml 구문](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) 에 대 한 자세한 내용은 WPF 대상에 맞게 작성 되었지만 해당 항목의 대부분의 정보는 특정 구현 프레임 워크와 관련이 없는 xaml과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="57998-140">멤버 정의</span><span class="sxs-lookup"><span data-stu-id="57998-140">Member Definitions</span></span>

<span data-ttu-id="57998-141">형식은 XAML 사용에 대 한 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="57998-142">특정 형식이 XAML을 사용할 수 없는 경우에도 형식이 XAML을 사용할 수 있는 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="57998-143">이는 CLR 상속 때문에 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="57998-144">멤버를 상속 하는 일부 형식이 XAML 사용을 형식으로 지원 하 고 멤버가 내부 형식에 대 한 XAML 사용을 지원 하거나 네이티브 XAML 구문을 사용할 수 있는 경우 해당 멤버는 XAML을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="57998-145">속성</span><span class="sxs-lookup"><span data-stu-id="57998-145">Properties</span></span>

<span data-ttu-id="57998-146">일반적인 CLR 및 접근자 패턴과 언어에 적합 한 단어를 사용 하 여 속성을 공용 CLR 속성으로 정의 하는 경우 `get` `set` XAML 형식 시스템은 속성에 제공 된 적절 한 정보 ( <xref:System.Xaml.XamlMember> 예: 및)를 가진 멤버로 속성을 보고할 수 있습니다 <xref:System.Xaml.XamlMember.IsReadPublic%2A> <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="57998-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="57998-147">특정 속성은를 적용 하 여 텍스트 구문을 사용 하도록 설정할 수 있습니다 <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="57998-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="57998-148">자세한 내용은 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="57998-149">텍스트 구문이 나 네이티브 XAML 변환이 없고 태그 확장 사용과 같은 추가 간접 참조가 없으면 속성의 형식 ( <xref:System.Xaml.XamlMember.TargetType%2A> xaml 형식 시스템)은 대상 형식을 CLR 형식으로 처리 하 여 xaml 개체 작성기에 인스턴스를 반환할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="57998-150">XAML 2009를 사용 하는 경우 앞의 고려 사항이 충족 되지 않는 경우에는 [X:reference 태그 확장](xreference-markup-extension.md) 을 사용 하 여 값을 제공할 수 있습니다. 그러나이는 형식 정의 문제 보다 더 많은 사용 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="57998-151">이벤트</span><span class="sxs-lookup"><span data-stu-id="57998-151">Events</span></span>

<span data-ttu-id="57998-152">이벤트를 공용 CLR 이벤트로 정의 하면 XAML 형식 시스템에서로 이벤트를 멤버로 보고할 수 있습니다 <xref:System.Xaml.XamlMember.IsEvent%2A> `true` .</span><span class="sxs-lookup"><span data-stu-id="57998-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="57998-153">이벤트 처리기의 연결은 .NET XAML 서비스 기능 범위 내에 있지 않습니다. 와이어링은 특정 프레임 워크 및 구현으로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="57998-154">메서드</span><span class="sxs-lookup"><span data-stu-id="57998-154">Methods</span></span>

<span data-ttu-id="57998-155">메서드에 대 한 인라인 코드는 기본 XAML 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="57998-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="57998-156">대부분의 경우 XAML에서 메서드 멤버를 직접 참조 하지 않으며 XAML의 메서드 역할은 특정 XAML 패턴에 대 한 지원도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="57998-157">[X:FactoryMethod 지시문](xfactorymethod-directive.md) 은 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="57998-158">필드</span><span class="sxs-lookup"><span data-stu-id="57998-158">Fields</span></span>

<span data-ttu-id="57998-159">CLR 디자인 지침은 비정적 필드를 억제 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="57998-160">정적 필드의 경우 [X:Static 태그 확장](xstatic-markup-extension.md)을 통해서만 정적 필드 값에 액세스할 수 있습니다. 이 경우 [x:Static](xstatic-markup-extension.md) 사용에 대 한 필드를 노출 하기 위해 CLR 정의에서 특별 한 작업을 수행 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="57998-161">연결 가능한 멤버</span><span class="sxs-lookup"><span data-stu-id="57998-161">Attachable Members</span></span>

<span data-ttu-id="57998-162">연결 가능한 멤버는 정의 형식에 대 한 접근자 메서드 패턴을 통해 XAML로 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="57998-163">정의 형식 자체는 개체로 XAML을 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="57998-164">실제로 패턴은 연결할 수 있는 멤버를 소유 하 고 관련 된 동작을 구현 하는 역할을 하는 서비스 클래스를 선언 하는 것입니다. 그러나 UI 표현과 같은 다른 함수는 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="57998-165">다음 섹션에서 자리 표시자 *PropertyName* 은 연결 가능한 멤버의 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57998-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="57998-166">이 이름은 [XamlName 문법](xamlname-grammar.md)에서 유효 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="57998-167">이러한 패턴과 형식의 다른 메서드 간 이름 충돌을 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="57998-168">패턴 중 하 나와 일치 하는 멤버가 있는 경우 의도 하지 않은 경우에도 XAML 프로세서에서 연결 가능한 멤버 사용 경로로 해석 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="57998-169">GetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="57998-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="57998-170">접근자에 대 한 시그니처는 `GetPropertyName` 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="57998-171">구현에서 보다 구체적인 형식으로 `target` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="57998-172">이를 사용 하 여 연결 가능한 멤버를 사용 하는 범위를 지정할 수 있습니다. 의도 된 범위를 벗어나는 사용량은 XAML 구문 분석 오류로 표시 되는 잘못 된 캐스팅 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="57998-173">매개 변수 이름은 `target` 요구 사항이 아니지만 `target` 대부분의 구현에서 규칙에 따라 이름이 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="57998-174">구현에서 보다 구체적인 형식으로 반환 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="57998-175">연결 <xref:System.ComponentModel.TypeConverter> 가능한 멤버의 특성 사용에 대해 활성화 된 텍스트 구문을 지원 하려면 <xref:System.ComponentModel.TypeConverterAttribute> 접근자에을 적용 `GetPropertyName` 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="57998-176">대신에를 적용 하면 `get` `set` 직관적이 지 않을 수 있지만이 규칙은 디자이너 시나리오에서 유용 하 게 사용할 수 있는 읽기 전용 연결 가능 멤버의 개념을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="57998-177">SetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="57998-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="57998-178">접근자에 대 한 시그니처는 `SetPropertyName` 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="57998-179">`target`이전 섹션에서 설명한 것과 동일한 논리와 결과를 사용 하 여 구현에서 개체를 더 구체적인 형식으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="57998-180">구현에서 보다 구체적인 형식으로 `value` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="57998-181">이 메서드의 값은 일반적으로 특성 형식의 XAML 사용에서 들어오는 입력입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="57998-182">특성 형식에서 텍스트 구문에 대 한 값 변환기를 지원 하 고 s 접근자에 대 한 특성을 지원 해야 합니다 `GetPropertyName` .</span><span class="sxs-lookup"><span data-stu-id="57998-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="57998-183">연결 가능한 멤버 저장소</span><span class="sxs-lookup"><span data-stu-id="57998-183">Attachable Member Stores</span></span>

<span data-ttu-id="57998-184">일반적으로 접근자 메서드는 개체 그래프에 연결할 수 있는 멤버 값을 배치할 수단을 제공 하거나 개체 그래프에서 값을 검색 하 고 올바르게 serialize 할 수 있는 수단을 제공 하기에 충분 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="57998-185">이 기능을 제공 하기 위해 `target` 이전 접근자 시그니처의 개체는 값을 저장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="57998-186">연결 가능한 멤버가 멤버 목록에 없는 대상에 연결할 수 있는 연결 가능한 멤버와 저장소 메커니즘이 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="57998-187">.NET XAML 서비스는 Api 및를 통해 연결 가능한 멤버 저장소에 대 한 구현 기술을 제공 합니다 <xref:System.Xaml.IAttachedPropertyStore> <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="57998-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="57998-188"><xref:System.Xaml.IAttachedPropertyStore> 는 XAML 작성기에서 저장소 구현을 검색 하는 데 사용 되며 접근자의 인 형식에 대해 구현 되어야 합니다 `target` .</span><span class="sxs-lookup"><span data-stu-id="57998-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="57998-189">정적 <xref:System.Xaml.AttachablePropertyServices> api는 접근자의 본문 내에서 사용 되며에서 연결 가능한 멤버를 참조 합니다 <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="57998-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="57998-190">XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="57998-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="57998-191">.NET XAML 서비스에 XAML 형식 시스템 정보를 보고 하려면 형식, 멤버 및 어셈블리를 올바르게 특성을 적절 하 게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="57998-192">보고 XAML 형식 시스템 정보는 다음 상황 중 하나에 해당 하는 경우에만 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="57998-193">.NET XAML 서비스 XAML 판독기 및 XAML 작성기를 직접 기반으로 하는 XAML 시스템에서 사용 하기 위해 형식을 사용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="57998-194">이러한 XAML 판독기와 XAML 작성기를 기반으로 하는 XAML 활용 프레임 워크를 정의 하거나 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="57998-195">사용자 지정 형식의 XAML 지원과 관련 된 각 XAML 관련 특성의 목록은 [사용자 지정 형식 및 라이브러리에 대 한 Xaml 관련 CLR 특성](clr-attributes-with-custom-types-and-libraries.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="57998-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="57998-196">사용량</span><span class="sxs-lookup"><span data-stu-id="57998-196">Usage</span></span>

<span data-ttu-id="57998-197">사용자 지정 형식을 사용 하려면 태그 작성자가 어셈블리 및 사용자 지정 형식이 포함 된 CLR 네임 스페이스에 대 한 접두사를 매핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="57998-198">이 절차는이 항목에서 설명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="57998-199">액세스 수준</span><span class="sxs-lookup"><span data-stu-id="57998-199">Access Level</span></span>

<span data-ttu-id="57998-200">XAML은 액세스 수준이 있는 형식을 로드 하 고 인스턴스화하는 방법을 제공 `internal` 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="57998-201">사용자 코드에서 고유한 형식을 정의한 다음 동일한 사용자 코드 범위의 일부인 태그에서 해당 클래스를 인스턴스화할 수 있도록이 기능이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="57998-202">WPF의 한 가지 예는 사용자 코드에서 <xref:System.Windows.Controls.UserControl> UI 동작을 리팩터링 하는 방법으로 사용 되지만 액세스 수준으로 지원 클래스를 선언 하 여 암시 될 수 있는 확장 메커니즘의 일부가 아닌를 정의할 때마다입니다 `public` .</span><span class="sxs-lookup"><span data-stu-id="57998-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="57998-203"><xref:System.Windows.Controls.UserControl> `internal` 지원 코드를 XAML 형식으로 참조 되는 것과 동일한 어셈블리로 컴파일하면 액세스를 사용 하 여 이러한을 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57998-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="57998-204">완전 신뢰 및 사용 중인 XAML을 로드 하는 응용 프로그램의 경우 <xref:System.Xaml.XamlObjectWriter> 액세스 수준을 사용 하 여 클래스를 로드 하 `internal` 는 것은 항상 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="57998-205">부분 신뢰에서 XAML을 로드 하는 응용 프로그램의 경우 API를 사용 하 여 액세스 수준 특성을 제어할 수 있습니다 <xref:System.Xaml.Permissions.XamlAccessLevel> .</span><span class="sxs-lookup"><span data-stu-id="57998-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="57998-206">또한 지연 메커니즘 (예: WPF 템플릿 시스템)은 액세스 수준 권한을 전파 하 고 최종 실행 시간 평가를 위해 유지할 수 있어야 합니다. 이는 정보를 전달 하 여 내부적으로 처리 됩니다 <xref:System.Xaml.Permissions.XamlAccessLevel> .</span><span class="sxs-lookup"><span data-stu-id="57998-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="57998-207">WPF 구현</span><span class="sxs-lookup"><span data-stu-id="57998-207">WPF Implementation</span></span>

<span data-ttu-id="57998-208">WPF XAML은 부분 신뢰 액세스 모델을 사용 합니다. 여기서 BAML이 부분 신뢰로 로드 되 면 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> baml 소스인 어셈블리에 대 한 액세스가로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="57998-209">지연의 경우 WPF는 <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 액세스 수준 정보를 전달 하기 위한 메커니즘으로를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="57998-210">WPF XAML 용어에서 *내부 형식은* 참조 XAML도 포함 하는 동일한 어셈블리에 의해 정의 되는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="57998-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="57998-211">이러한 형식은 어셈블리를 의도적으로 생략 하는 XAML 네임 스페이스 (예:)를 통해 매핑될 수 있습니다 `xmlns:local="clr-namespace:WPFApplication1"` .</span><span class="sxs-lookup"><span data-stu-id="57998-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="57998-212">BAML이 내부 형식을 참조 하 고 해당 형식에 `internal` 액세스 수준이 있는 경우 `GeneratedInternalTypeHelper` 어셈블리에 대 한 클래스가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="57998-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="57998-213">이를 방지 하려면 `GeneratedInternalTypeHelper` 액세스 수준을 사용 해야 합니다 `public` . 또는 관련 클래스의 수준을 별도의 어셈블리로 지정 하 고 해당 어셈블리를 종속 된 것으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57998-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="57998-214">참조</span><span class="sxs-lookup"><span data-stu-id="57998-214">See also</span></span>

- [<span data-ttu-id="57998-215">사용자 지정 형식 및 라이브러리에 대한 XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="57998-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="57998-216">XAML 서비스</span><span class="sxs-lookup"><span data-stu-id="57998-216">XAML Services</span></span>](../../../api/index.md)
