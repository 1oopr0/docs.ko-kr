---
title: XAML 형식 변환기 개요
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [XAML Services], type converters
- XAML [XAML Services], TypeConverter
- type conversion for XAML [XAML Services]
ms.assetid: 51a65860-efcb-4fe0-95a0-1c679cde66b7
ms.openlocfilehash: 6e78210178fda65bb3baad0d24eb3a20cd6f2a3e
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90540115"
---
# <a name="overview-of-type-converters-for-xaml"></a><span data-ttu-id="59907-102">XAML에 대 한 형식 변환기 개요</span><span class="sxs-lookup"><span data-stu-id="59907-102">Overview of type converters for XAML</span></span>

<span data-ttu-id="59907-103">형식 변환기는 XAML 태그의 문자열에서 개체 그래프의 특정 개체로 변환하는 논리를 개체 작성기에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-103">Type converters supply logic for an object writer that converts from a string in XAML markup into particular objects in an object graph.</span></span> <span data-ttu-id="59907-104">.NET XAML 서비스에서 형식 변환기는에서 파생 되는 클래스 여야 합니다 <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="59907-104">In .NET XAML Services, the type converter must be a class that derives from <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="59907-105">또한 일부 변환기는 XAML 저장 경로를 지원하며 serialization 태그에서 개체를 문자열 형식으로 직렬화하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-105">Some converters also support the XAML save path and can be used to serialize an object into a string form in serialization markup.</span></span> <span data-ttu-id="59907-106">이 항목에서는 XAML의 형식 변환기가 호출되는 방법 및 시기에 대해 설명하고 <xref:System.ComponentModel.TypeConverter>의 메서드 재정의에 대한 구현 권장 사항을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-106">This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <xref:System.ComponentModel.TypeConverter>.</span></span>

## <a name="type-conversion-concepts"></a><span data-ttu-id="59907-107">형식 변환 개념</span><span class="sxs-lookup"><span data-stu-id="59907-107">Type Conversion Concepts</span></span>

<span data-ttu-id="59907-108">다음 섹션에서는 XAML에서 문자열을 사용 하는 방법 및 .NET XAML 서비스의 개체 작성기에서 형식 변환기를 사용 하 여 XAML 소스에 있는 일부 문자열 값을 처리 하는 방법에 대 한 기본 개념을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-108">The following sections explain basic concepts about how XAML uses strings, and how object writers in .NET XAML Services use type converters to process some of the string values that are encountered in a XAML source.</span></span>

### <a name="xaml-and-string-values"></a><span data-ttu-id="59907-109">XAML 및 문자열 값</span><span class="sxs-lookup"><span data-stu-id="59907-109">XAML and String Values</span></span>

<span data-ttu-id="59907-110">XAML 파일에서 특성 값을 설정하는 경우 해당 값의 초기 형식은 일반적인 의미에서 문자열이고 XML 의미에서 문자열 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-110">When you set an attribute value in a XAML file, the initial type of that value is a string in a general sense, and a string attribute value in an XML sense.</span></span> <span data-ttu-id="59907-111"><xref:System.Double> 과 같은 다른 기본 형식도 처음에는 XAML 프로세서의 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-111">Even other primitives such as <xref:System.Double> are initially strings to a XAML processor.</span></span>

<span data-ttu-id="59907-112">대부분의 경우 XAML 프로세서에서 특성 값을 처리하려면 두 가지 정보가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-112">In most cases, a XAML processor needs two pieces of information to process an attribute value.</span></span> <span data-ttu-id="59907-113">첫 번째 정보는 설정되는 속성의 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-113">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="59907-114">특성 값을 정의하고 XAML에서 처리되는 모든 문자열은 결국 해당 형식의 값으로 변환되거나 확인되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-114">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="59907-115">값이 숫자 값과 같이 XAML 파서에서 인식되는 기본 형식인 경우 문자열의 직접 변환이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="59907-115">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="59907-116">특성에 대한 값이 열거형을 참조하는 경우에는 제공된 문자열에서 이름이 해당 열거형에 명명된 상수와 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-116">If the value for the attribute references an enumeration, the supplied string is checked for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="59907-117">값이 파서에서 인식 되는 기본 형식이 나 열거형의 상수 이름이 아닌 경우 적용 가능한 형식에서 변환 된 문자열을 기반으로 하는 값 이나 참조를 제공할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-117">If the value is not a parser-understood primitive or a constant name from an enumeration, the applicable type must be able to provide a value or reference that is based on a converted string.</span></span>

> [!NOTE]
> <span data-ttu-id="59907-118">XAML 언어 지시문은 형식 변환기를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-118">XAML language directives do not use type converters.</span></span>

### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="59907-119">형식 변환기 및 태그 확장명</span><span class="sxs-lookup"><span data-stu-id="59907-119">Type Converters and Markup Extensions</span></span>

<span data-ttu-id="59907-120">태그 확장 사용은 속성 형식 및 기타 고려 사항을 확인하기 전에 XAML 프로세서에서 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-120">Markup extension usages must be handled by a XAML processor before it checks for property type and other considerations.</span></span> <span data-ttu-id="59907-121">예를 들어 일반적으로 특성으로 설정되는 속성에 형식 변환이 있지만 특별한 경우에는 태그 확장 사용으로 설정되는 경우 태그 확장 동작이 먼저 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="59907-121">For example, if a property being set as an attribute normally has a type conversion, but in a particular case is set by a markup extension usage, then the markup extension behavior processes first.</span></span> <span data-ttu-id="59907-122">태그 확장이 필요한 일반적인 상황은 이미 존재하는 개체에 대한 참조를 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-122">One common situation where a markup extension is necessary is to make a reference to an object that already exists.</span></span> <span data-ttu-id="59907-123">이 시나리오에서는 상태 비저장 형식 변환기만 새 인스턴스를 생성할 수 있으며, 이는 바람직하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-123">For this scenario, a stateless type converter can only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="59907-124">태그 확장에 대한 자세한 내용은 [Markup Extensions for XAML Overview](markup-extensions-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="59907-124">For more information about markup extensions, see [Markup Extensions for XAML Overview](markup-extensions-overview.md).</span></span>

### <a name="native-type-converters"></a><span data-ttu-id="59907-125">네이티브 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="59907-125">Native Type Converters</span></span>

<span data-ttu-id="59907-126">Windows Presentation Foundation (WPF) 및 .NET XAML 서비스 구현에는 네이티브 형식 변환 처리를 포함 하는 특정 CLR 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-126">In the Windows Presentation Foundation (WPF) and .NET XAML services implementations, there are certain CLR types that have native type conversion handling.</span></span> <span data-ttu-id="59907-127">그러나 이러한 CLR 형식은 일반적으로 기본 형식으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-127">However, those CLR types are not conventionally thought of as primitives.</span></span> <span data-ttu-id="59907-128">이러한 형식의 예로는 <xref:System.DateTime>이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-128">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="59907-129">한 가지 이유는 <xref:System.DateTime> 형식이 .NET에서 가장 기본적인 라이브러리인 mscorlib에서 정의되는 .NET Framework 아키텍처의 작동 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-129">One reason for this is how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="59907-130"><xref:System.DateTime> 는 종속성을 도입 하는 다른 어셈블리에서 제공 되는 특성을 사용할 수 없습니다 ( <xref:System.ComponentModel.TypeConverterAttribute> 시스템에서).</span><span class="sxs-lookup"><span data-stu-id="59907-130"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System).</span></span> <span data-ttu-id="59907-131">따라서 특성에 따라 일반적인 형식 변환기 검색 메커니즘을 지원할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-131">Therefore, the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="59907-132">대신 XAML 파서에 네이티브 처리가 필요한 형식 목록이 있으며 실제 기본 형식이 처리되는 방법과 유사한 방법으로 이러한 형식을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-132">Instead, the XAML parser has a list of types that need native processing, and it processes these types similar to how the true primitives are processed.</span></span> <span data-ttu-id="59907-133"><xref:System.DateTime>의 경우 이 처리에서 <xref:System.DateTime.Parse%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-133">In the case of <xref:System.DateTime>, this processing involves a call to <xref:System.DateTime.Parse%2A>.</span></span>

## <a name="implementing-a-type-converter"></a><span data-ttu-id="59907-134">형식 변환기 구현</span><span class="sxs-lookup"><span data-stu-id="59907-134">Implementing a Type Converter</span></span>

<span data-ttu-id="59907-135">다음 섹션에서는 <xref:System.ComponentModel.TypeConverter> 클래스의 API에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-135">The following sections discuss the API of the <xref:System.ComponentModel.TypeConverter> class.</span></span>

### <a name="typeconverter"></a><span data-ttu-id="59907-136">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="59907-136">TypeConverter</span></span>

<span data-ttu-id="59907-137">.NET XAML 서비스에서 XAML 용도에 사용 되는 모든 형식 변환기는 기본 클래스에서 파생 되는 클래스입니다 <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="59907-137">Under .NET XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="59907-138"><xref:System.ComponentModel.TypeConverter> 클래스는 XAML이 존재하기 이전에 .NET Framework 버전에 있었으며, 원래 <xref:System.ComponentModel.TypeConverter> 시나리오 중 하나는 비주얼 디자이너의 속성 편집기에 문자열 변환을 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-138">The <xref:System.ComponentModel.TypeConverter> class existed in versions of the .NET Framework before XAML existed; one of the original <xref:System.ComponentModel.TypeConverter> scenarios was to provide string conversion for property editors in visual designers.</span></span>

<span data-ttu-id="59907-139">XAML의 경우 <xref:System.ComponentModel.TypeConverter> 의 역할이 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="59907-139">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded.</span></span> <span data-ttu-id="59907-140">XAML 용도에서 <xref:System.ComponentModel.TypeConverter> 는 특정 to-string 및 from-string 변환을 지원하는 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-140">For XAML purposes, <xref:System.ComponentModel.TypeConverter> is the base class for providing support for certain to-string and from-string conversions.</span></span> <span data-ttu-id="59907-141">From-string에서는 XAML에서 문자열 특성 값을 구문 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-141">From-string enables parsing a string attribute value from XAML.</span></span> <span data-ttu-id="59907-142">To-string에서는 serialization을 위해 특정 개체 속성의 런타임 값을 XAML의 특성으로 다시 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-142">To-string might enable processing a run-time value of a particular object property back into an attribute in XAML for serialization.</span></span>

<span data-ttu-id="59907-143"><xref:System.ComponentModel.TypeConverter> 는 XAML 처리를 위한 to-string 및 from-string 변환과 관련된 네 가지 멤버를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-143"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:</span></span>

- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>

- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>

<span data-ttu-id="59907-144">이러한 멤버 중 가장 중요한 메서드는 입력 문자열을 필요한 개체 형식으로 변환하는 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-144">Of these members, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, which converts the input string to the required object type.</span></span> <span data-ttu-id="59907-145"><xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 메서드는 광범위한 형식을 변환기의 지정된 대상 형식으로 변환하기 위해 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-145">The <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method can be implemented to convert a wider range of types into the intended destination type of the converter.</span></span> <span data-ttu-id="59907-146">따라서 런타임 변환 지원과 같이 XAML 이상으로 확장되는 용도로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-146">Therefore, it can serve purposes that extend beyond XAML, such as supporting run-time conversions.</span></span> <span data-ttu-id="59907-147">그러나 XAML 용도에서는 <xref:System.String> 입력을 처리할 수 있는 코드 경로만 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-147">However, for XAML use, only the code path that can process a <xref:System.String> input is important.</span></span>

<span data-ttu-id="59907-148">두 번째로 중요 한 메서드는 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-148">The second-most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="59907-149">응용 프로그램이 태그 표현으로 변환 되는 경우 (예: XML에 파일로 저장 된 경우) <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 는 xaml 텍스트 작성기의 더 큰 시나리오와 관련 되어 태그 표현을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-149">If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is involved in the larger scenario of a XAML text writer to produce a markup representation.</span></span> <span data-ttu-id="59907-150">이 경우 XAML에 중요한 코드 경로는 호출자가 `destinationType` 의 <xref:System.String>을 전달하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-150">In this case, the important code path for XAML is when the caller passes a `destinationType` of <xref:System.String>.</span></span>

<span data-ttu-id="59907-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 및 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 은 서비스에서 <xref:System.ComponentModel.TypeConverter> 구현의 기능을 쿼리할 때 사용되는 지원 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-151"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="59907-152">변환기의 동일한 변환 메서드에서 지원하는 형식 관련 케이스에 대해 `true`를 반환하려면 이러한 메서드를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-152">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="59907-153">XAML 용도에서는 일반적으로 <xref:System.String> 형식을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-153">For XAML purposes, this generally means the <xref:System.String> type.</span></span>

### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="59907-154">XAML에 대한 문화권 정보 및 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="59907-154">Culture Information and Type Converters for XAML</span></span>

<span data-ttu-id="59907-155">각 <xref:System.ComponentModel.TypeConverter> 구현에서는 변환에 유효한 문자열을 고유하게 해석할 수 있으며 매개 변수로 전달되는 형식 설명을 사용하거나 무시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-155">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters.</span></span> <span data-ttu-id="59907-156">문화권 및 XAML 형식 변환에서 중요한 고려 사항은 XAML에서 지역화 가능한 문자열을 특성 값으로 사용할 수 있지만 이러한 지역화 가능한 문자열을 특정 문화권 요구 사항이 있는 형식 변환기 입력으로 사용할 수 없다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-156">An important consideration for culture and XAML type conversion is the following: although using localizable strings as attribute values is supported by XAML, you cannot use these localizable strings as type converter input with specific culture requirements.</span></span> <span data-ttu-id="59907-157">이러한 제한은 XAML 특성 값에 대한 형식 변환기에서 `en-US` 문화권을 사용하는 고정 언어 XAML 처리 동작을 반드시 포함하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-157">This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses `en-US` culture.</span></span> <span data-ttu-id="59907-158">이러한 제한의 디자인 이유에 대 한 자세한 내용은 XAML 언어 사양 ([ \[ MS-xaml \] ](/previous-versions/msp-n-p/ff650760(v=pandp.10))) 또는 [WPF 전역화 및 지역화 개요](/dotnet/desktop/wpf/advanced/wpf-globalization-and-localization-overview)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="59907-158">For more information about the design reasons for this restriction, see the XAML language specification ([\[MS-XAML\]](/previous-versions/msp-n-p/ff650760(v=pandp.10))) or [WPF Globalization and Localization Overview](/dotnet/desktop/wpf/advanced/wpf-globalization-and-localization-overview).</span></span>

<span data-ttu-id="59907-159">문화권이 문제가 될 수 있는 경우에 대한 예로 일부 문화권에서는 문자열 형식의 숫자에 대한 소수점 구분 기호로 마침표 대신 쉼표를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-159">As an example where culture can be an issue, some cultures use a comma instead of a period as the decimal point delimiter for numbers in string form.</span></span> <span data-ttu-id="59907-160">이러한 사용은 쉼표를 구분 기호로 사용하는 기존의 많은 형식 변환기의 동작과 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-160">This use collides with the behavior that many existing type converters have, which is to use a comma as a delimiter.</span></span> <span data-ttu-id="59907-161">주변 XAML에서 `xml:lang` 을 통해 문화권을 전달하면 문제가 해결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-161">Passing a culture through `xml:lang` in the surrounding XAML does not solve the issue.</span></span>

### <a name="implementing-convertfrom"></a><span data-ttu-id="59907-162">ConvertFrom 구현</span><span class="sxs-lookup"><span data-stu-id="59907-162">Implementing ConvertFrom</span></span>

<span data-ttu-id="59907-163">XAML을 지원하는 <xref:System.ComponentModel.TypeConverter> 구현으로 사용하려면 해당 변환기에 대한 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 메서드에서 문자열을 `value` 매개 변수로 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-163">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="59907-164">문자열이 올바른 형식이고 <xref:System.ComponentModel.TypeConverter> 구현으로 변환할 수 있는 경우 반환된 개체가 속성에 필요한 형식으로 캐스트를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-164">If the string is in a valid format and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, the returned object must support a cast to the type that is expected by the property.</span></span> <span data-ttu-id="59907-165">그렇지 않은 경우 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 구현에서 `null`을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-165">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>

<span data-ttu-id="59907-166">각 <xref:System.ComponentModel.TypeConverter> 구현에서는 변환에 유효한 문자열을 구성하는 항목을 고유하게 해석할 수 있으며 매개 변수로 전달되는 문화권 컨텍스트나 형식 설명을 사용하거나 무시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-166">Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters.</span></span> <span data-ttu-id="59907-167">그러나 WPF XAML 처리에서 모든 경우의 형식 설명 컨텍스트에 값을 전달할 수는 없으며 `xml:lang`에 기반을 둔 문화권을 전달할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-167">However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on `xml:lang`.</span></span>

> [!NOTE]
> <span data-ttu-id="59907-168">중괄호 ( {} ), 특히 여는 중괄호 ({)를 문자열 형식의 요소로 사용 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="59907-168">Do not use the braces ({}), specifically the opening brace ({), as an element of your string format.</span></span> <span data-ttu-id="59907-169">이러한 문자는 태그 확장명 시퀀스의 시작 및 종료로 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-169">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>

<span data-ttu-id="59907-170">형식 변환기가 .NET XAML 서비스 개체 작성기에서 XAML 서비스에 액세스할 수 있어야 하지만 <xref:System.IServiceProvider.GetService%2A> 컨텍스트에 대 한 호출에서 해당 서비스를 반환 하지 않는 경우 예외를 throw 하는 것이 적절 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-170">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-convertto"></a><span data-ttu-id="59907-171">ConvertTo 구현</span><span class="sxs-lookup"><span data-stu-id="59907-171">Implementing ConvertTo</span></span>

<span data-ttu-id="59907-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 는 serialization 지원에 잠재적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="59907-172"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="59907-173"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 를 통해 사용자 지정 형식 및 해당 형식 변환기에 대해 Serialization을 지원하는 것은 절대적인 요구 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="59907-173">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="59907-174">그러나 컨트롤을 구현하거나 클래스의 디자인 또는 기능의 일부로 serialization을 사용하는 경우에는 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-174">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>

<span data-ttu-id="59907-175">XAML을 지원하는 <xref:System.ComponentModel.TypeConverter> 구현으로 사용하려면 해당 변환기에 대한 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 메서드에서 `value` 매개 변수로 지원되는 형식(또는 값)의 인스턴스를 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-175">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) that is supported as the `value` parameter.</span></span> <span data-ttu-id="59907-176">`destinationType` 매개 변수가 <xref:System.String>형식인 경우 반환된 개체는 <xref:System.String>으로 캐스트될 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-176">When the `destinationType` parameter is of type <xref:System.String>, the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="59907-177">반환된 문자열은 `value`의 직렬화된 값을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-177">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="59907-178">이상적으로 선택한 serialization 형식은 해당 문자열이 동일한 변환기의 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 구현에 전달된 경우와 동일한 값을 생성할 수 있어야 하며 정보가 크게 손실되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-178">Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>

<span data-ttu-id="59907-179">값을 직렬화할 수 없거나 변환기에서 serialization을 지원하지 않는 경우 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 구현은 `null` 을 반환하고 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-179">If the value cannot be serialized or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null` and can throw an exception.</span></span> <span data-ttu-id="59907-180">그러나 예외를 throw하는 경우에는 먼저 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 를 확인하여 예외를 방지하는 가장 좋은 방법이 지원되도록 해당 변환을 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 구현의 일부로 사용할 수 없음을 보고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-180">However, if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>

<span data-ttu-id="59907-181">`destinationType` 매개 변수가 <xref:System.String>형식이 아닌 경우 고유한 변환기 처리를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-181">If the `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="59907-182">일반적으로 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 에서 특정 예외를 발생시키는 기본 구현 처리로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="59907-182">Typically, you revert to base implementation handling, which in the base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>

<span data-ttu-id="59907-183">형식 변환기가 .NET XAML 서비스 개체 작성기에서 XAML 서비스에 액세스할 수 있어야 하지만 <xref:System.IServiceProvider.GetService%2A> 컨텍스트에 대 한 호출에서 해당 서비스를 반환 하지 않는 경우 예외를 throw 하는 것이 적절 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-183">It is appropriate to throw an exception when your type converter must have access to a XAML service from .NET XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.</span></span>

### <a name="implementing-canconvertfrom"></a><span data-ttu-id="59907-184">CanConvertFrom 구현</span><span class="sxs-lookup"><span data-stu-id="59907-184">Implementing CanConvertFrom</span></span>

<span data-ttu-id="59907-185"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 구현은 `true` 형식의 `sourceType` 에 대해 <xref:System.String> 를 반환하고, 그렇지 않은 경우 기본 구현에서 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-185">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String> and otherwise, defer to the base implementation.</span></span> <span data-ttu-id="59907-186"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>에서 예외를 throw하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-186">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>.</span></span>

### <a name="implementing-canconvertto"></a><span data-ttu-id="59907-187">CanConvertTo 구현</span><span class="sxs-lookup"><span data-stu-id="59907-187">Implementing CanConvertTo</span></span>

<span data-ttu-id="59907-188"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 구현은 `true` 형식의 `destinationType` 에 대해 <xref:System.String>를 반환하고, 그렇지 않은 경우 기본 구현에서 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-188">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span> <span data-ttu-id="59907-189"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>에서 예외를 throw하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-189">Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>.</span></span>

## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="59907-190">TypeConverterAttribute 적용</span><span class="sxs-lookup"><span data-stu-id="59907-190">Applying the TypeConverterAttribute</span></span>

<span data-ttu-id="59907-191">사용자 지정 형식 변환기를 .NET XAML 서비스에서 사용자 지정 클래스에 대해 작동 하는 형식 변환기로 사용 하려면를 <xref:System.ComponentModel.TypeConverterAttribute> 클래스 정의에 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-191">For your custom type converter to be used as the acting type converter for a custom class by .NET XAML Services, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="59907-192">특성을 통해 지정하는 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 은 사용자 지정 형식 변환기의 형식 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-192">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="59907-193">XAML 프로세서에서 속성 형식이 사용자 지정 클래스 형식을 사용하는 값을 처리할 때 이 특성을 적용하면 문자열을 입력하고 개체 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-193">If you apply this attribute, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>

<span data-ttu-id="59907-194">또한 속성별로 형식 변환기를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-194">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="59907-195">를 <xref:System.ComponentModel.TypeConverterAttribute> 클래스 정의에 적용 하는 대신 속성 정의 (기본 정의는 포함 되지 않음)에 적용 `get` / `set` 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-195">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="59907-196">속성의 형식은 사용자 지정 형식 변환기에서 처리되는 형식과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-196">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="59907-197">XAML 프로세서에서 해당 속성의 값을 처리할 때 이 특성을 적용하면 입력 문자열을 처리하고 개체 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-197">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="59907-198">Microsoft .NET Framework의 속성 형식 또는 클래스 정의를 제어할 수 없고 여기에 적용할 수 없는 일부 다른 라이브러리에서 속성 형식을 사용 하도록 선택 하는 경우에는 속성 형식 변환기 기술이 유용 합니다 <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="59907-198">The per-property type converter technique is useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>

<span data-ttu-id="59907-199">연결된 사용자 지정 멤버에 형식 변환 동작을 제공하려면 연결된 멤버에 대한 구현 패턴의 <xref:System.ComponentModel.TypeConverterAttribute> 접근자 메서드에 `Get` 를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-199">To supply a type conversion behavior for a custom attached member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get` accessor method of the implementation pattern for the attached member.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="59907-200">태그 확장 구현에서 서비스 공급자 컨텍스트 액세스</span><span class="sxs-lookup"><span data-stu-id="59907-200">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="59907-201">사용 가능한 서비스는 모든 값 변환기에서 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-201">The available services are the same for any value converter.</span></span> <span data-ttu-id="59907-202">차이점은 각 값 변환기에서 서비스 컨텍스트를 수신하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="59907-202">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="59907-203">서비스 액세스 및 사용 가능한 서비스는 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)항목에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-203">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="59907-204">XAML 노드 스트림의 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="59907-204">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="59907-205">XAML 노드 스트림을 사용하여 작업하는 경우 형식 변환기의 동작 또는 최종 결과가 아직 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-205">If you are working with a XAML node stream, the action or end result of a type converter is not yet executed.</span></span> <span data-ttu-id="59907-206">로드 경로에서 로드하기 위해 결국 형식 변환이 필요한 특성 문자열은 시작 멤버 및 종료 멤버 내에서 텍스트 값으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="59907-206">In a load path, the attribute string that eventually needs to be type-converted in order to load remains as a text value within a start member and end member.</span></span> <span data-ttu-id="59907-207">결국 이 작업에 필요한 형식 변환기는 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 속성을 사용하여 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="59907-207">The type converter that is eventually needed for this operation can be determined by using the <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="59907-208">그러나 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 에서 유효한 값을 가져오려면 기본 멤버를 통해 이러한 정보에 액세스할 수 있는 XAML 스키마 컨텍스트 또는 멤버에서 사용하는 개체 값의 형식을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-208">However, obtaining a valid value from <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses.</span></span> <span data-ttu-id="59907-209">또한 형식 변환 동작을 호출하려면 형식 매핑이 필요하고 변환기 인스턴스를 만들어야 하므로 XAML 스키마 컨텍스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="59907-209">Invoking the type conversion behavior also requires the XAML schema context because that requires type-mapping and creating a converter instance.</span></span>

## <a name="see-also"></a><span data-ttu-id="59907-210">참조</span><span class="sxs-lookup"><span data-stu-id="59907-210">See also</span></span>

- <xref:System.ComponentModel.TypeConverterAttribute>
- [<span data-ttu-id="59907-211">XAML을 위한 형식 변환기 및 태그 확장</span><span class="sxs-lookup"><span data-stu-id="59907-211">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="59907-212">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="59907-212">XAML Overview (WPF)</span></span>](../fundamentals/xaml.md)
