---
title: XAML 태그 확장 개요
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: efb41f31a3baa895b5739021af5fa36e32aefeea
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90556995"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="58173-102">XAML에 대 한 태그 확장 개요</span><span class="sxs-lookup"><span data-stu-id="58173-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="58173-103">태그 확장은 기본 형식이 나 특정 XAML 형식이 아닌 값을 가져오기 위한 XAML 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="58173-104">특성 사용과 관련하여 태그 확장은 여는 중괄호 `{` 의 알려진 문자 시퀀스를 사용하여 태그 확장 범위를 시작하고 닫는 중괄호 `}` 를 사용하여 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="58173-105">.NET XAML 서비스를 사용 하는 경우 system.xaml 어셈블리에서 미리 정의 된 몇 가지 XAML 언어 태그 확장을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="58173-106">System.Xaml에 정의된 <xref:System.Windows.Markup.MarkupExtension> 클래스에서 서브클래싱하고 고유한 태그 확장을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="58173-107">또는 해당 프레임 워크를 이미 참조 하 고 있는 경우 특정 프레임 워크에 의해 정의 된 태그 확장을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="58173-108">태그 확장 사용법에 액세스하는 경우 XAML 개체 작성기는 <xref:System.Windows.Markup.MarkupExtension> 재정의의 서비스 연결 지점을 통해 사용자 지정 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> 클래스에 서비스를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="58173-109">이 서비스는 사용법, 개체 작성기의 특정 기능, XAML 스키마 컨텍스트 등에 대한 컨텍스트를 가져오는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="58173-110">XAML 정의 태그 확장</span><span class="sxs-lookup"><span data-stu-id="58173-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="58173-111">몇 가지 태그 확장은 XAML 언어 지원을 위해 .NET XAML 서비스에 의해 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="58173-112">이러한 태그 확장은 XAML 언어 사양의 일부에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="58173-113">일반적인 사용법을 통해 알 수 있듯이 이러한 확장은 구문에서 `x:` 접두사로 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="58173-114">이러한 XAML 언어 요소에 대 한 .NET XAML 서비스 구현은 모두  <xref:System.Windows.Markup.MarkupExtension> 기본 클래스에서 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="58173-115">`x:` 접두사는 XAML 프로덕션의 루트 요소에서 XAML 언어 네임스페이스의 일반적인 XAML 네임스페이스 매핑에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="58173-116">예를 들어 다양 한 특정 프레임 워크에 대 한 Visual Studio 프로젝트 및 페이지 템플릿은이 매핑을 사용 하 여 XAML 파일을 시작 합니다 `x:` .</span><span class="sxs-lookup"><span data-stu-id="58173-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="58173-117">사용자 고유의 XAML 네임스페이스 매핑에서 다른 접두사 토큰을 선택할 수 있지만 이 설명서에서는 특정 프레임워크의 기본 XAML 네임스페이스나 다른 임의 CLR 또는 XML 네임스페이스와 달리 XAML 언어 XAML 네임 스페이스에서 정의된 부분인 해당 엔터티를 식별하는 방법으로 기본 `x:` 매핑을 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="58173-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="58173-118">x:Type</span></span>

<span data-ttu-id="58173-119">`x:Type` 은 명명된 형식에 <xref:System.Type> 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="58173-120">이 기능은 기본 CLR 형식 및 형식 파생을 그룹화 모니커 또는 식별자로 사용하는 지연 메커니즘에서 가장 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="58173-121">WPF 스타일 및 템플릿, `TargetType` 속성의 용도는 특정 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="58173-122">자세한 내용은 [x:Type Markup Extension](xtype-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="58173-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="58173-123">x:Static</span></span>

<span data-ttu-id="58173-124">`x:Static` 은 직접적으로 속성 값의 형식이 아니라 해당 형식으로 계산될 수 있는 값-형식 코드 엔터티에서 정적 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="58173-125">잘 알려진 상수로 형식 정의에 이미 존재하는 값을 지정하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="58173-126">자세한 내용은 [x:Static Markup Extension](xstatic-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="58173-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="58173-127">x:Null</span></span>

<span data-ttu-id="58173-128">`x:Null` 은 `null` 을 XAML 멤버에 대한 값으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="58173-129">특정 형식의 디자인인지 더 큰 프레임워크 개념인지에 따라 `null` 이 속성의 기본값이나 빈 문자열 특성의 암시적 값이 아닌 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="58173-130">자세한 내용은 [x:Null Markup Extension](xnull-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="58173-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="58173-131">x:Array</span></span>

<span data-ttu-id="58173-132">`x:Array` 는 기본 요소 및 컨트롤 모델에서 제공하는 컬렉션 지원이 의도적으로 사용되지 않는 경우 XAML 구문에서 일반적인 배열 만들기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="58173-133">자세한 내용은 [x:Array Markup Extension](xarray-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="58173-134">특히 XAML 2009에서 배열은 확장이 아닌 언어 기본 형식으로 액세스됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="58173-135">자세한 내용은 [XAML 2009 Language Features](xaml-2009-language-features.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="58173-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="58173-136">x:Reference</span></span>

<span data-ttu-id="58173-137">`x:Reference` 는 원래(2006) 언어 집합의 확장인 XAML 2009의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="58173-138">`x:Reference` 는 개체 그래프에 있는 다른 기존 개체에 대한 참조를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="58173-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="58173-139">해당 개체는 `x:Name`으로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="58173-140">자세한 내용은 [x:Reference Markup Extension](xreference-markup-extension.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="58173-141">기타 x: 구문</span><span class="sxs-lookup"><span data-stu-id="58173-141">Other x: Constructs</span></span>

<span data-ttu-id="58173-142">XAML 언어 기능을 지원하는 다른 `x:` 구문도 있지만 이러한 구문은 태그 확장으로 구현되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="58173-143">자세한 내용은 [XAML 네임스페이스(x:) 언어 기능](namespace-language-features.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="58173-144">MarkupExtension 기본 클래스</span><span class="sxs-lookup"><span data-stu-id="58173-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="58173-145">System.Xaml의 XAML 판독기 및 XAML 작성기 기본 구현과 상호 작용할 수 있는 사용자 지정 태그 확장을 정의하려면 추상 <xref:System.Windows.Markup.MarkupExtension> 클래스에서 클래스를 파생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="58173-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="58173-146">해당 클래스에는 재정의할 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>메서드가 한 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="58173-147">태그 확장 사용에 대한 인수 및 일치하는 설정 가능한 속성을 지원하기 위해 추가 생성자도 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="58173-148"><xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>를 통해 사용자 지정 태그 확장은 태그 확장이 XAML 프로세서에 의해 호출 되는 환경을 보고 하는 서비스 컨텍스트에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="58173-149">로드 경로에서는 일반적으로 <xref:System.Xaml.XamlObjectWriter> 입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="58173-150">저장 경로에서는 일반적으로 <xref:System.Xaml.XamlXmlWriter>입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="58173-151">각각은 서비스 공급자 패턴을 구현하는 내부 XAML 서비스 공급자 컨텍스트 클래스로 서비스 컨텍스트를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="58173-152">사용 가능한 서비스 및 해당 서비스가 나타내는 의미에 대한 자세한 내용은 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58173-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="58173-153">태그 확장 클래스는 공용 액세스 수준을 사용해야 합니다. XAML 프로세서는 해당 서비스를 사용하기 위해 태그 확장의 지원 클래스를 항상 인스턴스화할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="58173-154">사용자 지정 태그 확장에 대한 지원 형식 정의</span><span class="sxs-lookup"><span data-stu-id="58173-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="58173-155">.Net xaml 서비스 또는 .NET xaml 서비스에서 빌드하는 프레임 워크를 사용 하는 경우 태그 확장 지원 형식의 이름을 표시 하는 방법에 대 한 두 가지 선택 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="58173-156">형식 이름은 관련 XAML 개체 작성기가 XAML에서 태그 확장 사용에 도달할 경우 태그 확장 지원 형식에 액세스하고 호출하는 방법과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="58173-157">다음 명명 전략 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="58173-158">XAML 태그 사용 토큰과 정확하게 일치하도록 형식 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="58173-159">예를 들어 `{Collate ...}` 확장 사용을 지원하려면 지원 형식의 이름을 `Collate`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="58173-160">형식 이름이 사용 문자열 토큰과 접미사 `Extension`이 되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="58173-161">예를 들어 `{Collate ...}` 확장 사용을 지원하려면 지원 형식의 이름을 `CollateExtension`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="58173-162">조회 순서는 `Extension`접미사가 있는 클래스 이름을 먼저 찾은 다음 `Extension` 접미사 없이 클래스 이름을 찾는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="58173-163">태그 사용 관점에서 `Extension` 접미사를 사용의 일부로 포함하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="58173-164">그러나 `Extension` 이 실제로 클래스 이름의 일부인 것처럼 동작하며, 지원 클래스에 `Extension` 접미사가 없는 경우 XAML 개체 작성기에서 해당 사용에 대한 태그 확장 지원 클래스를 확인하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="58173-165">매개 변수가 없는 생성자</span><span class="sxs-lookup"><span data-stu-id="58173-165">The parameterless constructor</span></span>

<span data-ttu-id="58173-166">모든 태그 확장 지원 형식에 대해 매개 변수가 없는 public 생성자를 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="58173-167">XAML 개체 작성기가 개체 요소 사용에서 태그 확장을 인스턴스화하는 모든 경우에는 매개 변수가 없는 생성자가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="58173-168">개체 요소 사용 지원은 태그 확장, 특히 serialization에 크게 기대하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="58173-169">그러나 태그 확장의 특성 사용만 지원하려는 경우에는 public 생성자 없이 태그 확장을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="58173-170">태그 확장 사용에 인수가 없는 경우 사용을 지원 하려면 매개 변수가 없는 생성자가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="58173-171">사용자 지정 태그 확장에 대한 생성자 패턴 및 위치 인수</span><span class="sxs-lookup"><span data-stu-id="58173-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="58173-172">원하는 인수가 사용되는 태그 확장의 경우 public 생성자가 원하는 사용 모드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="58173-173">즉, 태그 확장이 하나의 위치 인수를 유효한 사용으로 요구하도록 디자인된 경우 위치 인수를 사용하는 하나의 입력 매개 변수로 public 생성자를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="58173-174">예를 들어 `Collate` 태그 확장이 해당 모드를 나타내고 `CollationMode` 열거형 상수로 지정된 하나의 위치 인수가 있는 모드만 지원하도록 되어 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="58173-175">이런 경우 다음과 같은 형식의 생성자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="58173-176">기본적인 수준에서 태그 확장으로 전달된 인수는 태그의 특성 값에서 전달되기 때문에 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="58173-177">모든 인수를 문자열로 만들고 해당 수준에서 입력 작업을 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="58173-178">그러나 태그 확장 인수가 지원 클래스에 전달되기 전에 발생하는 특정 처리에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="58173-179">개념적으로 처리는 태그 확장이 만들려는 개체인 것처럼 작동한 다음 해당 멤버 값이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="58173-180">설정하도록 지정된 각 속성은 XAML을 구문 분석할 때 만든 개체에서 지정된 멤버를 설정하는 방법과 유사하게 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="58173-181">다음과 같은 두 가지 중요한 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-181">There are two important differences:</span></span>

- <span data-ttu-id="58173-182">앞에서 설명한 대로 태그 확장 지원 형식은 XAML에서 인스턴스화하기 위해 매개 변수가 없는 생성자를 가질 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="58173-183">해당 개체 생성은 텍스트 구문에서 가능한 인수가 위치 인수나 명명된 인수로 토큰화되고 계산될 때까지 지연되고 그때 적절한 생성자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="58173-184">태그 확장 사용은 중첩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="58173-185">가장 안쪽의 태그 확장이 먼저 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="58173-186">따라서 이러한 사용을 가정하고 생성 매개 변수 중 하나를 값 변환기(예: 태그 확장)에서 생성해야 하는 형식으로 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="58173-187">이러한 처리에 의존하는 경우는 이전 예제에 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="58173-188">.NET XAML 서비스 XAML 개체 작성기는 열거형 상수 이름을 기본 수준에서 열거 된 값으로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="58173-189">또한 태그 확장 위치 매개 변수의 텍스트 구문 처리에서는 생성 인수에 있는 형식과 연결된 형식 변환기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="58173-190">사용에서 토큰 발생 순서가 할당된 생성자 매개 변수의 위치 순서에 해당하기 때문에 이러한 인수를 위치 인수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="58173-191">예를 들어 다음과 같은 생성자 서명을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="58173-192">XAML 프로세서는 이 태그 확장에 대해 두 개의 위치 인수를 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="58173-193">`{Collate AlphaUp,{x:Reference circularFile}}`사용이 있는 경우 `AlphaUp` 토큰은 첫 번째 매개 변수로 전달되고 `CollationMode` 열거형 명명된 상수로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="58173-194">내부 `x:Reference` 의 결과는 두 번째 매개 변수를 전달되고 개체로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="58173-195">태그 확장 구문 및 처리에 대한 XAML 지정 규칙에서 쉼표는 해당 인수가 위치 인수인지 명명된 인수인지에 관계없이 인수 사이의 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="58173-196">위치 인수의 중복 인자</span><span class="sxs-lookup"><span data-stu-id="58173-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="58173-197">XAML 개체 작성기에서 위치 인수가 있는 태그 확장 사용이 발견되는 경우 해당 개수의 인수를 사용하는 여러 생성자 인수(중복 인자)가 있어도 반드시 오류가 발생하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="58173-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="58173-198">이 동작은 사용자 지정 가능한 XAML 스키마 컨텍스트 설정인 <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="58173-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="58173-199"><xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 가 `true`인 경우 XAML 개체 작성기는 중복 인자라는 이유만으로 예외를 throw해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="58173-200">해당 지점을 벗어난 동작이 엄격하게 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="58173-201">기본 디자인에서는 스키마 컨텍스트가 특정 매개 변수에 사용할 수 있는 형식 정보를 포함하고 중복 후보자와 일치하는 명시적 캐스팅을 시도하여 가장 잘 일치하는 서명을 확인한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="58173-202">서명이 XAML 개체 작성기에서 실행되는 해당 특정 스키마 컨텍스트에서 적용되는 테스트를 통과할 수 없는 경우 예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="58173-203">기본적으로 <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 는 `false` .Net XAML 서비스용 CLR 기반에 <xref:System.Xaml.XamlSchemaContext> 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="58173-204">따라서 지원 형식의 생성자에 중복 인자가 있는 태그 확장 사용이 발견되는 경우 기본 <xref:System.Xaml.XamlObjectWriter> 는 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="58173-205">사용자 지정 태그 확장에 대 한 명명 된 인수</span><span class="sxs-lookup"><span data-stu-id="58173-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="58173-206">XAML로 지정된 태그 확장은 사용에 명명된 인수 형태를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="58173-207">첫 번째 토큰화 수준에서 텍스트 구문이 인수로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="58173-208">인수 내에 등호 기호(=)가 있는 인수는 명명된 인수로 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="58173-209">또한 이러한 인수는 이름/값 쌍으로 토큰화됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="58173-210">이 경우 이름은 태그 확장 지원 형식의 설정 가능한 공용 속성 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="58173-211">명명된 인수 사용을 지원하려면 이러한 설정 가능한 공용 속성을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="58173-212">이 속성은 공용으로 유지되는 한 상속된 속성일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="58173-213">태그 확장 구현에서 서비스 공급자 컨텍스트 액세스</span><span class="sxs-lookup"><span data-stu-id="58173-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="58173-214">사용 가능한 서비스는 모든 값 변환기에서 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="58173-215">차이점은 각 값 변환기에서 서비스 컨텍스트를 수신하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="58173-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="58173-216">서비스 액세스 및 사용 가능한 서비스는 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)항목에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="58173-217">태그 확장의 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="58173-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="58173-218">태그 확장 사용에 대한 시나리오는 종종 특성 사용에서 태그 확장을 사용하여 설계됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="58173-219">그러나 지원 클래스를 정의하여 속성 요소 사용을 지원할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="58173-220">태그 확장의 속성 요소 사용을 지원 하려면 매개 변수가 없는 public 생성자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="58173-221">이 생성자는 정적 생성자가 아닌 인스턴스 생성자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="58173-222">일반적으로 XAML 프로세서는 태그에서 처리 하는 모든 개체 요소에서 매개 변수가 없는 생성자를 호출 해야 하기 때문에이 작업이 필요 합니다. 여기에는 태그 확장 클래스가 개체 요소로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="58173-223">고급 시나리오의 경우 클래스에 대해 기본이 아닌 생성 경로를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="58173-224">자세한 내용은 [X:FactoryMethod 지시문](xfactorymethod-directive.md)을 참조 하세요. 그러나 이러한 패턴을 태그 확장 용도로 사용 하면 디자이너와 원시 태그 사용자 모두 사용 패턴을 검색 하기가 훨씬 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="58173-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="58173-225">사용자 지정 태그 확장에 대 한 특성 지정</span><span class="sxs-lookup"><span data-stu-id="58173-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="58173-226">디자인 환경과 특정 XAML 개체 작성기 시나리오를 모두 지원하려면 여러 가지 CLR 특성으로 태그 확장 지원 형식의 특성을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="58173-227">이러한 특성은 의도된 태그 확장 사용을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="58173-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> 는 <xref:System.Type> 에서 반환하는 개체 형식에 대한 <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 정보를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="58173-229">순수 서명에 따라 <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 는 <xref:System.Object>를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="58173-230">그러나 다양한 소비자는 보다 정확한 반환 형식 정보를 원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="58173-231">다음 내용이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-231">This includes:</span></span>

- <span data-ttu-id="58173-232">태그 확장 사용에 대한 형식 인식 지원을 제공할 수 있는 디자이너 및 IDE.</span><span class="sxs-lookup"><span data-stu-id="58173-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="58173-233">대상 클래스의 `SetMarkupExtension` 처리기 고급 구현으로, 알려진 특정 <xref:System.Windows.Markup.MarkupExtension> 구현을 이름별로 분기하는 대신 리플렉션을 사용하여 태그 확장의 반환 형식을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="58173-234">태그 확장 사용의 Serialization</span><span class="sxs-lookup"><span data-stu-id="58173-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="58173-235">XAML 개체 작성기에서 태그 확장 사용을 처리하고 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>를 호출하면 이전의 태그 확장 사용에 대한 컨텍스트가 개체 그래프가 아닌 XAML 노드 스트림에 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="58173-236">개체 그래프에서는 값만 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="58173-237">원래 태그 확장 사용을 직렬화된 출력으로 유지해야 하는 다른 이유나 디자인 시나리오가 있는 경우 로드 경로 XAML 노드 스트림에서 태그 확장 사용을 추적하기 위한 고유 인프라를 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="58173-238">로드 경로에서 노드 스트림의 요소를 다시 만드는 동작을 구현하고 저장 경로에서 serialization을 위해 XAML 작성기로 다시 재생하여 노드 스트림의 적절한 위치에 있는 값을 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="58173-239">XAML 노드 스트림의 태그 확장</span><span class="sxs-lookup"><span data-stu-id="58173-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="58173-240">로드 경로에서 XAML 노드 스트림을 사용하여 작업하는 경우 태그 확장 사용은 개체로 노드 스트림에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="58173-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="58173-241">태그 확장 사용에서 위치 인수를 사용하는 경우 초기화 값을 가진 시작 개체로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="58173-242">대략적인 텍스트 표현으로 노드 스트림은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="58173-243">`StartObject` (<xref:System.Xaml.XamlType> 은 반환 형식이 아니라 태그 확장의 정의 형식임)</span><span class="sxs-lookup"><span data-stu-id="58173-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="58173-244">`StartMember` ( <xref:System.Xaml.XamlMember> 의 이름은 `_InitializationText`임)</span><span class="sxs-lookup"><span data-stu-id="58173-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="58173-245">`Value` (값은 사이의 구분 기호를 포함하는 문자열로의 위치 인수임)</span><span class="sxs-lookup"><span data-stu-id="58173-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="58173-246">명명된 인수를 사용하는 태그 확장 사용은 관련 이름의 멤버가 있는 개체로 표현되고, 각각은 텍스트 문자열 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58173-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="58173-247">실제로 태그 확장의 `ProvideValue` 구현을 호출하려면 형식 매핑이 필요하고 태그 확장 지원 형식 인스턴스를 만들어야 하기 때문에 XAML 스키마 컨텍스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="58173-248">이러한 이유로 태그 확장 사용이 기본 .NET XAML 서비스 노드 스트림에서 이런 방식으로 유지 됩니다. 로드 경로의 판독기 부분에서 필요한 XAML 스키마 컨텍스트를 사용할 수 없는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="58173-249">일반적으로 저장 경로에서 XAML 노드 스트림을 사용하여 작업하는 경우 직렬화할 개체가 처음에는 태그 확장 사용 및 `ProvideValue` 결과에서 제공되었음을 알릴 수 있는 것이 개체 그래프 표현에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="58173-250">라운드트립에 대한 태그 확장 사용을 유지하면서 개체 그래프의 다른 변경 내용도 캡처해야 하는 시나리오에서는 원래 XAML 입력에서 태그 확장 사용에 대한 지식을 유지할 수 있는 고유한 기술을 고안해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58173-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="58173-251">예를 들어 태그 확장 사용을 복원하려면 저장 경로의 노드 스트림에서 작업하여 태그 확장 사용을 복원하거나 원래 XAML과 라운드트립 XAML 간에 병합을 수행해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="58173-252">WPF와 같은 일부 XAML 구현 프레임워크에서는 중간 형식(식)을 사용하여 태그 확장 사용에서 값을 제공한 경우를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58173-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="58173-253">추가 정보</span><span class="sxs-lookup"><span data-stu-id="58173-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="58173-254">XAML을 위한 형식 변환기 및 태그 확장</span><span class="sxs-lookup"><span data-stu-id="58173-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="58173-255">태그 확장명 및 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="58173-255">Markup Extensions and WPF XAML</span></span>](/dotnet/desktop/wpf/advanced/markup-extensions-and-wpf-xaml)
