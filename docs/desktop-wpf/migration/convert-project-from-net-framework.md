---
title: WPF 앱을 .NET Core 3.0으로 마이그레이션
description: WPF(Windows Presentation Foundation) 앱을 .NET Core 3.0으로 마이그레이션하는 방법을 알아봅니다.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: fda4f618ddb4a3edbe6f2dd9fba0b10bc618e88d
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/29/2020
ms.locfileid: "84201568"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="5c114-103">WPF 앱을 .NET Core로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="5c114-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="5c114-104">이 문서에서는 WPF(Windows Presentation Foundation) 앱을 .NET Framework에서 .NET Core 3.0으로 마이그레이션하는 데 필요한 단계를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="5c114-105">이식할 WPF 앱이 없지만 프로세스를 시도해보려면 [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)에 제공되는 **Bean Trader** 샘플 앱을 사용하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="5c114-106">원래 앱(.NET Framework 4.7.2 대상)은 NetFx\BeanTraderClient 폴더에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="5c114-107">먼저 앱을 이식하는 데 필요한 일반인 단계를 설명한 다음, **Bean Trader** 샘플에 적용되는 특정한 변경 사항을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="5c114-108">.NET Core로 마이그레이션하려면 먼저 다음을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="5c114-109">NuGet 종속성 이해 및 업데이트:</span><span class="sxs-lookup"><span data-stu-id="5c114-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="5c114-110">`<PackageReference>` 형식을 사용하도록 NuGet 종속성을 업그레이드합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="5c114-111">.NET Core 또는 .NET Standard 호환성에 대한 최상위 NuGet 종속성을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="5c114-112">NuGet 패키지를 최신 버전으로 업그레이드합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="5c114-113">[.NET 이식성 분석기](../../standard/analyzers/portability-analyzer.md)를 사용하여 .NET 종속성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="5c114-114">프로젝트 파일을 새로운 SDK 스타일 형식으로 마이그레이션:</span><span class="sxs-lookup"><span data-stu-id="5c114-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="5c114-115">.NET Core와 .NET Framework 모두를 대상으로 할지, 아니면 .NET Core만 대상으로 할지 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="5c114-116">관련 프로젝트 파일 속성 및 항목을 새 프로젝트 파일에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="5c114-117">빌드 문제 해결:</span><span class="sxs-lookup"><span data-stu-id="5c114-117">Fix build issues:</span></span>

    01. <span data-ttu-id="5c114-118">[Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) 패키지에 대한 참조를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="5c114-119">API 수준의 차이를 찾아서 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="5c114-120">`appSettings` 또는 `connectionStrings`가 아닌 *app.config* 섹션을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="5c114-121">필요한 경우 생성된 코드를 다시 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="5c114-122">런타임 테스트:</span><span class="sxs-lookup"><span data-stu-id="5c114-122">Runtime testing:</span></span>

    01. <span data-ttu-id="5c114-123">이식된 앱이 예상대로 작동하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="5c114-124"><xref:System.NotSupportedException> 예외에 유의합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="5c114-125">샘플 정보</span><span class="sxs-lookup"><span data-stu-id="5c114-125">About the sample</span></span>

<span data-ttu-id="5c114-126">이 문서에서는 [Bean Trader 샘플 앱](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)을 참조합니다. 이 앱에는 실제 WPF 앱에 사용되는 종속성과 유사한 종속성이 다양하게 사용되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="5c114-127">이 앱은 크지 않지만 복잡성 측면에서 'Hello World'에서 한 단계 업그레이드된 앱입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="5c114-128">이 앱은 실제 앱을 이식하는 동안 발생할 수 있는 몇 가지 문제를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="5c114-129">이 앱은 WCF 서비스와 통신하기 때문에 제대로 실행되려면, BeanTraderServer 프로젝트(동일한 GitHub 리포지토리에서 사용 가능)를 실행하고 BeanTraderClient 구성이 올바른 엔드포인트를 가리키도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="5c114-130">(기본적으로 이 샘플은 서버가 `http://localhost:8090`의 동일한 컴퓨터에서 실행되는 것으로 가정하며, BeanTraderServer를 로컬에서 시작하면 동일한 상황이 됩니다.)</span><span class="sxs-lookup"><span data-stu-id="5c114-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="5c114-131">이 샘플 앱으로 .NET Core 이식의 어려움과 솔루션을 시연할 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="5c114-132">WPF 모범 사례를 시연하려는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="5c114-133">사실은, 이식하는 동안 적어도 몇 가지 흥미로운 문제가 발생할 수 있도록 몇 가지 안티 패턴이 의도적으로 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="5c114-134">준비</span><span class="sxs-lookup"><span data-stu-id="5c114-134">Getting ready</span></span>

<span data-ttu-id="5c114-135">.NET Framework 앱을 .NET Core로 마이그레이션하는 경우 주된 문제는, 종속성이 다르게 작동하거나 전혀 작동하지 않을 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="5c114-136">마이그레이션은 이전보다 훨씬 더 쉬워졌고 이제 많은 NuGet 패키지가 .NET Standard를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="5c114-137">.NET Core 2.0부터는 .NET Framework와 .NET Core의 노출 영역이 비슷해졌습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="5c114-138">그래도 몇 가지 차이점(NuGet 패키지의 지원 및 사용 가능한 .NET API)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="5c114-139">마이그레이션의 첫 단계는 앱의 종속성을 검토하고 참조가 .NET Core로 쉽게 마이그레이션되는 형식인지 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="5c114-140">`<PackageReference>` NuGet 참조로 업그레이드</span><span class="sxs-lookup"><span data-stu-id="5c114-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="5c114-141">이전 .NET Framework 프로젝트는 NuGet 종속성이 일반적으로 *packages.config* 파일에 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="5c114-142">새로운 SDK 스타일 프로젝트 파일 형식은 NuGet 패키지를 별도의 구성 파일이 아닌 csproj 파일 자체의 [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) 요소로 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="5c114-143">마이그레이션할 때 `<PackageReference>` 스타일 참조를 사용하면 두 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="5c114-144">이 스타일은 새 .NET Core 프로젝트 파일에 필요한 NuGet 참조 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="5c114-145">`<PackageReference>`를 이미 사용하고 있으면, 해당 프로젝트 파일 요소를 복사하여 새 프로젝트에 바로 붙여넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="5c114-146">packages.config 파일과 달리 `<PackageReference>` 요소는 프로젝트가 직접 종속된 최상위 종속성만 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="5c114-147">다른 모든 전이적 NuGet 패키지는 복원 시 결정되며 자동 생성된 obj\project.assets.json 파일에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="5c114-148">따라서, 프로젝트의 종속성을 훨씬 더 쉽게 확인할 수 있기 때문에 필요한 종속성이 .NET Core에서 작동할지 여부를 확인할 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="5c114-149">.NET Framework 앱을 .NET Core로 마이그레이션하는 첫 번째 단계는 `<PackageReference>` NuGet 참조를 사용하도록 업데이트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="5c114-150">Visual Studio를 사용하면 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="5c114-151">Visual Studio의 **솔루션 탐색기**에서 프로젝트의 *packages.config* 파일을 마우스 오른쪽 단추로 클릭한 다음, **packages.config를 PackageReference로 마이그레이션**을 선택하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![PackageReference로 업그레이드](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="5c114-153">계산된 최상위 NuGet 종속성을 보여주는 대화 상자가 나타나고, 다른 어떤 NuGet 패키지를 최상위 수준으로 승격해야 하는지 묻는 메시지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="5c114-154">다른 패키지 중에 Bean Trader 샘플의 최상위 수준으로 승격해야 하는 패키지가 없으므로, 해당 확인란의 선택을 모두 취소하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="5c114-155">그런 다음, **Ok**을 클릭하면 *packages.config* 파일이 제거되고 `<PackageReference>` 요소가 프로젝트 파일에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="5c114-156">`<PackageReference>` 스타일 참조는 NuGet 패키지를 로컬 패키지 폴더에 저장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="5c114-157">대신, 최적화로 전역적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="5c114-158">마이그레이션이 완료되면 csproj 파일을 편집하고 이전에 *..\packages* 디렉터리에서 가져온 분석기를 참조하는 `<Analyzer>` 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="5c114-159">그래도 NuGet 패키지 참조가 아직 있기 때문에 분석기는 프로젝트에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="5c114-160">이전 packages.config 스타일 `<Analyzer>` 요소만 정리하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="5c114-161">NuGet 패키지 검토</span><span class="sxs-lookup"><span data-stu-id="5c114-161">Review NuGet packages</span></span>

<span data-ttu-id="5c114-162">이제 프로젝트가 종속된 최상위 NuGet 패키지를 볼 수 있으므로, .NET Core에서 해당 패키지를 사용할 수 있는지 여부를 검토할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="5c114-163">[nuget.org](https://www.nuget.org/)에 대한 종속성을 살펴보고 패키지가 .NET Core를 지원하는지 여부를 확인할 수 있습니다. 커뮤니티에서 만든 [fuget.org](https://www.fuget.org/) 사이트에는 이 정보가 패키지 정보 페이지 맨 위에 두드러지게 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="5c114-164">.NET Core 3.0을 대상으로 하는 경우 .NET Core 또는 .NET Standard를 대상으로 하는 모든 패키지가 작동해야 합니다. (.NET Core는 .NET Standard 노출 영역을 구현하기 때문입니다.)</span><span class="sxs-lookup"><span data-stu-id="5c114-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="5c114-165">사용되는 특정 버전의 패키지는 .NET Core나 .NET Standard를 대상으로 하지 않지만 최신 버전은 대상으로 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="5c114-166">이런 경우에는 최신 버전의 패키지로 업그레이드하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="5c114-167">.NET Framework를 대상으로 하는 패키지도 사용할 수 있지만 약간의 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="5c114-168">.NET Core와 .NET Framework 노출 영역은 종속성이 대체로 작동할 만큼 유사하기 때문에, .NET Core에서 .NET Framework로 종속성은 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="5c114-169">하지만, 패키지가 .NET Core에 없는 .NET API를 사용하려고 하면 런타임 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="5c114-170">따라서 다른 옵션이 없는 경우에만 .NET Framework 패키지를 참조해야 하며 이렇게 하면 테스트 부담이 발생한다는 것을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="5c114-171">.NET Core나 .NET Standard를 대상으로 하지 않는 패키지가 참조된 경우에는 다른 대안을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="5c114-172">대신 사용할 수 있는 다른 유사한 패키지가 있나요?</span><span class="sxs-lookup"><span data-stu-id="5c114-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="5c114-173">NuGet 작성자가 특히 .NET Core를 대상으로 하는 별도의 '.Core' 버전 라이브러리를 게시하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="5c114-174">엔터프라이즈 라이브러리 패키지는 커뮤니티 게시 ".NetCore" 대안의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="5c114-175">다른 경우에는 특정 서비스에 대한 최신 SDK를(때로는 다른 패키지 이름으로) .NET Standard에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="5c114-176">대안이 없으면 .NET Framework 대상 패키지를 계속 사용할 수 있습니다. 다만, .NET Core에서 실행한 후에는 철저한 테스트가 필요하다는 점에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="5c114-177">Bean Trader 샘플에 있는 최상위 NuGet 종속성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="5c114-178">**Castle.Windsor, 버전 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="5c114-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="5c114-179">이 패키지는 .NET Standard 1.6을 대상으로 하므로 .NET Core에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="5c114-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, 버전 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="5c114-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="5c114-181">메타 패키지이므로 어떤 플랫폼을 지원하는지가 즉시 분명하지는 않지만, 최신 버전(2.9.2)이 .NET Framework와 .NET Core 모두에서 작동한다는 내용이 [설명서](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="5c114-182">**Nito.AsyncEx, 버전 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="5c114-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="5c114-183">이 패키지는 .NET Core를 대상으로 하지 않지만 최신 5.0 버전은 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="5c114-184">최근 많은 NuGet 패키지에 .NET Standard 지원이 추가되었지만 이전 프로젝트 버전은 .NET Framework만 대상으로 하기 때문에, 마이그레이션하는 경우 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="5c114-185">버전 차이가 작으면 최신 버전으로 업그레이드하기 쉬운 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="5c114-186">이 경우에는 버전 차이가 크기 때문에 패키지에 호환성이 손상되는 변경이 있을 수 있으므로 주의하여 업그레이드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="5c114-187">하지만 방법이 있으므로 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="5c114-188">**MahApps.Metro, 버전 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="5c114-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="5c114-189">이 패키지도 .NET Core를 대상으로 하지 않지만 최신 시험판(2.0-alpha)은 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="5c114-190">역시, 호환성이 손상되는 변경이 있는지 확인해야 하지만, 최신 패키지를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="5c114-191">Bean Trader 샘플의 NuGet 종속성은 모두 .NET Standard/.NET Core를 대상으로 하거나, 이것을 대상으로 하는 최신 버전이 있습니다. 따라서 차단 문제가 있을 가능성은 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="5c114-192">NuGet 패키지 업그레이드</span><span class="sxs-lookup"><span data-stu-id="5c114-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="5c114-193">가능하면, .NET Core나 .NET Standard만 대상으로 하는 패키지 버전을 이 시점(프로젝트가 아직 .NET Framework를 대상으로 하는)에 최신 버전으로 업그레이드하여 호환성이 손상되는 변경이 있으면 초기에 찾아서 처리하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="5c114-194">기존 .NET Framework 버전의 앱을 실질적으로 변경하지 않으려면, .NET Core를 대상으로 하는 새 프로젝트 파일이 준비될 때까지 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="5c114-195">하지만 NuGet 패키지를 .NET Core 호환 버전으로 미리 업그레이드하고 새 프로젝트 파일을 만들면 마이그레이션 프로세스가 훨씬 더 쉬워지고, .NET Framework 버전과 .NET Core 버전 앱의 차이가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="5c114-196">Bean Trader 샘플을 사용하면, 필요한 모든 업그레이드를 쉽게 수행할 수 있지만(Visual Studio의 NuGet 패키지 관리자를 사용하여) 한 가지 예외가 있습니다. **MahApps.Metro 1.6.5**에서 **2.0**으로 업그레이드하면 테마 및 강조 관리 API와 관련하여 호환성이 손상되는 변경이 드러납니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="5c114-197">앱이 최신 버전의 패키지를 사용하도록 업데이트되는 것이 가장 좋습니다(.NET Core에서 작동할 가능성이 높기 때문).</span><span class="sxs-lookup"><span data-stu-id="5c114-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="5c114-198">하지만 이 방법이 적합하지 않은 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="5c114-199">이러한 경우 **MahApps.Metro**를 업그레이드하지 마십시오. 필요한 변경 사항이 사소하지 않으며, 이 자습서는 **MahApps.Metro 2.** 가 아닌 .NET Core 3으로 마이그레이션하는 데 중점을 두고 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="5c114-200">또한 Bean Trader 앱은 **MahApps.Metro**의 작은 부분만 실행하기 때문에 위험 수준이 낮은 .NET Framework 종속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="5c114-201">물론 마이그레이션이 완료되면 모든 것이 제대로 작동하는지 확인하는 테스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="5c114-202">실제 시나리오인 경우 마이그레이션을 수행하지 않으면 기술적인 문제를 남기기 때문에 **MahApps.Metro** 버전 2.0으로 이동하는 작업을 추적하는 문제를 제기하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="5c114-203">NuGet 패키지가 최신 버전으로 업데이트되면 Bean Trader 샘플 프로젝트 파일의 `<PackageReference>` 항목 그룹은 다음과 같은 모양입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="5c114-204">.NET Framework 이식성 분석</span><span class="sxs-lookup"><span data-stu-id="5c114-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="5c114-205">프로젝트의 NuGet 종속성 상태를 이해했으면, 다음으로 고려할 사항은 .NET Framework API 종속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="5c114-206">[.NET 이식성 분석기](../../standard/analyzers/portability-analyzer.md) 도구는 프로젝트에 사용되는 .NET API 중 어떤 API를 다른 .NET 플랫폼에서 사용할 수 있는지 파악하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="5c114-207">이 도구는 [Visual Studio 플러그인](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), [명령줄 도구](https://github.com/Microsoft/dotnet-apiport/releases)로 제공되거나 [간단한 GUI](https://github.com/Microsoft/dotnet-apiport-ui)로 래핑되어 옵션을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="5c114-208">GUI를 사용하여 .NET 이식성 분석기(API 포트)를 사용하는 방법에 대한 자세한 내용은 [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)(데스크톱 앱을 .NET Core로 이식) 블로그 게시물을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5c114-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="5c114-209">명령줄을 사용하려는 경우 필요한 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="5c114-210">[.NET 이식성 분석기](https://github.com/Microsoft/dotnet-apiport/releases)가 아직 없으면 다운로드합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="5c114-211">이식할 .NET Framework 앱이 성공적으로 빌드되었는지 확인합니다. (마이그레이션하기 전에 수행하는 것이 좋습니다.)</span><span class="sxs-lookup"><span data-stu-id="5c114-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="5c114-212">아래와 같은 명령줄을 사용하여 API 포트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="5c114-213">`-f` 인수는 분석할 이진이 포함된 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="5c114-214">`-r` 인수는 원하는 출력 파일 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="5c114-215">`-t` 인수는 API 사용을 분석할 .NET 플랫폼을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="5c114-216">이 경우에는 .NET Core가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="5c114-217">HTML 보고서를 열면 첫 번째 섹션에는 분석된 모든 이진과 대상 플랫폼에서 사용할 수 있는 .NET API의 백분율이 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="5c114-218">백분율 자체로는 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="5c114-219">누락된 특정 API를 보는 것이 더 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="5c114-220">이렇게 하려면 어셈블리 이름을 선택하거나 개별 어셈블리에 대한 보고서까지 아래로 스크롤합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="5c114-221">소스 코드를 소유하는 어셈블리에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="5c114-222">예를 들어 Bean Trader ApiPort 보고서에는 많은 이진이 나열되지만 대부분이 NuGet 패키지에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="5c114-223">`Castle.Windsor`는 .NET Core에 없는 몇 가지 System.Web API에 종속된 것으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="5c114-224">이 점은 `Castle.Windsor`가 .NET Core를 지원한다는 것을 이전에 확인했으므로 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="5c114-225">NuGet 패키지에는 다양한 .NET 플랫폼에 사용할 서로 다른 이진이 있는 것이 일반적입니다. 따라서 패키지가 .NET Standard나 .NET Core(이 경우 대상임)를 대상으로 하는 한 `Castle.Windsor`의 .NET Framework 버전이 System.Web API를 사용하는지 여부는 상관이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="5c114-226">Bean Trader 샘플에서 고려해야 하는 유일한 이진은 **BeanTraderClient**이며 보고서에는 두 가지 .NET API 즉, `System.ServiceModel.ClientBase<T>.Close` 및 `System.ServiceModel.ClientBase<T>.Open`만 없는 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient 이식성 보고서](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="5c114-228">WCF 클라이언트 API는 .NET Core에서 (대부분) 지원되기 때문에 차단 문제가 발생할 가능성이 낮습니다. 따라서 중앙 API에 사용 가능한 대안이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="5c114-229">실제로 `System.ServiceModel`의 .NET Core 노출 영역(<https://apisof.net> 사용)을 살펴보면, .NET Core에 비동기 대안이 있는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="5c114-230">이 보고서와 이전 NuGet 종속성 분석에 기반하면, Bean Trader 샘플을 .NET Core로 마이그레이션하는 데 큰 문제가 없는 것으로 보입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="5c114-231">실제로 마이그레이션을 시작하는 다음 단계를 수행할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="5c114-232">프로젝트 파일 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="5c114-232">Migrating the project file</span></span>

<span data-ttu-id="5c114-233">앱에 새로운 [SDK 스타일 프로젝트 파일 형식](../../core/tools/csproj.md)이 사용되지 않으면 .NET Core를 대상으로 하는 새 프로젝트 파일이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="5c114-234">기존 csproj 파일을 교체하거나, 기존 프로젝트를 현재 상태에서 그대로 유지하려면 .NET Core를 대상으로 하는 새 csproj 파일을 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="5c114-235">[멀티 타기팅](../../standard/library-guidance/cross-platform-targeting.md)(여러 `<TargetFrameworks>` 대상 지정)이 포함된 단일 SDK 스타일 프로젝트 파일을 사용하여 .NET Framework와 .NET Core용 앱 버전을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="5c114-236">새 프로젝트 파일을 만들려면 Visual Studio에서 새 WPF 프로젝트를 만들거나, 임시 디렉터리에서 `dotnet new wpf` 명령을 사용하여 프로젝트 파일을 만든 다음, 올바른 위치로 복사하고 이름을 변경하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="5c114-237">커뮤니티에서 만든 도구인 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)도 있으며, 프로젝트 파일 마이그레이션의 일부를 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="5c114-238">이 도구는 유용하지만 그래도 사람이 결과를 검토하여 마이그레이션의 모든 세부 사항이 올바른지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="5c114-239">이 도구가 최적으로 처리하지 못하는 한 가지 영역은 *packages.config* 파일에서 NuGet 패키지를 마이그레이션하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="5c114-240">*packages.config* 파일을 사용하여 NuGet 패키지를 참조하는 프로젝트 파일에서 도구를 실행하면, `<PackageReference>` 요소로 자동 마이그레이션되지만 최상위 패키지뿐만 아니라 모든 패키지에 대해 `<PackageReference>` 요소가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="5c114-241">Visual Studio를 사용하여 `<PackageReference>` 요소로 이미 마이그레이션한 경우에는(이 샘플에서 수행한 것처럼), 이 도구가 나머지 변환에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="5c114-242">Scott Hanselman이 [csproj 파일 마이그레이션에 대한 블로그 게시물](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)에서 권장하듯이, 수동으로 이식하면 교육적이며 이식할 프로젝트가 적다면 더 나은 결과를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="5c114-243">하지만 수십 또는 수백 개의 프로젝트 파일을 이식하는 경우에는 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)과 같은 도구가 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="5c114-244">Bean Trader 샘플에 대한 새 프로젝트 파일을 만들려면 임시 디렉터리에서 `dotnet new wpf`를 실행하여 생성된 *.csproj* 파일을 *BeanTraderClient* 폴더로 옮기고 이름을 **BeanTraderClient.Core.csproj**로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="5c114-245">새 프로젝트 파일 형식에는 C# 파일, *resx* 파일, XAML 파일이 해당 디렉터리 내에 자동으로 포함되기 때문에 프로젝트 파일은 이미 거의 완성되었습니다!</span><span class="sxs-lookup"><span data-stu-id="5c114-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="5c114-246">마이그레이션을 마치려면 이전 프로젝트 파일과 새 프로젝트 파일을 나란히 열어두고 이전 파일을 살펴보면서 포함된 정보 중 마이그레이션이 필요한 정보가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="5c114-247">Bean Trader 샘플의 경우, 다음 항목을 새 프로젝트에 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="5c114-248">`<RootNamespace>`, `<AssemblyName>`, `<ApplicationIcon>` 속성을 모두 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="5c114-249">Bean Trader 샘플은 AssemblyInfo.cs 파일에 어셈블리 수준 속성(예: `[AssemblyTitle]`)이 포함되어 있기 때문에 새 프로젝트 파일에 `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` 속성도 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="5c114-250">기본적으로 새 SDK 스타일 프로젝트는 csproj 파일의 속성을 기반으로 이러한 특성을 자동으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="5c114-251">이 경우에는 이렇게 수행되는 것을 원하지 않기 때문에(자동 생성된 특성이 AssemblyInfo.cs의 특성과 충돌함), `<GenerateAssemblyInfo>`를 사용하여 자동 생성된 특성을 비활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="5c114-252">*resx* 파일은 포함된 리소스로 자동 포함되지만 이미지와 같은 다른 `<Resource>` 항목은 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="5c114-253">따라서 이미지와 아이콘 파일을 포함하기 위해 `<Resource>` 요소를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="5c114-254">와일드 카드 사용 패턴(`<Resource Include="**\*.png" />`)에 대한 새 프로젝트 파일 형식의 지원을 사용하면 png 참조를 한 줄로 간소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="5c114-255">마찬가지로 `<None>` 항목은 자동으로 포함되지만, 기본적으로 출력 디렉터리에 복사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="5c114-256">Bean Trader 프로젝트에는 출력 디렉터리에 복사된(`PreserveNewest` 동작을 사용하여) `<None>` 항목이 포함되어 있기 때문에, 이 파일에 대해 자동으로 채워진 `<None>` 항목을 다음과 같이 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="5c114-257">Bean Trader 샘플에는 XAML 파일(Default.Accent.xaml)이 `Page`가 아닌 `Content`로 포함되어 있습니다. 이 파일에 정의된 테마와 강조는 앱 자체에 포함되지 않고 런타임 시 파일의 XAML에서 로드되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="5c114-258">새 프로젝트 시스템은 이 파일을 `<Page>`로 자동 포함합니다. 하지만 이것은 XAML 파일이기 때문에,</span><span class="sxs-lookup"><span data-stu-id="5c114-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="5c114-259">페이지로 포함된 XAML 파일을 제거하고(`<Page Remove="**\Default.Accent.xaml" />`) 콘텐츠로 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="5c114-260">마지막으로 모든 `<ItemGroup>`을 `<PackageReference>` 요소와 함께 복사하여 NuGet 참조를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="5c114-261">이전에 NuGet 패키지를 .NET Core 호환 버전으로 업그레이드하지 않았으면, 이제 패키지 참조가 .NET Core 관련 프로젝트에 있으므로 지금 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="5c114-262">이제 BeanTrader 솔루션에 새 프로젝트를 추가하고 Visual Studio에서 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="5c114-263">프로젝트가 **솔루션 탐색기**에서 올바르게 표시되고 `dotnet restore BeanTraderClient.Core.csproj`는 패키지를 성공적으로 복원해야 합니다(.NET Framework를 대상으로 하는 사용 중인 MahApps.Metro 버전과 관련된 두 가지 경고가 예상됨).</span><span class="sxs-lookup"><span data-stu-id="5c114-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="5c114-264">두 프로젝트 파일을 나란히 유지하는 것이 가능하더라도(기존 프로젝트를 그대로 빌드하려는 경우에는 바람직할 수도 있지만), 마이그레이션 프로세스가 복잡해지고(두 프로젝트가 동일한 bin 및 obj 폴더를 사용하려고 함) 대개는 그럴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="5c114-265">.NET Core와 .NET Framework 대상 모두에 대해 빌드하려면 새 프로젝트 파일의 `<TargetFramework>netcoreapp3.0</TargetFramework>` 속성을 대신 `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`로 바꾸면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="5c114-266">Bean Trader 샘플의 경우 이전 프로젝트 파일(BeanTraderClient.csproj)이 더 이상 필요하지 않으므로 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="5c114-267">두 프로젝트 파일을 모두 유지하려면 서로 다른 출력 및 중간 출력 경로로 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="5c114-268">빌드 문제 해결</span><span class="sxs-lookup"><span data-stu-id="5c114-268">Fix build issues</span></span>

<span data-ttu-id="5c114-269">이식 프로세스의 세 번째 단계는 프로젝트를 빌드하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="5c114-270">어떤 앱은 프로젝트 파일이 SDK 스타일 프로젝트로 변환되면 이미 빌드에 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="5c114-271">이런 경우에 해당하는 앱이라면, 축하드립니다!</span><span class="sxs-lookup"><span data-stu-id="5c114-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="5c114-272">4단계로 이동하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-272">You can go on to Step 4.</span></span> <span data-ttu-id="5c114-273">다른 앱은 .NET Core용으로 빌드하기 위해 업데이트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="5c114-274">예를 들어, Bean Trader 샘플 프로젝트에서 `dotnet build`를 실행(또는 Visual Studio에서 빌드)하려고 하면 많은 오류가 발생하겠지만 신속하게 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="5c114-275">System.ServiceModel 참조 및 Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="5c114-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="5c114-276">일반적인 오류의 원인은 .NET Core에서 사용 가능하지만 .NET Core 앱 메타 패키지에는 자동으로 포함되지 않는 API에 대한 참조가 누락된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="5c114-277">이 문제를 해결하려면 `Microsoft.Windows.Compatibility` 패키지를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="5c114-278">호환성 패키지에는 Windows 데스크톱 앱에서 일반적으로 사용되는 광범위한 API 세트(예: WCF 클라이언트, 디렉터리 서비스, 레지스트리, 구성, ACL API 등)가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="5c114-279">Bean Trader 샘플에서 대부분의 빌드 오류는 <xref:System.ServiceModel> 형식이 누락되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="5c114-280">이것은 필요한 WCF NuGet 패키지를 참조하여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="5c114-281">WCF 클라이언트 API는 `Microsoft.Windows.Compatibility` 패키지에 포함되어 있으므로 호환성 패키지를 참조하는 것이 더 나은 솔루션입니다. (호환성 패키지에 제공되는 WCF 문제에 대한 솔루션뿐만 아니라 API 관련 문제도 해결되기 때문입니다.)</span><span class="sxs-lookup"><span data-stu-id="5c114-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="5c114-282">`Microsoft.Windows.Compatibility` 패키지는 대부분의 .NET Core 3.0 WPF 및 WinForms 이식 시나리오에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="5c114-283">`Microsoft.Windows.Compatibility`에 NuGet 참조를 추가하면 빌드 오류가 하나만 남습니다!</span><span class="sxs-lookup"><span data-stu-id="5c114-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="5c114-284">사용되지 않는 파일 정리</span><span class="sxs-lookup"><span data-stu-id="5c114-284">Cleaning up unused files</span></span>

<span data-ttu-id="5c114-285">자주 발생하는 마이그레이션 문제 중 한 가지 형식은, 이전에는 빌드에 포함되지 않은 C# 및 XAML 파일이 모든 소스를 자동으로 포함하는 새로운 SDK 스타일 프로젝트에서 선택되는 것과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="5c114-286">Bean Trader 샘플에 보이는 다음 빌드 오류는 *OldUnusedViewModel.cs*의 잘못된 인터페이스 구현을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="5c114-287">파일 이름에 힌트가 있지만 검사를 하면 소스 파일이 잘못된 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="5c114-288">원래 .NET Framework 프로젝트에는 포함되지 않았기 때문에 이전에는 문제가 발생하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="5c114-289">디스크에 있어도 이전 *csproj*에는 포함되지 않았던 소스 파일이 이제 자동으로 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="5c114-290">이와 같이 한 번만 있는 문제는 이전 *csproj*와 비교하여 파일이 필요하지 않은 것을 확인한 다음, `<Compile Remove="" />` 처리하거나 소스 파일이 더 이상 필요하지 않으면 삭제하는 것이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="5c114-291">이 경우 *OldUnusedViewModel.cs*를 삭제하는 것이 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="5c114-292">이런 방식으로 제외해야 하는 소스 파일이 많으면, 프로젝트 파일에서 `<EnableDefaultCompileItems>` 속성을 false로 설정하여 C# 파일의 자동 포함을 비활성화하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="5c114-293">그런 다음, 포함하려는 소스만 빌드되도록 이전 프로젝트 파일의 `<Compile Include>` 항목을 새 프로젝트 파일로 복사하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="5c114-294">마찬가지로 `<EnableDefaultPageItems>`을 사용하여 XAML 페이지의 자동 포함을 해제할 수 있고 `<EnableDefaultItems>`는 단일 속성으로 둘 다 제어가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="5c114-295">멀티 패스 컴파일러에 대한 간략한 설명</span><span class="sxs-lookup"><span data-stu-id="5c114-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="5c114-296">Bean Trader 샘플에서 문제가 되는 파일을 제거한 후 다시 빌드하면 오류 4개가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="5c114-297">전에는 1개 아니었나요?</span><span class="sxs-lookup"><span data-stu-id="5c114-297">Didn't you have one before?</span></span> <span data-ttu-id="5c114-298">오류 수가 왜 증가했나요?</span><span class="sxs-lookup"><span data-stu-id="5c114-298">Why did the number of errors go up?</span></span> <span data-ttu-id="5c114-299">C# 컴파일러는 [멀티 패스 컴파일러](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="5c114-300">즉, 각 소스 파일을 두 번 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="5c114-301">처음에는, 컴파일러가 각 소스 파일에서 메타데이터와 선언을 살펴보고 선언 수준 문제가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="5c114-302">이러한 문제는 해결한 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="5c114-303">그런 다음, 코드를 다시 살펴보고 C# 소스를 IL로 빌드합니다. 이것이 지금 보이는 두 번째 오류 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="5c114-304">C# 컴파일러는 [두 번 이상의 패스](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)를 수행하지만, 최종 결과는 이와 같은 대량 코드 변경에 대한 컴파일러 오류가 두 번에 걸쳐 제공되는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="5c114-305">타사 종속성 해결(Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="5c114-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="5c114-306">일부 마이그레이션 시나리오에서 발생하는 또 다른 문제는 .NET Framework와 .NET Core 버전 종속성 간의 API 차이점입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="5c114-307">NuGet 패키지가 .NET Framework와 .NET Standard 모두를 또는 .NET Core를 대상으로 하더라도 여러 .NET 대상에 다른 라이브러리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="5c114-308">이렇게 하면 패키지가 여러 .NET 플랫폼을 지원할 수 있으며 따라서 여러 구현이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="5c114-309">또한 여러 .NET 플랫폼을 대상으로 하는 경우, 라이브러리마다 API에 약간의 차이가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="5c114-310">Bean Trader 샘플에서 볼 다음 오류 세트는 `Castle.Windsor` API와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="5c114-311">.NET Core Bean Trader 프로젝트는 .NET Framework 대상 프로젝트(4.1.1)와 동일한 버전의 `Castle.Windsor`를 사용하지만, 두 가지 플랫폼에 대한 구현은 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="5c114-312">이 경우 수정해야 하는 문제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="5c114-313">.NET Core에서는 `Castle.MicroKernel.Registration.Classes.FromThisAssembly`를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="5c114-314">하지만 유사한 API인 `Classes.FromAssemblyContaining`을 사용할 수 있으므로 `Classes.FromThisAssembly()` 사용을 `Classes.FromAssemblyContaining(t)` 호출로 대체할 수 있습니다. 여기에서 `t`는 호출을 수행하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="5c114-315">마찬가지로 *Bootstrapper.cs*에는 `Castle.Windsor.Installer.FromAssembly`가 있는데, .NET Core에서는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="5c114-316">대신 이 호출을 `FromAssembly.Containing(typeof(Bootstrapper))`로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="5c114-317">WCF 클라이언트 사용 업데이트</span><span class="sxs-lookup"><span data-stu-id="5c114-317">Updating WCF client usage</span></span>

<span data-ttu-id="5c114-318">`Castle.Windsor` 차이를 해결했으므로, .NET Core Bean Trader 프로젝트에 마지막으로 남은 빌드 오류는 `BeanTraderServiceClient`(`DuplexClientBase`에서 파생됨)에 `Open` 메서드가 없는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="5c114-319">마이그레이션 프로세스를 시작할 때 .NET 이식성 분석기에 강조 표시된 API이기 때문에 알고 있는 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="5c114-320">하지만, `BeanTraderServiceClient`를 살펴보면 더 큰 문제에 주목하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="5c114-321">[Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) 도구에서 WCF 클라이언트가 자동으로 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="5c114-322">**Svcutil에서 생성된 WCF 클라이언트는 .NET Framework에서만 사용이 가능합니다.**</span><span class="sxs-lookup"><span data-stu-id="5c114-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="5c114-323">svcutil에서 생성된 WCF 클라이언트를 사용하는 솔루션은 .NET Core에 사용할 .NET Standard 호환 클라이언트를 다시 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="5c114-324">이전 클라이언트가 작동하지 않는 주된 이유 중 하나는 앱 구성에 의존하여 WCF 바인딩과 엔드포인트를 정의한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="5c114-325">.NET Standard WCF API는 플랫폼 간 작동이 가능하기 때문에(System.Configuration API를 사용할 수 없는 경우), .NET Core 및 .NET Standard 시나리오의 WCF 클라이언트는 구성이 아닌 프로그래밍 방식으로 바인딩과 엔드포인트를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="5c114-326">실제로, `<system.serviceModel>` app.config 섹션에 종속된 WCF 클라이언트(Svcutil에서 생성되거나 수동으로 생성한) 사용이 .NET Core에서 작동하려면 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="5c114-327">.NET Standard 호환 WCF 클라이언트를 자동으로 생성하는 방법은 두 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="5c114-328">`dotnet-svcutil` 도구는 Svcutil의 이전 작동 방식과 유사하게 WCF 클라이언트를 생성하는 .NET 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="5c114-329">Visual Studio는 자체 연결된 서비스 기능의 [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) 옵션을 사용하여 WCF 클라이언트를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="5c114-330">어느 방식이든 괜찮습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-330">Either approach works well.</span></span> <span data-ttu-id="5c114-331">물론 WCF 클라이언트 코드를 직접 작성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="5c114-332">이 샘플에서는 Visual Studio 연결된 서비스 기능을 사용하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="5c114-333">그러려면, Visual Studio의 솔루션 탐색기에서 *BeanTraderClient.Core* 프로젝트를 마우스 오른쪽 단추로 클릭하고, **추가** > **연결된 서비스**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="5c114-334">다음으로 WCF Web Service Reference Provider를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="5c114-335">그러면 대화 상자가 열리고 백 엔드 Bean Trader 웹 서비스의 주소(로컬에서 서버를 실행하는 경우 `localhost:8080`) 및 생성된 형식을 사용해야 하는 네임스페이스(예: **BeanTrader.Service**)를 지정할 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="5c114-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Service Reference 연결된 서비스 대화 상자](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="5c114-337">**마침** 단추를 선택하면, 새로운 연결된 서비스 노드가 프로젝트에 추가되고 이 노드(Bean Trader 서비스에 액세스하기 위한 새 .NET Standard WCF 클라이언트가 포함됨) 아래에 Reference.cs 파일이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="5c114-338">이 파일에서 `GetEndpointAddress`나 또는 `GetBindingForEndpoint` 메서드를 살펴보면 바인딩과 엔드포인트가 이제 프로그래밍 방식으로(앱 구성을 통하지 않고) 생성된 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="5c114-339">'연결된 서비스 추가' 기능이 프로젝트 파일의 일부 System.ServiceModel 패키지에 대한 참조를 추가할 수도 있지만 필요한 모든 WCF 패키지가 Microsoft.Windows.Compatibility를 통해 포함되기 때문에 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="5c114-340">csproj를 확인하여 System.ServiceModel `<PackageReference>` 항목이 더 추가되었는지 확인하고 그런 경우에는 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="5c114-341">이제 프로젝트에 새 WCF 클라이언트 클래스가 있지만(*Reference.cs*에) 아직 이전 클래스도 있습니다(BeanTrader.cs에).</span><span class="sxs-lookup"><span data-stu-id="5c114-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="5c114-342">이 시점에는 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-342">There are two options at this point:</span></span>

- <span data-ttu-id="5c114-343">원래 .NET Framework 프로젝트(새로운 .NET Core 대상 프로젝트와 함께)를 빌드하려면, .NET Framework와 .NET Core 버전의 앱이 서로 다른 WCF 클라이언트를 사용하도록 .NET Core 프로젝트의 csproj 파일에 `<Compile Remove="BeanTrader.cs" />` 항목을 사용하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="5c114-344">이렇게 하면 기존 .NET Framework 프로젝트를 변경하지 않고 그대로 두는 이점이 있지만, 생성된 WCF 클라이언트를 사용하는 코드가 .NET Core의 경우 .NET Framework 프로젝트의 경우와 약간 다를 수 있다는 단점이 있습니다. 따라서 `#if` 지시문을 사용하여 .NET Core용으로 빌드할 때와 .NET Framework 용으로 빌드할 때가 다르게 작동하도록 일부 WCF 클라이언트 사용(예: 클라이언트 생성)을 조건부로 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="5c114-345">반면에 기존 .NET Framework 프로젝트에서 일부 코드 변경이 허용되는 경우 *BeanTrader.cs*를 모두 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="5c114-346">새 WCF 클라이언트는 .NET Standard용으로 빌드되었기 때문에 .NET Core와 .NET Framework 시나리오 모두에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="5c114-347">.NET Core용 외에도 .NET Framework용 빌드를 수행하는 경우(멀티 타기팅을 통해 또는 csproj 파일을 두 개 사용하여), 두 대상 모두에 새 *Reference.cs* 파일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="5c114-348">이 방식은 두 가지 다른 WCF 클라이언트를 지원하기 위해 코드를 분기할 필요가 없다는 장점이 있습니다. 동일한 코드가 모든 곳에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="5c114-349">단점은 .NET Framework 프로젝트(가정상 안정적인) 변경과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="5c114-350">Bean Trader 샘플의 경우, 마이그레이션이 더 편해진다면 원래 프로젝트를 약간 변경할 수 있습니다. 따라서 다음 단계에 따라 WCF 클라이언트 사용을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="5c114-351">솔루션 탐색기에서 '기존 항목 추가'라는 상황에 맞는 메뉴를 사용하여 새 Reference.cs 파일을 .NET Framework *BeanTraderClient.csproj* 프로젝트에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="5c114-352">두 프로젝트에 동일한 파일이 사용되도록 '링크로' 추가해야 합니다(C# 파일을 복사하는 것이 아님).</span><span class="sxs-lookup"><span data-stu-id="5c114-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="5c114-353">단일 csproj(멀티 타기팅을 사용하여)로 .NET Core와 .NET Framework용 빌드를 모두 수행하는 경우에는 이 단계가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="5c114-354">*BeanTrader.cs*를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="5c114-355">새 WCF 클라이언트는 이전 WCF 클라이언트와 비슷하지만 생성된 코드에서 다수의 네임스페이스가 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="5c114-356">따라서, WCF 클라이언트 형식이 BeanTrader.Model 대신 또는 네임스페이스 없이 BeanTrader.Service(또는 선택한 네임스페이스 이름)에서 사용되도록 프로젝트를 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="5c114-357">*BeanTraderClient.Core.csproj*를 빌드하면 이러한 변경이 필요한 위치를 식별하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="5c114-358">C#과 XAML 소스 파일 모두에서 수정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="5c114-359">마지막으로 `BeanTraderServiceClient` 형식에 사용할 수 있는 생성자가 변경되었으니 *BeanTraderServiceClientFactory.cs*에 오류가 있는 것을 알게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="5c114-360">이전에는 `InstanceContext` 인수(`Castle.Windsor` IoC 컨테이너의 `CallbackHandler`를 사용하여 생성됨)를 제공할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="5c114-361">새 생성자는 새로운 `CallbackHandler`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="5c114-362">하지만 `BeanTraderServiceClient`의 기본 형식에는 필요한 것과 일치하는 생성자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="5c114-363">자동 생성된 WCF 클라이언트 코드는 모두 partial 클래스에 있으므로 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="5c114-364">이렇게 하려면 *BeanTraderServiceClient.cs*라는 새 파일을 만든 다음, 동일한 이름(BeanTrader.Service 네임스페이스 사용)으로 partial 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="5c114-365">그런 다음, 부분 형식(Partial Type)에 생성자를 하나 추가합니다(아래 참조).</span><span class="sxs-lookup"><span data-stu-id="5c114-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="5c114-366">변경이 완료되면 이제 Bean Trader 샘플에 새로운 .NET Standard 호환 WCF 클라이언트가 사용되며, *TradingService.cs*에서 `Open` 호출에 `await OpenAsync`가 대신 사용되도록 변경하는 마지막 수정 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="5c114-367">WCF 문제가 해결되면 .NET Core 버전의 Bean Trader 샘플이 이제 깔끔하게 빌드됩니다!</span><span class="sxs-lookup"><span data-stu-id="5c114-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="5c114-368">런타임 테스트</span><span class="sxs-lookup"><span data-stu-id="5c114-368">Runtime testing</span></span>

<span data-ttu-id="5c114-369">프로젝트가 .NET Core에 대해 깔끔하게 빌드되는 즉시 마이그레이션 작업이 완료되는 것이 아니라는 사실을 잊기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="5c114-370">이식된 앱을 테스트할 시간을 남겨 두는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="5c114-371">빌드가 완료되고 나면, 앱이 실행되고 예상대로 작동하는지 확인해야 합니다. 특히 .NET Framework를 대상으로 하는 패키지를 사용하는 경우에는 반드시 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="5c114-372">이식된 Bean Trader 앱을 시작하여 어떻게 작동하는지 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="5c114-373">앱에 곧 장애가 발생하고 다음 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="5c114-374">물론, 이는 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-374">This makes sense, of course.</span></span> <span data-ttu-id="5c114-375">WCF에는 앱 구성이 더 이상 사용되지 않습니다. 따라서 app.config 파일의 이전 system.serviceModel 섹션을 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="5c114-376">업데이트된 WCF 클라이언트는 동일한 모든 정보가 코드에 포함되기 때문에 구성 섹션이 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="5c114-377">app.config에서 WCF 엔드포인트를 구성할 수 있게 하려면 해당 항목을 앱 설정으로 추가하고, 구성에서 WCF 서비스 엔드포인트를 검색하도록 WCF 클라이언트 코드를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="5c114-378">*app.config*의 system.serviceModel 섹션을 제거하면 앱이 실행되지만 사용자가 로그인하면 다른 예외로 인해 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="5c114-379">지원되지 않는 API는 `Func<T>.BeginInvoke`입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="5c114-380">[dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940)의 설명대로 .NET Core는 기본 원격 종속성으로 인해 대리자 형식에서 `BeginInvoke` 및 `EndInvoke` 메서드를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="5c114-381">이 문제와 해결 방법은 [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)(.NET Core에 대한 Delegate.BeginInvoke 호출 마이그레이션) 블로그 게시물에 자세히 설명되어 있지만, 요지는 `BeginInvoke`와 `EndInvoke` 호출을 `Task.Run`(또는 가능한 경우 비동기 대안)으로 바꿔야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="5c114-382">여기에서 일반적인 솔루션을 적용하면 `BeginInvoke` 호출을 `Task.Run`에서 시작한 `Invoke` 호출로 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="5c114-383">`BeginInvoke` 사용을 제거하면 Bean Trader 앱이 .NET Core에서 성공적으로 실행됩니다!</span><span class="sxs-lookup"><span data-stu-id="5c114-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![.NET Core에서 실행되는 Bean Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="5c114-385">모든 앱은 서로 다릅니다. 따라서 각자의 앱을 .NET Core로 마이그레이션하는 데 필요한 구체적인 단계는 다양합니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="5c114-386">하지만, Bean Trader 샘플을 통해 일반적인 워크플로와 예상할 수 있는 문제 유형을 참고하실 수 있기를 바랍니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="5c114-387">문서의 길이는 장황하지만, Bean Trader 샘플이 .NET Core에서 작동하도록 만들기 위해 실제로 변경해야 하는 내용은 상당히 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="5c114-388">많은 앱이 .NET Core에 동일한 방식으로 마이그레이션되며, 코드 변경은 제한적이거나 전혀 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5c114-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
