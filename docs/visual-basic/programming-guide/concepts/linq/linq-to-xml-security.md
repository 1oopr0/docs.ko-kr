---
title: LINQ to XML 보안
ms.date: 07/20/2015
ms.assetid: d99b4af2-d447-4a3b-991b-6da0231a8637
ms.openlocfilehash: 2be3e2df81af046035832794766f3317e1e96e35
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/04/2020
ms.locfileid: "84368532"
---
# <a name="linq-to-xml-security-visual-basic"></a><span data-ttu-id="b7803-102">LINQ to XML 보안 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b7803-102">LINQ to XML Security (Visual Basic)</span></span>
<span data-ttu-id="b7803-103">이 항목에서는 LINQ to XML과 관련된 보안 문제에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-103">This topic describes security issues associated with LINQ to XML.</span></span> <span data-ttu-id="b7803-104">또한 보안 노출을 경감하는 몇 가지 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-104">In addition, it provides some guidance for mitigating security exposure.</span></span>  
  
## <a name="linq-to-xml-security-overview"></a><span data-ttu-id="b7803-105">LINQ to XML 보안 개요</span><span class="sxs-lookup"><span data-stu-id="b7803-105">LINQ to XML Security Overview</span></span>  
 <span data-ttu-id="b7803-106">LINQ to XML은 보안 요구 사항이 엄격한 서버측 애플리케이션보다 간편하게 프로그래밍하는 데 중점을 두어 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-106">LINQ to XML is designed more for programming convenience than for server-side applications with stringent security requirements.</span></span> <span data-ttu-id="b7803-107">대부분의 XML 시나리오는 서버에 업로드된 신뢰할 수 없는 XML 문서의 처리가 아니라 신뢰할 수 있는 XML 문서의 처리로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-107">Most XML scenarios consist of processing trusted XML documents, rather than processing untrusted XML documents that are uploaded to a server.</span></span> <span data-ttu-id="b7803-108">LINQ to XML은 이러한 시나리오에 맞게 최적화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-108">LINQ to XML is optimized for these scenarios.</span></span>  
  
 <span data-ttu-id="b7803-109">알 수 없는 소스에서 신뢰할 수 없는 데이터를 처리해야 하는 경우 알려진 XML DoS(서비스 거부) 공격을 필터링하도록 구성된 <xref:System.Xml.XmlReader> 클래스의 인스턴스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-109">If you must process untrusted data from unknown sources, Microsoft recommends that you use an instance of the <xref:System.Xml.XmlReader> class that has been configured to filter out known XML denial of service (DoS) attacks.</span></span>  
  
 <span data-ttu-id="b7803-110">서비스 거부 공격을 완화하도록 <xref:System.Xml.XmlReader>를 구성한 경우 해당 판독기를 사용하여 LINQ to XML 트리를 채우고 LINQ to XML의 프로그래머 생산성 향상 기능에서 혜택을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-110">If you have configured an <xref:System.Xml.XmlReader> to mitigate denial of service attacks, you can use that reader to populate a LINQ to XML tree and still benefit from the programmer productivity enhancements of LINQ to XML.</span></span> <span data-ttu-id="b7803-111">많은 완화 기법에는 보안 문제를 완화하도록 구성된 판독기를 만들고 구성된 판독기를 통해 XML 트리를 인스턴스화하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-111">Many mitigation techniques involve creating readers that are configured to mitigate the security issue, and then instantiating an XML tree through the configured reader.</span></span>  
  
 <span data-ttu-id="b7803-112">XML은 문서의 크기, 깊이, 요소 이름 크기 등이 제한되어 있지 않기 때문에 서비스 거부 공격에 기본적으로 취약합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-112">XML is intrinsically vulnerable to denial of service attacks because documents are unbounded in size, depth, element name size, and more.</span></span> <span data-ttu-id="b7803-113">XML 처리에 사용하는 구성 요소에 관계없이 과도한 리소스를 사용하는 경우 애플리케이션 도메인을 재활용할 준비가 항상 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-113">Regardless of the component that you use to process XML, you should always be prepared to recycle the application domain if it uses excessive resources.</span></span>  
  
## <a name="mitigation-of-xml-xsd-xpath-and-xslt-attacks"></a><span data-ttu-id="b7803-114">XML, XSD, XPath 및 XSLT 공격의 완화</span><span class="sxs-lookup"><span data-stu-id="b7803-114">Mitigation of XML, XSD, XPath, and XSLT Attacks</span></span>  
 <span data-ttu-id="b7803-115">LINQ to XML은 <xref:System.Xml.XmlReader> 및 <xref:System.Xml.XmlWriter>를 기반으로 빌드되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-115">LINQ to XML is built upon <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter>.</span></span> <span data-ttu-id="b7803-116">LINQ to XML에서는 <xref:System.Xml.Schema?displayProperty=nameWithType> 및 <xref:System.Xml.XPath?displayProperty=nameWithType> 네임스페이스의 확장 메서드를 통해 XSD와 XPath를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-116">LINQ to XML supports XSD and XPath through extension methods in the <xref:System.Xml.Schema?displayProperty=nameWithType> and <xref:System.Xml.XPath?displayProperty=nameWithType> namespaces.</span></span> <span data-ttu-id="b7803-117">LINQ to XML과 함께 <xref:System.Xml.XmlReader>, <xref:System.Xml.XPath.XPathNavigator> 및 <xref:System.Xml.XmlWriter> 클래스를 사용하는 경우 XSLT를 호출하여 XML 트리를 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-117">Using the <xref:System.Xml.XmlReader>, <xref:System.Xml.XPath.XPathNavigator>, and <xref:System.Xml.XmlWriter> classes in conjunction with LINQ to XML, you can invoke XSLT to transform XML trees.</span></span>  
  
 <span data-ttu-id="b7803-118">보안 수준이 낮은 운영 환경에서는 XML 및 <xref:System.Xml?displayProperty=nameWithType>, <xref:System.Xml.Schema?displayProperty=nameWithType>, <xref:System.Xml.XPath?displayProperty=nameWithType> 및 <xref:System.Xml.Xsl?displayProperty=nameWithType>의 클래스 사용과 관련된 많은 보안 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-118">If you are operating in a less secure environment, there are a number of security issues that are associated with XML and the use of the classes in <xref:System.Xml?displayProperty=nameWithType>, <xref:System.Xml.Schema?displayProperty=nameWithType>, <xref:System.Xml.XPath?displayProperty=nameWithType>, and <xref:System.Xml.Xsl?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b7803-119">이러한 문제는 다음과 같지만 다음 문제로만 제한되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-119">These issues include, but are not limited to, the following:</span></span>  
  
- <span data-ttu-id="b7803-120">XSD, XPath 및 XSLT는 많은 시간이나 메모리를 사용하는 작업을 지정할 수 있는 문자열 기반 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-120">XSD, XPath, and XSLT are string-based languages in which you can specify operations that consume a lot of time or memory.</span></span> <span data-ttu-id="b7803-121">문자열이 악성이 아닌지 확인하거나 이러한 문자열을 확인할 때 시스템 리소스를 과도하게 사용하게 될 가능성을 모니터링하고 완화하는 것은 신뢰할 수 없는 소스에서 XSD, XPath 또는 XSLT 문자열을 가져오는 애플리케이션 프로그래머의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-121">It is the responsibility of application programmers who take XSD, XPath, or XSLT strings from untrusted sources to validate that the strings are not malicious, or to monitor and mitigate the possibility that evaluating these strings will lead to excessive system resource consumption.</span></span>  
  
- <span data-ttu-id="b7803-122">인라인 스키마를 비롯한 XSD 스키마는 기본적으로 서비스 거부 공격에 취약하므로 신뢰할 수 없는 소스에서 스키마를 받아들이지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-122">XSD schemas (including inline schemas) are inherently vulnerable to denial of service attacks; you should not accept schemas from untrusted sources.</span></span>  
  
- <span data-ttu-id="b7803-123">XSD와 XSLT에는 다른 파일에 대한 참조가 포함될 수 있으며 이러한 참조로 인해 영역 간 공격과 도메인 간 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-123">XSD and XSLT can include references to other files, and such references can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="b7803-124">DTD의 외부 엔터티로 인해 영역 간 공격과 도메인 간 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-124">External entities in DTDs can result in cross-zone and cross-domain attacks.</span></span>  
  
- <span data-ttu-id="b7803-125">DTD는 서비스 거부 공격에 취약합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-125">DTDs are vulnerable to denial of service attacks.</span></span>  
  
- <span data-ttu-id="b7803-126">매우 깊은 XML 문서는 서비스 거부 문제를 일으킬 수 있으므로 XML 문서의 깊이를 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-126">Exceptionally deep XML documents can pose denial of service issues; you might want to limit the depth of XML documents.</span></span>  
  
- <span data-ttu-id="b7803-127">신뢰할 수 없는 어셈블리에서 <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> 및 <xref:System.Xml.XmlResolver> 개체와 같은 지원 구성 요소를 받아들이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-127">Do not accept supporting components, such as <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, and <xref:System.Xml.XmlResolver> objects, from untrusted assemblies.</span></span>  
  
- <span data-ttu-id="b7803-128">큰 문서 공격을 완화하기 위해 데이터를 청크로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-128">Read data in chunks to mitigate large document attacks.</span></span>  
  
- <span data-ttu-id="b7803-129">XSLT 스타일시트의 스크립트 블록은 많은 공격에 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-129">Script blocks in XSLT style sheets can expose a number of attacks.</span></span>  
  
- <span data-ttu-id="b7803-130">동적 XPath 식을 생성하기 전에 신중하게 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-130">Validate carefully before constructing dynamic XPath expressions.</span></span>  
  
## <a name="linq-to-xml-security-issues"></a><span data-ttu-id="b7803-131">LINQ to XML 보안 문제</span><span class="sxs-lookup"><span data-stu-id="b7803-131">LINQ to XML Security Issues</span></span>  
 <span data-ttu-id="b7803-132">이 항목의 보안 문제는 특정 순서로 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-132">The security issues in this topic are not presented in any particular order.</span></span> <span data-ttu-id="b7803-133">모든 문제는 중요하며 적절하게 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-133">All issues are important and should be addressed as appropriate.</span></span>  
  
 <span data-ttu-id="b7803-134">권한 상승 공격이 성공하면 악의적인 어셈블리가 환경을 더 많이 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-134">A successful elevation of privilege attack gives a malicious assembly more control over its environment.</span></span> <span data-ttu-id="b7803-135">또한 데이터 공개, 서비스 거부 등이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-135">A successful elevation of privilege attack can result in disclosure of data, denial of service, and more.</span></span>  
  
 <span data-ttu-id="b7803-136">애플리케이션에서는 데이터를 볼 권한이 없는 사용자에게 데이터를 공개해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-136">Applications should not disclose data to users who are not authorized to see that data.</span></span>  
  
 <span data-ttu-id="b7803-137">서비스 거부 공격이 발생하면 XML 파서나 LINQ to XML에서 메모리나 CPU 시간을 지나치게 많이 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-137">Denial of service attacks cause the XML parser or LINQ to XML to consume excessive amounts of memory or CPU time.</span></span> <span data-ttu-id="b7803-138">서비스 거부 공격은 권한 상승 공격이나 데이터 공개 공격보다 심각하지 않은 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-138">Denial of service attacks are considered to be less severe than elevation of privilege attacks or disclosure of data attacks.</span></span> <span data-ttu-id="b7803-139">그러나 서버에서 신뢰할 수 없는 소스의 XML 문서를 처리해야 하는 경우에는 서비스 거부 공격이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-139">However, they are important in a scenario where a server needs to process XML documents from untrusted sources.</span></span>  
  
### <a name="exceptions-and-error-messages-might-reveal-data"></a><span data-ttu-id="b7803-140">예외 및 오류 메시지에서 데이터를 드러낼 수 있음</span><span class="sxs-lookup"><span data-stu-id="b7803-140">Exceptions and Error Messages Might Reveal Data</span></span>  
 <span data-ttu-id="b7803-141">오류에 대한 설명에서 변환 중인 데이터, 파일 이름 또는 구현 정보와 같은 데이터를 드러낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-141">The description of an error might reveal data, such as the data being transformed, file names, or implementation details.</span></span> <span data-ttu-id="b7803-142">오류 메시지는 신뢰할 수 없는 호출자에게 노출되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-142">Error messages should not be exposed to callers that are not trusted.</span></span> <span data-ttu-id="b7803-143">사용자 지정 오류 메시지를 사용하여 모든 오류와 보고서 오류를 catch해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-143">You should catch all errors and report errors with your own custom error messages.</span></span>  
  
### <a name="do-not-call-codeaccesspermissionsassert-in-an-event-handler"></a><span data-ttu-id="b7803-144">이벤트 처리기에서 CodeAccessPermissions.Assert를 호출하지 않아야 함</span><span class="sxs-lookup"><span data-stu-id="b7803-144">Do Not Call CodeAccessPermissions.Assert in an Event Handler</span></span>  
 <span data-ttu-id="b7803-145">어셈블리는 적은 권한이나 많은 권한을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-145">An assembly can have lesser or greater permissions.</span></span> <span data-ttu-id="b7803-146">많은 권한을 가진 어셈블리는 컴퓨터와 환경을 더 많이 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-146">An assembly that has greater permissions has greater control over the computer and its environments.</span></span>  
  
 <span data-ttu-id="b7803-147">많은 권한을 가진 어셈블리의 코드가 이벤트 처리기에서 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>를 호출한 후 제한된 권한을 가진 악의적인 어셈블리에 XML 트리가 전달되면 악의적인 어셈블리로 인해 이벤트가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-147">If code in an assembly with greater permissions calls <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler, and then the XML tree is passed to a malicious assembly that has restricted permissions, the malicious assembly can cause an event to be raised.</span></span> <span data-ttu-id="b7803-148">이벤트에서 많은 권한을 가진 어셈블리에 있는 코드를 실행하기 때문에 악의적인 어셈블리가 상승된 권한으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-148">Because the event runs code that is in the assembly with greater permissions, the malicious assembly would then be operating with elevated privileges.</span></span>  
  
 <span data-ttu-id="b7803-149">이벤트 처리기에서 <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType>를 절대로 호출하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-149">Microsoft recommends that you never call <xref:System.Security.CodeAccessPermission.Assert%2A?displayProperty=nameWithType> in an event handler.</span></span>  
  
### <a name="dtds-are-not-secure"></a><span data-ttu-id="b7803-150">DTD에 보안이 설정되지 않음</span><span class="sxs-lookup"><span data-stu-id="b7803-150">DTDs are Not Secure</span></span>  
 <span data-ttu-id="b7803-151">DTD의 엔터티에는 기본적으로 보안이 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-151">Entities in DTDs are inherently not secure.</span></span> <span data-ttu-id="b7803-152">DTD가 포함된 악의적인 XML 문서로 인해 파서에서 모든 메모리와 CPU 시간을 사용하여 서비스 거부 공격을 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-152">It is possible for a malicious XML document that contains a DTD to cause the parser to use all memory and CPU time, causing a denial of service attack.</span></span> <span data-ttu-id="b7803-153">따라서 LINQ to XML에서 DTD 처리는 기본적으로 해제되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-153">Therefore, in LINQ to XML, DTD processing is turned off by default.</span></span> <span data-ttu-id="b7803-154">신뢰할 수 없는 소스에서는 DTD를 받아들이지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-154">You should not accept DTDs from untrusted sources.</span></span>  
  
 <span data-ttu-id="b7803-155">신뢰할 수 없는 소스에서 DTD를 받아들이는 한 가지 예는 웹 사용자가 DTD와 DTD 파일을 참조하는 XML 파일을 업로드할 수 있도록 하는 웹 애플리케이션입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-155">One example of accepting DTDs from untrusted sources is a Web application that allows Web users to upload an XML file that references a DTD and a DTD file.</span></span> <span data-ttu-id="b7803-156">파일의 유효성을 검사할 때 악의적인 DTD는 서버에서 서비스 거부 공격을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-156">Upon validation of the file, a malicious DTD could execute a denial of service attack on your server.</span></span> <span data-ttu-id="b7803-157">신뢰할 수 없는 소스에서 DTD를 받아들이는 또 다른 예는 익명 FTP 액세스도 허용하는 네트워크 공유에서 DTD를 참조하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-157">Another example of accepting DTDs from untrusted sources is to reference a DTD on a network share that also allows anonymous FTP access.</span></span>  
  
### <a name="avoid-excessive-buffer-allocation"></a><span data-ttu-id="b7803-158">과도한 버퍼 할당 방지</span><span class="sxs-lookup"><span data-stu-id="b7803-158">Avoid Excessive Buffer Allocation</span></span>  
 <span data-ttu-id="b7803-159">애플리케이션 개발자는 데이터 소스가 매우 크면 리소스가 고갈되고 서비스 거부 공격이 발생할 수 있음을 명심해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-159">Application developers should be aware that extremely large data sources can lead to resource exhaustion and denial of service attacks.</span></span>  
  
 <span data-ttu-id="b7803-160">악의적인 사용자가 매우 큰 XML 문서를 제출하거나 업로드하면 LINQ to XML에서 시스템 리소스를 지나치게 많이 사용할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="b7803-160">If a malicious user submits or uploads a very large XML document, it could cause LINQ to XML to consume excessive system resources.</span></span> <span data-ttu-id="b7803-161">이로 인해 서비스 거부 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-161">This can constitute a denial of service attack.</span></span> <span data-ttu-id="b7803-162">이를 방지하기 위해 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> 속성을 설정하고 로드할 수 있는 문서 크기로 제한된 판독기를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-162">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the size of document that it can load.</span></span> <span data-ttu-id="b7803-163">그런 다음 판독기를 사용하여 XML 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-163">You then use the reader to create the XML tree.</span></span>  
  
 <span data-ttu-id="b7803-164">예를 들어, 신뢰할 수 없는 소스에서 제공되는 XML 문서의 최대 예상 크기가 50K바이트보다 작을 것으로 예상되면 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType>를 100,000으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-164">For example, if you know that the maximum expected size of your XML documents coming from an untrusted source will be less than 50K bytes, set <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A?displayProperty=nameWithType> to 100,000.</span></span> <span data-ttu-id="b7803-165">이렇게 하는 경우 XML 문서의 처리가 방해를 받지 않으며 이와 동시에 많은 메모리를 사용할 문서가 업로드될 수 있는 서비스 거부 위협이 완화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-165">This will not encumber your processing of XML documents, and at the same time it will mitigate denial of service threats where documents might be uploaded that would consume large amounts of memory.</span></span>  
  
### <a name="avoid-excess-entity-expansion"></a><span data-ttu-id="b7803-166">지나친 엔터티 확장 방지</span><span class="sxs-lookup"><span data-stu-id="b7803-166">Avoid Excess Entity Expansion</span></span>  
 <span data-ttu-id="b7803-167">DTD를 사용하는 경우 알려진 서비스 거부 공격 중 하나는 지나친 엔터티 확장을 발생시키는 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-167">One of the known denial of service attacks when using a DTD is a document that causes excessive entity expansion.</span></span> <span data-ttu-id="b7803-168">이를 방지하기 위해 <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> 속성을 설정하고 엔터티 확장으로 발생하는 문자 수로 제한된 판독기를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-168">To prevent this, you can set the <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A?displayProperty=nameWithType> property, and create a reader that is then limited in the number of characters that result from entity expansion.</span></span> <span data-ttu-id="b7803-169">그런 다음 판독기를 사용하여 XML 트리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-169">You then use the reader to create the XML tree.</span></span>  
  
### <a name="limit-the-depth-of-the-xml-hierarchy"></a><span data-ttu-id="b7803-170">XML 계층 구조의 깊이 제한</span><span class="sxs-lookup"><span data-stu-id="b7803-170">Limit the Depth of the XML Hierarchy</span></span>  
 <span data-ttu-id="b7803-171">한 가지 가능한 서비스 거부 공격은 계층 구조의 깊이가 매우 큰 문서가 제출되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-171">One possible denial of service attack is when a document is submitted that has excessive depth of hierarchy.</span></span> <span data-ttu-id="b7803-172">이를 방지하기 위해 <xref:System.Xml.XmlReader>를 요소의 깊이를 세는 자체 클래스에 래핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-172">To prevent this, you can wrap a <xref:System.Xml.XmlReader> in your own class that counts the depth of elements.</span></span> <span data-ttu-id="b7803-173">깊이가 미리 결정된 적절한 수준을 초과하면 악의적인 문서의 처리를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-173">If the depth exceeds a predetermined reasonable level, you can terminate the processing of the malicious document.</span></span>  
  
### <a name="protect-against-untrusted-xmlreader-or-xmlwriter-implementations"></a><span data-ttu-id="b7803-174">신뢰할 수 없는 XmlReader 또는 XmlWriter 구현으로부터 보호</span><span class="sxs-lookup"><span data-stu-id="b7803-174">Protect Against Untrusted XmlReader or XmlWriter Implementations</span></span>  
 <span data-ttu-id="b7803-175">관리자는 외부에서 제공된 <xref:System.Xml.XmlReader> 또는 <xref:System.Xml.XmlWriter> 구현이 강력한 이름을 갖고 있고 컴퓨터 구성에 등록되어 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-175">Administrators should verify that any externally supplied <xref:System.Xml.XmlReader> or <xref:System.Xml.XmlWriter> implementations have strong names and have been registered in the machine configuration.</span></span> <span data-ttu-id="b7803-176">이렇게 하면 판독기 또는 작성기로 가장한 악의적인 코드가 로드되는 것이 방지됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-176">This prevents malicious code masquerading as a reader or writer from being loaded.</span></span>  
  
### <a name="periodically-free-objects-that-reference-xname"></a><span data-ttu-id="b7803-177">XName을 참조하는 개체의 주기적 해제</span><span class="sxs-lookup"><span data-stu-id="b7803-177">Periodically Free Objects that Reference XName</span></span>  
 <span data-ttu-id="b7803-178">특정 유형의 공격으로부터 보호하기 위해 애플리케이션 프로그래머는 애플리케이션 도메인에서 <xref:System.Xml.Linq.XName> 개체를 참조하는 모든 개체를 주기적으로 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-178">To protect against certain kinds of attacks, application programmers should free all objects that reference an <xref:System.Xml.Linq.XName> object in the application domain on a regular basis.</span></span>  
  
### <a name="protect-against-random-xml-names"></a><span data-ttu-id="b7803-179">임의의 XML 이름으로부터 보호</span><span class="sxs-lookup"><span data-stu-id="b7803-179">Protect Against Random XML Names</span></span>  
 <span data-ttu-id="b7803-180">신뢰할 수 없는 소스에서 데이터를 가져오는 애플리케이션은 임의의 XML 이름 및 네임스페이스의 가능성을 검사하기 위해 사용자 지정 코드에 래핑된 <xref:System.Xml.XmlReader>를 사용하는 것을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-180">Applications that take data from untrusted sources should consider using an <xref:System.Xml.XmlReader> that is wrapped in custom code to inspect for the possibility of random XML names and namespaces.</span></span> <span data-ttu-id="b7803-181">이러한 임의의 XML 이름 및 네임스페이스가 검색되면 애플리케이션에서 악의적인 문서의 처리를 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-181">If such random XML names and namespaces are detected, the application can then terminate the processing of the malicious document.</span></span>  
  
 <span data-ttu-id="b7803-182">네임스페이스에 없는 이름을 비롯하여 지정된 네임스페이스에서 이름의 수를 적합한 한도까지 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-182">You might want to limit the number of names in any given namespace (including names in no namespace) to a reasonable limit.</span></span>  
  
### <a name="annotations-are-accessible-by-software-components-that-share-a-linq-to-xml-tree"></a><span data-ttu-id="b7803-183">LINQ to XML 트리를 공유하는 소프트웨어 구성 요소에서 주석에 액세스할 수 있음</span><span class="sxs-lookup"><span data-stu-id="b7803-183">Annotations Are Accessible by Software Components that Share a LINQ to XML Tree</span></span>  
 <span data-ttu-id="b7803-184">LINQ to XML을 사용하여 여러 애플리케이션 구성 요소가 구성 요소 간에 전달되는 XML 데이터의 로드, 유효성 검사, 쿼리, 변환, 업데이트 및 XML 트리로의 저장을 수행하는 처리 파이프라인을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-184">LINQ to XML could be used to build processing pipelines in which different application components load, validate, query, transform, update, and save XML data that is passed between components as XML trees.</span></span> <span data-ttu-id="b7803-185">이렇게 하면 개체를 로드하고 XML 텍스트로 serialize하는 오버헤드가 파이프라인 끝에서만 발생하므로 성능을 최적화하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-185">This can help optimize performance, because the overhead of loading and serializing objects to XML text is done only at the ends of the pipeline.</span></span> <span data-ttu-id="b7803-186">그러나 개발자는 한 구성 요소에서 만든 모든 주석과 이벤트 처리기를 다른 구성 요소에서 액세스할 수 있음을 명심해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-186">Developers must be aware, however, that all annotations and event handlers created by one component are accessible to other components.</span></span> <span data-ttu-id="b7803-187">이 때문에 구성 요소의 신뢰 수준이 서로 다른 경우 많은 취약점이 생길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-187">This can create a number of vulnerabilities if the components have different levels of trust.</span></span> <span data-ttu-id="b7803-188">신뢰 수준이 낮은 구성 요소 간에 보안 파이프라인을 만들려면 신뢰할 수 없는 구성 요소에 데이터를 전달하기 전에 LINQ to XML 개체를 XML 텍스트로 serialize해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-188">To build secure pipelines across less trusted components, you must serialize LINQ to XML objects to XML text before passing the data to an untrusted component.</span></span>  
  
 <span data-ttu-id="b7803-189">일부 보안은 CLR(공용 언어 런타임)을 통해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-189">Some security is provided by the common language runtime (CLR).</span></span> <span data-ttu-id="b7803-190">예를 들어, private 클래스가 포함되지 않은 구성 요소는 해당 클래스에서 입력한 주석에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-190">For example, a component that does not include a private class cannot access annotations keyed by that class.</span></span> <span data-ttu-id="b7803-191">그러나 주석을 읽을 수 없는 구성 요소에서 주석을 삭제할 수 있으며,</span><span class="sxs-lookup"><span data-stu-id="b7803-191">However, annotations can be deleted by components that cannot read them.</span></span> <span data-ttu-id="b7803-192">이것이 변조 공격으로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b7803-192">This could be used as a tampering attack.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b7803-193">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b7803-193">See also</span></span>

- [<span data-ttu-id="b7803-194">프로그래밍 가이드 (LINQ to XML) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b7803-194">Programming Guide (LINQ to XML) (Visual Basic)</span></span>](programming-guide-linq-to-xml.md)
