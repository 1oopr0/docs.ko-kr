---
title: BinaryFormatter 보안 가이드
description: 이 문서에서는 BinaryFormatter 형식에 내재된 보안 위험 및 사용할 여러 직렬 변환기에 대한 권장 사항을 설명합니다.
ms.date: 07/11/2020
ms.author: levib
author: GrabYourPitchforks
ms.openlocfilehash: f6a54b34bbf1e19212fe37aadb448a1722fe9ff0
ms.sourcegitcommit: 2543a78be6e246aa010a01decf58889de53d1636
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/17/2020
ms.locfileid: "86444753"
---
# <a name="binaryformatter-security-guide"></a><span data-ttu-id="0b611-103">BinaryFormatter 보안 가이드</span><span class="sxs-lookup"><span data-stu-id="0b611-103">BinaryFormatter security guide</span></span>

<span data-ttu-id="0b611-104">이 문서는 다음과 같은 .NET 구현에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-104">This article applies to the following .NET implementations:</span></span>

* <span data-ttu-id="0b611-105">.NET Framework 모든 버전</span><span class="sxs-lookup"><span data-stu-id="0b611-105">.NET Framework all versions</span></span>
* <span data-ttu-id="0b611-106">.NET Core 2.1 - 3.1</span><span class="sxs-lookup"><span data-stu-id="0b611-106">.NET Core 2.1 - 3.1</span></span>
* <span data-ttu-id="0b611-107">.NET 5.0 이상</span><span class="sxs-lookup"><span data-stu-id="0b611-107">.NET 5.0 and later</span></span>

## <a name="background"></a><span data-ttu-id="0b611-108">배경</span><span class="sxs-lookup"><span data-stu-id="0b611-108">Background</span></span>

> [!WARNING]
> <span data-ttu-id="0b611-109"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 형식은 위험하므로 데이터 처리에 사용하지 않는 것이 ***좋습니다***.</span><span class="sxs-lookup"><span data-stu-id="0b611-109">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> type is dangerous and is ***not*** recommended for data processing.</span></span> <span data-ttu-id="0b611-110">애플리케이션은 처리 중인 데이터를 신뢰할 수 있다고 생각하는 경우에도 최대한 빨리 `BinaryFormatter` 사용을 중지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-110">Applications should stop using `BinaryFormatter` as soon as possible, even if they believe the data they're processing to be trustworthy.</span></span> <span data-ttu-id="0b611-111">`BinaryFormatter`는 안전하지 않으며 안전하게 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-111">`BinaryFormatter` is insecure can't be made secure.</span></span>

<span data-ttu-id="0b611-112">이 문서는 다음 형식에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-112">This article also applies to the following types:</span></span>

* <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>
* <xref:System.Runtime.Serialization.NetDataContractSerializer>
* <xref:System.Web.UI.LosFormatter>
* <xref:System.Web.UI.ObjectStateFormatter>

<span data-ttu-id="0b611-113">deserialization 취약성은 요청 페이로드가 안전하지 않게 처리되는 위협 범주입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-113">Deserialization vulnerabilities are a threat category where request payloads are processed insecurely.</span></span> <span data-ttu-id="0b611-114">앱에 대한 deserialization 취약성을 제대로 활용하는 공격자는 대상 앱 내에서 DoS(서비스 거부 공격), 정보 공개 또는 원격 코드 실행을 유발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-114">An attacker who successfully leverages these vulnerabilities against an app can cause denial of service (DoS), information disclosure, or remote code execution inside the target app.</span></span> <span data-ttu-id="0b611-115">이 위험 범주는 일관되게 [OWASP 상위 10](https://owasp.org/www-project-top-ten/)에 올랐습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-115">This risk category consistently makes the [OWASP Top 10](https://owasp.org/www-project-top-ten/).</span></span> <span data-ttu-id="0b611-116">대상으로는 C/C++, Java, C#을 비롯한 [다양한 언어](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)로 작성된 앱이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-116">Targets include apps written in [a variety of languages](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data), including C/C++, Java, and C#.</span></span>

<span data-ttu-id="0b611-117">.NET에서 가장 위험한 대상은 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 형식을 사용하여 데이터를 역직렬화하는 앱입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-117">In .NET, the biggest risk target is apps that use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> type to deserialize data.</span></span> <span data-ttu-id="0b611-118">`BinaryFormatter`는 강력한 기능과 사용 편의성 때문에 .NET 에코시스템 전체에서 널리 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-118">`BinaryFormatter` is widely used throughout the .NET ecosystem because of its power and its ease of use.</span></span> <span data-ttu-id="0b611-119">그러나 이 동일한 기능으로 인해 공격자가 대상 앱 내의 제어 흐름에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-119">However, this same power gives attackers the ability to influence control flow within the target app.</span></span> <span data-ttu-id="0b611-120">공격이 성공하면 공격자가 대상 프로세스의 컨텍스트 내에서 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-120">Successful attacks can result in the attacker being able to run code within the context of the target process.</span></span>

<span data-ttu-id="0b611-121">더 간단한 비유로, 페이로드에 대해 `BinaryFormatter.Deserialize`를 호출하는 것은 해당 페이로드를 독립 실행형 실행 파일로 해석하고 시작하는 것과 같다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-121">As a simpler analogy, assume that calling `BinaryFormatter.Deserialize` over a payload is the equivalent of interpreting that payload as a standalone executable and launching it.</span></span>

## <a name="binaryformatter-security-vulnerabilities"></a><span data-ttu-id="0b611-122">BinaryFormatter 보안 취약성</span><span class="sxs-lookup"><span data-stu-id="0b611-122">BinaryFormatter security vulnerabilities</span></span>

> [!WARNING]
> <span data-ttu-id="0b611-123">`BinaryFormatter.Deserialize` 메서드는 신뢰할 수 없는 입력과 함께 사용할 경우 안전하지 __않습니다__.</span><span class="sxs-lookup"><span data-stu-id="0b611-123">The `BinaryFormatter.Deserialize` method is __never__ safe when used with untrusted input.</span></span> <span data-ttu-id="0b611-124">이 문서의 뒷부분에서 설명하는 대체 방법 중 하나를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-124">We strongly recommend that consumers instead consider using one of the alternatives outlined later in this article.</span></span>

<span data-ttu-id="0b611-125">`BinaryFormatter`는 deserialization 취약성이 잘 파악된 위협 범주가 되기 전에 구현되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-125">`BinaryFormatter` was implemented before deserialization vulnerabilities were a well-understood threat category.</span></span> <span data-ttu-id="0b611-126">따라서 코드가 최신 모범 사례를 따르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-126">As a result, the code does not follow modern best practices.</span></span> <span data-ttu-id="0b611-127">`Deserialize` 메서드는 공격자가 앱 사용에 대해 DoS 공격을 수행하기 위한 벡터로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-127">The `Deserialize` method can be used as a vector for attackers to perform DoS attacks against consuming apps.</span></span> <span data-ttu-id="0b611-128">해당 공격으로 인해 앱이 응답하지 않거나 예기치 않게 프로세스가 종료될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-128">These attacks might render the app unresponsive or result in unexpected process termination.</span></span> <span data-ttu-id="0b611-129">이 공격 범주는 `SerializationBinder` 또는 다른 `BinaryFormatter` 구성 스위치를 사용하여 완화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-129">This category of attack cannot be mitigated with a `SerializationBinder` or any other `BinaryFormatter` configuration switch.</span></span> <span data-ttu-id="0b611-130">.NET에서는 이 동작을 ‘의도적’인 것으로 간주하고 동작을 수정하는 코드 업데이트를 실행하지 않습니다.\*\*\*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="0b611-130">.NET considers this behavior to be ***by design*** and won't issue a code update to modify the behavior.</span></span>

<span data-ttu-id="0b611-131">`BinaryFormatter.Deserialize`는 정보 공개 또는 원격 코드 실행과 같은 다른 공격 범주에 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-131">`BinaryFormatter.Deserialize` may be vulnerable to other attack categories, such as information disclosure or remote code execution.</span></span> <span data-ttu-id="0b611-132">사용자 지정 <xref:System.Runtime.Serialization.SerializationBinder>와 같은 기능을 활용하는 것만으로는 이러한 위험을 제대로 완화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-132">Utilizing features such as a custom <xref:System.Runtime.Serialization.SerializationBinder> may be insufficient to properly mitigate these risks.</span></span> <span data-ttu-id="0b611-133">.NET에서 보안 업데이트를 실제로 게시할 수 없는 새로운 취약성이 발견될 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-133">The possibility exists that a novel vulnerability will be discovered for which .NET cannot practically publish a security update.</span></span> <span data-ttu-id="0b611-134">소비자는 개별 시나리오를 평가하고 이러한 위험에 노출될 가능성을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-134">Consumers should assess their individual scenarios and consider their potential exposure to these risks.</span></span>

<span data-ttu-id="0b611-135">`BinaryFormatter` 소비자는 해당 앱에서 개별 위험 평가를 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-135">We recommend that `BinaryFormatter` consumers perform individual risk assessments on their apps.</span></span> <span data-ttu-id="0b611-136">`BinaryFormatter`를 활용할지 여부를 결정하는 것은 전적으로 소비자의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-136">It is the consumer's sole responsibility to determine whether to utilize `BinaryFormatter`.</span></span> <span data-ttu-id="0b611-137">소비자는 `BinaryFormatter` 사용과 관련된 보안, 기술, 평판, 법률 및 규제 요구 사항을 평가하는 위험을 감수해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-137">Consumers should risk assess the security, technical, reputation, legal, and regulatory requirements of using `BinaryFormatter`.</span></span>

## <a name="preferred-alternatives"></a><span data-ttu-id="0b611-138">기본 설정 대안</span><span class="sxs-lookup"><span data-stu-id="0b611-138">Preferred alternatives</span></span>

<span data-ttu-id="0b611-139">.NET에는 신뢰할 수 없는 데이터를 안전하게 처리할 수 있는 여러 가지 기본 제공 직렬 변환기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-139">.NET offers several in-box serializers that can handle untrusted data safely:</span></span>

* <span data-ttu-id="0b611-140"><xref:System.Xml.Serialization.XmlSerializer> 및 <xref:System.Runtime.Serialization.DataContractSerializer> - 개체 그래프를 XML로 직렬화 및 XML에서 직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-140"><xref:System.Xml.Serialization.XmlSerializer> and <xref:System.Runtime.Serialization.DataContractSerializer> to serialize object graphs into and from XML.</span></span> <span data-ttu-id="0b611-141">`DataContractSerializer`를 <xref:System.Runtime.Serialization.NetDataContractSerializer>와 혼동하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="0b611-141">Do not confuse `DataContractSerializer` with  <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span>
* <span data-ttu-id="0b611-142"><xref:System.IO.BinaryReader> 및 <xref:System.IO.BinaryWriter> - XML 및 JSON에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-142"><xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for XML and JSON.</span></span>
* <span data-ttu-id="0b611-143"><xref:System.Text.Json> API - 개체 그래프를 JSON으로 직렬화합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-143">The <xref:System.Text.Json> APIs to serialize object graphs into JSON.</span></span>

## <a name="dangerous-alternatives"></a><span data-ttu-id="0b611-144">위험한 대안</span><span class="sxs-lookup"><span data-stu-id="0b611-144">Dangerous alternatives</span></span>

<span data-ttu-id="0b611-145">다음 직렬 변환기는 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="0b611-145">Avoid the following serializers:</span></span>

* <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>
* <xref:System.Web.UI.LosFormatter>
* <xref:System.Runtime.Serialization.NetDataContractSerializer>
* <xref:System.Web.UI.ObjectStateFormatter>

<span data-ttu-id="0b611-146">앞의 직렬 변환기는 모두 무제한 다형성 deserialization을 수행하며 `BinaryFormatter`와 마찬가지로 위험합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-146">The preceding serializers all perform unrestricted polymorphic deserialization and are dangerous, just like `BinaryFormatter`.</span></span>

## <a name="the-risks-of-assuming-data-to-be-trustworthy"></a><span data-ttu-id="0b611-147">데이터를 신뢰할 수 있다고 가정할 경우의 위험</span><span class="sxs-lookup"><span data-stu-id="0b611-147">The risks of assuming data to be trustworthy</span></span>

<span data-ttu-id="0b611-148">앱 개발자가 신뢰할 수 있는 입력만 처리하고 있다고 믿는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-148">Frequently, an app developer might believe that they are processing only trusted input.</span></span> <span data-ttu-id="0b611-149">드물긴 하지만 안전한 입력 사례인 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-149">The safe input case is true in some rare circumstances.</span></span> <span data-ttu-id="0b611-150">그러나 개발자 모르게 페이로드가 신뢰 경계를 넘어가는 경우가 훨씬 더 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-150">But it's much more common that a payload crosses a trust boundary without the developer realizing it.</span></span>

<span data-ttu-id="0b611-151">직원들이 워크스테이션의 데스크톱 클라이언트를 사용하여 서비스를 조작하는 경우 __온-프레미스 서버를 고려합니다__.</span><span class="sxs-lookup"><span data-stu-id="0b611-151">__Consider an on-prem server__ where employees use a desktop client from their workstations to interact with the service.</span></span> <span data-ttu-id="0b611-152">이 시나리오는 기본적으로 `BinaryFormatter` 활용이 허용되는 “안전한” 설치로 간주할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-152">This scenario might be seen naïvely as a "safe" setup where utilizing `BinaryFormatter` is acceptable.</span></span> <span data-ttu-id="0b611-153">그러나 이 시나리오는 단일 직원 머신에 대한 액세스 권한을 얻은 맬웨어가 기업 전체에 확산할 수 있는 벡터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-153">However, this scenario presents a vector for malware that gains access to a single employee's machine to be able to spread throughout the enterprise.</span></span> <span data-ttu-id="0b611-154">해당 맬웨어는 기업의 `BinaryFormatter` 사용을 활용하여 직원 워크스테이션에서 백 엔드 서버로 수평 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-154">That malware can leverage the enterprise's use of `BinaryFormatter` to move laterally from the employee's workstation to the backend server.</span></span> <span data-ttu-id="0b611-155">그런 다음, 회사의 중요한 데이터를 반출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-155">It can then exfiltrate the company's sensitive data.</span></span> <span data-ttu-id="0b611-156">이러한 데이터는 거래 비밀 또는 고객 데이터를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-156">Such data could include trade secrets or customer data.</span></span>

<span data-ttu-id="0b611-157">__`BinaryFormatter`를 사용하여 저장 상태를 유지하는 앱도 고려합니다.__</span><span class="sxs-lookup"><span data-stu-id="0b611-157">__Consider also an app that uses `BinaryFormatter` to persist save state.__</span></span> <span data-ttu-id="0b611-158">처음에는 사용자 고유의 하드 드라이브에서 데이터를 읽고 쓰는 것이 사소한 위협을 나타내므로 안전한 시나리오처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-158">This might at first seem to be a safe scenario, as reading and writing data on your own hard drive represents a minor threat.</span></span> <span data-ttu-id="0b611-159">그러나 전자 메일 또는 인터넷을 통한 문서 공유가 일반적이며, 대부분의 최종 사용자는 다운로드된 파일을 여는 것을 위험한 동작으로 인식하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-159">However, sharing documents across email or the internet is common, and most end users wouldn't perceive opening these downloaded files as risky behavior.</span></span>

<span data-ttu-id="0b611-160">이 시나리오는 불법적인 결과로 활용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-160">This scenario can be leveraged to nefarious effect.</span></span> <span data-ttu-id="0b611-161">앱이 게임인 경우 저장 파일을 공유하는 사용자는 자신도 모르게 위험에 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-161">If the app is a game, users who share save files unknowingly place themselves at risk.</span></span> <span data-ttu-id="0b611-162">개발자 자신도 대상이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-162">The developers themselves can also be targeted.</span></span> <span data-ttu-id="0b611-163">공격자는 개발자의 기술 지원팀에 전자 메일을 보내고 악성 데이터 파일을 첨부하여 지원 담당자에게 파일을 열도록 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-163">The attacker might email the developers' tech support, attaching a malicious data file and asking the support staff to open it.</span></span> <span data-ttu-id="0b611-164">이러한 종류의 공격을 통해 공격자는 기업에 침투할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-164">This kind of attack could give the attacker a foothold in the enterprise.</span></span>

<span data-ttu-id="0b611-165">또 다른 시나리오는 데이터 파일이 클라우드 스토리지에 저장되고 사용자 머신 간에 자동으로 동기화되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-165">Another scenario is where the data file is stored in cloud storage and automatically synced between the user's machines.</span></span> <span data-ttu-id="0b611-166">클라우드 스토리지 계정에 대한 액세스 권한을 얻을 수 있는 공격자는 데이터 파일을 감염시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-166">An attacker who is able to gain access to the cloud storage account can poison the data file.</span></span> <span data-ttu-id="0b611-167">이 데이터 파일이 사용자 머신에 자동으로 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-167">This data file will be automatically synced to the user's machines.</span></span> <span data-ttu-id="0b611-168">사용자가 다음에 데이터 파일을 열면 공격자의 페이로드가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-168">The next time the user opens the data file, the attacker's payload runs.</span></span> <span data-ttu-id="0b611-169">따라서 공격자는 클라우드 스토리지 계정 손상을 활용하여 전체 코드 실행 권한을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-169">Thus the attacker can leverage a cloud storage account compromise to gain full code execution permissions.</span></span>

<span data-ttu-id="0b611-170">__데스크톱 설치 모델에서 클라우드 우선 모델로 이동하는 앱을 고려합니다.__</span><span class="sxs-lookup"><span data-stu-id="0b611-170">__Consider an app that moves from a desktop-install model to a cloud-first model.__</span></span> <span data-ttu-id="0b611-171">이 시나리오에는 데스크톱 앱 또는 리치 클라이언트 모델에서 웹 기반 모델로 이동하는 앱이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-171">This scenario includes apps that move from a desktop app or rich client model into a web-based model.</span></span> <span data-ttu-id="0b611-172">데스크톱 앱에 대해 작성된 모든 위협 모델이 클라우드 기반 서비스에 반드시 적용되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-172">Any threat models drawn for the desktop app aren't necessarily applicable to the cloud-based service.</span></span> <span data-ttu-id="0b611-173">데스크톱 앱에 대한 위협 모델에서 지정된 위협을 “자신을 공격하는 클라이언트에 관련이 없는 것”으로 해제할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-173">The threat model for the desktop app might dismiss a given threat as "not interesting for the client to attack itself."</span></span> <span data-ttu-id="0b611-174">그러나 클라우드 서비스 자체를 공격하는 원격 사용자(클라이언트)를 고려할 경우 동일한 위협이 관련될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-174">But that same threat might become interesting when it considers a remote user (the client) attacking the cloud service itself.</span></span>

> [!NOTE]
> <span data-ttu-id="0b611-175">일반적인 용어의 serialization은 개체를 앱에(서) 전송하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-175">In general terms, the intent of serialization is to transmit an object into or out of an app.</span></span> <span data-ttu-id="0b611-176">위협 모델링 연습에서 이러한 종류의 데이터 전송은 거의 항상 신뢰 경계를 넘는 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b611-176">A threat modeling exercise almost always marks this kind of data transfer as crossing a trust boundary.</span></span>

## <a name="further-resources"></a><span data-ttu-id="0b611-177">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="0b611-177">Further resources</span></span>

* <span data-ttu-id="0b611-178">[YSoSerial.Net](https://github.com/pwntester/ysoserial.net) - `BinaryFormatter`를 활용하는 앱을 공격하는 방법 연구</span><span class="sxs-lookup"><span data-stu-id="0b611-178">[YSoSerial.Net](https://github.com/pwntester/ysoserial.net) for research into how adversaries attack apps that utilize `BinaryFormatter`.</span></span>
* <span data-ttu-id="0b611-179">[위협 모델링](/securityengineering/sdl/threatmodeling) - 위협 모델링 앱 및 서비스에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="0b611-179">[Threat Modeling](/securityengineering/sdl/threatmodeling) for information on threat modeling apps and services.</span></span>
* <span data-ttu-id="0b611-180">deserialization 취약성에 대한 일반적인 배경 정보:</span><span class="sxs-lookup"><span data-stu-id="0b611-180">General background on deserialization vulnerabilities:</span></span>
  * [<span data-ttu-id="0b611-181">OWASP 상위 10 - A8:2017-안전하지 않은 deserialization</span><span class="sxs-lookup"><span data-stu-id="0b611-181">OWASP Top 10 - A8:2017-Insecure Deserialization</span></span>](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A8-Insecure_Deserialization)
  * [<span data-ttu-id="0b611-182">CWE-502: 신뢰할 수 없는 데이터의 deserialization</span><span class="sxs-lookup"><span data-stu-id="0b611-182">CWE-502: Deserialization of Untrusted Data</span></span>](https://cwe.mitre.org/data/definitions/502.html)
