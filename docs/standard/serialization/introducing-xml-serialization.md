---
title: XML 직렬화에 대한 세부 정보
description: Serialization은 개체를 전송 가능한 양식으로 변환합니다. 이 문서에서는 XML serialization 및 XmlSerializer 클래스를 개략적으로 설명합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XML serialization, about XML serialization
- ICollection interface, serializing
- XmlSerializer class, serializing
- serialization, about serialization
- DataSet class, serializing
- XML Schema, serializing
ms.assetid: 8c63200d-db63-4a03-a93d-21641623df62
ms.openlocfilehash: 2971f5bbd587dabb62d095da3fef0b428ea9f039
ms.sourcegitcommit: 74d05613d6c57106f83f82ce8ee71176874ea3f0
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2020
ms.locfileid: "93282281"
---
# <a name="xml-serialization"></a><span data-ttu-id="ad2f3-104">XML serialization</span><span class="sxs-lookup"><span data-stu-id="ad2f3-104">XML serialization</span></span>

<span data-ttu-id="ad2f3-105">serialization은 개체를 전송할 수 있는 형태로 변환하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-105">Serialization is the process of converting an object into a form that can be readily transported.</span></span> <span data-ttu-id="ad2f3-106">예를 들어 개체를 serialize하고 클라이언트와 서버 사이에 HTTP를 사용하여 인터넷을 통해 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-106">For example, you can serialize an object and transport it over the Internet using HTTP between a client and a server.</span></span> <span data-ttu-id="ad2f3-107">반면 deserialization은 스트림에서 개체를 다시 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-107">On the other end, deserialization reconstructs the object from the stream.</span></span>

 <span data-ttu-id="ad2f3-108">XML serialization은 개체의 public 필드와 속성 값만 XML 스트림으로 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-108">XML serialization serializes only the public fields and property values of an object into an XML stream.</span></span> <span data-ttu-id="ad2f3-109">XML serialization에는 형식 정보가 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-109">XML serialization does not include type information.</span></span> <span data-ttu-id="ad2f3-110">예를 들어 **Library** 네임스페이스에 존재하는 **Book** 개체가 있는 경우에는 같은 형식의 개체로 역직렬화된다는 보장이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-110">For example, if you have a **Book** object that exists in the **Library** namespace, there is no guarantee that it is deserialized into an object of the same type.</span></span>

> [!NOTE]
> <span data-ttu-id="ad2f3-111">XML serialization은 메서드, 인덱서, 전용 필드 또는 읽기 전용 속성을 변환하지 않습니다. 단, 읽기 전용 컬렉션은 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-111">XML serialization does not convert methods, indexers, private fields, or read-only properties (except read-only collections).</span></span> <span data-ttu-id="ad2f3-112">공용 및 전용을 모두 포함하여 개체의 필드 및 속성을 모두 serialize하려면 XML serialization 대신 <xref:System.Runtime.Serialization.DataContractSerializer>를 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-112">To serialize all an object's fields and properties, both public and private, use the <xref:System.Runtime.Serialization.DataContractSerializer> instead of XML serialization.</span></span>

 <span data-ttu-id="ad2f3-113">XML serialization의 핵심 클래스는 <xref:System.Xml.Serialization.XmlSerializer> 클래스이며 이 클래스에서 가장 중요한 메서드는 **Serialize** 및 **Deserialize** 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-113">The central class in XML serialization is the <xref:System.Xml.Serialization.XmlSerializer> class, and the most important methods in this class are the **Serialize** and **Deserialize** methods.</span></span> <span data-ttu-id="ad2f3-114"><xref:System.Xml.Serialization.XmlSerializer>는 C# 파일을 만들고 이를 .dll 파일로 컴파일하여 이 serialization을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-114">The <xref:System.Xml.Serialization.XmlSerializer> creates C# files and compiles them into .dll files to perform this serialization.</span></span> <span data-ttu-id="ad2f3-115">[XML 직렬 변환기 생성기 도구(Sgen.exe)](xml-serializer-generator-tool-sgen-exe.md)는 애플리케이션과 함께 배포하기 전에 이러한 직렬화 어셈블리를 생성하고 시작 성능을 향상시키도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-115">The [XML Serializer Generator Tool (Sgen.exe)](xml-serializer-generator-tool-sgen-exe.md) is designed to generate these serialization assemblies in advance to be deployed with your application and improve startup performance.</span></span> <span data-ttu-id="ad2f3-116">**XmlSerializer** 로 생성된 XML 스트림은 World Wide Web 컨소시엄(W3C) [XSD(XML 스키마 정의 언어) 1.0 권장 사항](https://www.w3.org/TR/xslt)을 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-116">The XML stream generated by the **XmlSerializer** is compliant with the World Wide Web Consortium (W3C) [XML Schema definition language (XSD) 1.0 recommendation](https://www.w3.org/TR/xslt).</span></span> <span data-ttu-id="ad2f3-117">또한 생성된 데이터 형식은 문서 "XML Schema Part 2: Datatypes"를 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-117">Furthermore, the data types generated are compliant with the document titled "XML Schema Part 2: Datatypes."</span></span>

 <span data-ttu-id="ad2f3-118">개체 내의 데이터는 클래스, 필드, 속성, 기본 형식, 배열 및 **XmlElement** 또는 **XmlAttribute** 개체 형태로 포함된 XML과 같은 프로그래밍 언어 구조를 통하여 설명됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-118">The data in your objects is described using programming language constructs like classes, fields, properties, primitive types, arrays, and even embedded XML in the form of **XmlElement** or **XmlAttribute** objects.</span></span> <span data-ttu-id="ad2f3-119">특성으로 주석이 첨부된 클래스를 직접 만들거나, XML 스키마 정의 도구를 사용하여 기존 XML 스키마를 기반으로 클래스를 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-119">You have the option of creating your own classes, annotated with attributes, or using the XML Schema Definition tool to generate the classes based on an existing XML Schema.</span></span>

 <span data-ttu-id="ad2f3-120">XML 스키마가 있는 경우, XML 스키마 정의 도구를 실행하여 스키마로 강력하게 형식화되고 주석이 첨부된 클래스 집합을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-120">If you have an XML Schema, you can run the XML Schema Definition tool to produce a set of classes that are strongly typed to the schema and annotated with attributes.</span></span> <span data-ttu-id="ad2f3-121">이러한 클래스의 인스턴스가 serialize될 때 생성된 XML은 XML 스키마를 준수합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-121">When an instance of such a class is serialized, the generated XML adheres to the XML Schema.</span></span> <span data-ttu-id="ad2f3-122">이러한 클래스를 사용하면 생성된 XML이 XML 스키마를 준수하도록 하면서 손쉽게 조작할 수 있는 개체 모델을 사용하여 프로그래밍할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-122">Provided with such a class, you can program against an easily manipulated object model while being assured that the generated XML conforms to the XML schema.</span></span> <span data-ttu-id="ad2f3-123">이 방법은 **XmlReader** 및 **XmlWriter** 클래스와 같은 .NET의 다른 클래스 대신 사용하여 XML 스트림을 구문 분석하고 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-123">This is an alternative to using other classes in .NET, such as the **XmlReader** and **XmlWriter** classes, to parse and write an XML stream.</span></span> <span data-ttu-id="ad2f3-124">자세한 내용은 [XML 문서 및 데이터](../data/xml/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-124">For more information, see [XML Documents and Data](../data/xml/index.md).</span></span> <span data-ttu-id="ad2f3-125">이러한 클래스를 사용하면 모든 XML 스트림을 구문 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-125">These classes allow you to parse any XML stream.</span></span> <span data-ttu-id="ad2f3-126">반면 XML 스트림이 알려진 XML 스키마를 준수해야 하는 경우에는 **XmlSerializer** 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-126">In contrast, use the **XmlSerializer** when the XML stream is expected to conform to a known XML Schema.</span></span>

 <span data-ttu-id="ad2f3-127">특성은 **XmlSerializer** 클래스로 생성된 XML 스트림을 제어하기 때문에 XML 스트림의 XML 네임스페이스, 요소 이름, 특성 이름 등을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-127">Attributes control the XML stream generated by the **XmlSerializer** class, allowing you to set the XML namespace, element name, attribute name, and so on, of the XML stream.</span></span> <span data-ttu-id="ad2f3-128">이러한 특성에 대한 자세한 내용 및 이러한 특성이 XML serialization을 제어하는 방법에 대해서는 [특성을 사용하여 XML Serialization 제어](controlling-xml-serialization-using-attributes.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-128">For more information about these attributes and how they control XML serialization, see [Controlling XML Serialization Using Attributes](controlling-xml-serialization-using-attributes.md).</span></span> <span data-ttu-id="ad2f3-129">생성된 XML의 제어에 사용되는 특성의 표를 보려면 [XML Serialization을 제어하는 특성](attributes-that-control-xml-serialization.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-129">For a table of those attributes that are used to control the generated XML, see [Attributes That Control XML Serialization](attributes-that-control-xml-serialization.md).</span></span>

 <span data-ttu-id="ad2f3-130">**XmlSerializer** 클래스는 개체를 추가적으로 직렬화하여 인코딩된 SOAP XML 스트림을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-130">The **XmlSerializer** class can further serialize an object and generate an encoded SOAP XML stream.</span></span> <span data-ttu-id="ad2f3-131">생성된 XML은 World Wide Web 컨소시엄 문서 "SOAP(Simple Object Access Protocol) 1.1"의 5단원을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-131">The generated XML adheres to section 5 of the World Wide Web Consortium document titled "Simple Object Access Protocol (SOAP) 1.1."</span></span> <span data-ttu-id="ad2f3-132">이 프로세스에 대한 자세한 내용은 [방법: 개체를 SOAP 인코딩된 XML 스트림으로 직렬화](how-to-serialize-an-object-as-a-soap-encoded-xml-stream.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-132">For more information about this process, see [How to: Serialize an Object as a SOAP-Encoded XML Stream](how-to-serialize-an-object-as-a-soap-encoded-xml-stream.md).</span></span> <span data-ttu-id="ad2f3-133">생성된 XML을 제어하는 특성의 표를 보려면 [인코딩된 SOAP Serialization을 제어하는 특성](attributes-that-control-encoded-soap-serialization.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-133">For a table of the attributes that control the generated XML, see [Attributes That Control Encoded SOAP Serialization](attributes-that-control-encoded-soap-serialization.md).</span></span>

 <span data-ttu-id="ad2f3-134">**XmlSerializer** 클래스는 XML Web services에 의해 생성되고 XML Web services로 전달되는 SOAP 메시지를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-134">The **XmlSerializer** class generates the SOAP messages created by, and passed to, XML Web services.</span></span> <span data-ttu-id="ad2f3-135">SOAP 메시지를 제어하려면 XML Web services 파일(.asmx)의 클래스, 반환 값, 매개 변수 및 필드에 특성을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-135">To control the SOAP messages, you can apply attributes to the classes, return values, parameters, and fields found in an XML Web service file (.asmx).</span></span> <span data-ttu-id="ad2f3-136">XML Web services는 리터럴 또는 인코딩된 SOAP 스타일을 사용할 수 있으므로 "XML serialization을 제어하는 특성" 및 "인코딩된 SOAP serialization을 제어하는 특성"에 나열된 두 특성을 모두 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-136">You can use both the attributes listed in "Attributes That Control XML Serialization" and "Attributes That Control Encoded SOAP Serialization" because an XML Web service can use either the literal or encoded SOAP style.</span></span> <span data-ttu-id="ad2f3-137">특성을 사용하여 XML Web services에서 생성된 XML을 제어하는 방법에 대한 자세한 내용은 [XML Web Services의 XML Serialization](xml-serialization-with-xml-web-services.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-137">For more information about using attributes to control the XML generated by an XML Web service, see [XML Serialization with XML Web Services](xml-serialization-with-xml-web-services.md).</span></span> <span data-ttu-id="ad2f3-138">SOAP 및 XML Web Services에 대한 자세한 내용은 [SOAP 메시지 형식 사용자 지정](/previous-versions/dotnet/netframework-4.0/dkwy2d72(v=vs.100))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-138">For more information about SOAP and XML Web services, see [Customizing SOAP Message Formatting](/previous-versions/dotnet/netframework-4.0/dkwy2d72(v=vs.100)).</span></span>

## <a name="security-considerations-for-xmlserializer-applications"></a><span data-ttu-id="ad2f3-139">XmlSerializer 애플리케이션에 대한 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad2f3-139">Security Considerations for XmlSerializer Applications</span></span>

<span data-ttu-id="ad2f3-140">**XmlSerializer** 를 사용하는 애플리케이션을 만들 때 다음과 같은 항목과 해당 영향에 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-140">When creating an application that uses the **XmlSerializer** , be aware of the following items and their implications:</span></span>

- <span data-ttu-id="ad2f3-141">**XmlSerializer** 는 C# 파일(.cs)을 만들어서 TEMP 환경 변수에 의해 이름 지정된 디렉터리의 .dll 파일로 컴파일합니다. 이 DLL을 사용하여 serialization이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-141">The **XmlSerializer** creates C# (.cs) files and compiles them into .dll files in the directory named by the TEMP environment variable; serialization occurs with those DLLs.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ad2f3-142">이러한 serialization 어셈블리는 SGen.exe 도구를 사용하여 미리 생성하고 서명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-142">These serialization assemblies can be generated in advance and signed by using the SGen.exe tool.</span></span> <span data-ttu-id="ad2f3-143">웹 서비스의 서버에는 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-143">This does not work a server of Web services.</span></span> <span data-ttu-id="ad2f3-144">즉, 클라이언트 및 수동 serialization 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-144">In other words, it is only for client use and for manual serialization.</span></span>

  <span data-ttu-id="ad2f3-145">코드 및 DLL은 생성 및 컴파일 시점에서 악의적 프로세스에 취약합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-145">The code and the DLLs are vulnerable to a malicious process at the time of creation and compilation.</span></span> <span data-ttu-id="ad2f3-146">Microsoft Windows NT 4.0 이상을 실행하는 컴퓨터에서 사용할 때는 둘 이상의 사용자가 TEMP 디렉터리를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-146">When using a computer running Microsoft Windows NT 4.0 or later, it might be possible for two or more users to share the TEMP directory.</span></span> <span data-ttu-id="ad2f3-147">두 계정의 보안 권한이 서로 다르고 높은 권한의 계정이 **XmlSerializer** 를 사용하여 애플리케이션을 실행하는 경우 TEMP 디렉터리를 공유하는 것이 위험합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-147">Sharing a TEMP directory is dangerous if the two accounts have different security privileges and the higher-privilege account runs an application using the **XmlSerializer**.</span></span> <span data-ttu-id="ad2f3-148">이 경우 한 사용자가 컴파일된 .cs 또는 .dll 파일을 바꿔 컴퓨터의 보안을 침해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-148">In this case, one user can breach the computer's security by replacing either the .cs or .dll file that is compiled.</span></span> <span data-ttu-id="ad2f3-149">이런 문제를 방지하기 위해 항상 컴퓨터의 각 계정마다 자체 프로필을 사용하도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-149">To eliminate this concern, always be sure that each account on the computer has its own profile.</span></span> <span data-ttu-id="ad2f3-150">기본적으로 TEMP 환경 변수는 각 계정마다 서로 다른 디렉터리를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-150">By default, the TEMP environment variable points to a different directory for each account.</span></span>

- <span data-ttu-id="ad2f3-151">악의적 사용자가 XML 데이터의 연속 스트림을 웹 서버에 전송하면(서비스 거부 공격) **XmlSerializer** 는 컴퓨터 리소스가 부족해질 때까지 데이터를 계속 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-151">If a malicious user sends a continuous stream of XML data to a Web server (a denial of service attack), then the **XmlSerializer** continues to process the data until the computer runs low on resources.</span></span>

  <span data-ttu-id="ad2f3-152">IIS(인터넷 정보 서비스)를 실행하는 컴퓨터를 사용하여 애플리케이션이 IIS 내에서 실행되는 경우에는 이러한 종류의 공격이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-152">This kind of attack is eliminated if you are using a computer running Internet Information Services (IIS), and your application is running within IIS.</span></span> <span data-ttu-id="ad2f3-153">IIS에는 설정된 길이(기본값은 4KB)보다 긴 스트림은 처리하지 않는 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-153">IIS features a gate that does not process streams longer than a set amount (the default is 4 KB).</span></span> <span data-ttu-id="ad2f3-154">IIS를 사용하지 않는 애플리케이션을 만들고 **XmlSerializer** 로 역직렬화하는 경우에는 서비스 거부 공격을 차단하는 이와 비슷한 기능을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-154">If you create an application that does not use IIS and deserializes with the **XmlSerializer** , you should implement a similar gate that prevents a denial of service attack.</span></span>

- <span data-ttu-id="ad2f3-155">**XmlSerializer** 에서는 데이터를 직렬화하고 주어진 모든 형식을 사용하여 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-155">The **XmlSerializer** serializes data and runs any code using any type given to it.</span></span>

  <span data-ttu-id="ad2f3-156">악의적 개체가 위협을 초래하는 방법에는 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-156">There are two ways in which a malicious object presents a threat.</span></span> <span data-ttu-id="ad2f3-157">즉, 악의적 코드를 실행하거나 **XmlSerializer** 에서 만들어진 C# 파일에 악의적 코드를 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-157">It could run malicious code or it could inject malicious code into the C# file created by the **XmlSerializer**.</span></span> <span data-ttu-id="ad2f3-158">첫 번째 경우 악의적 개체가 안전하지 않은 절차의 실행을 시도하면 코드 액세스 보안이 이러한 행위로 인한 손상 예방에 도움을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-158">In the first case, if a malicious object tries to run a destructive procedure, code access security helps prevent any damage from being done.</span></span> <span data-ttu-id="ad2f3-159">두 번째 경우 이론적으로는 악의적 개체가 **XmlSerializer** 에서 만들어진 C# 파일에 코드를 삽입할 수 있는 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-159">In the second case, there is a theoretical possibility that a malicious object may somehow inject code into the C# file created by the **XmlSerializer**.</span></span> <span data-ttu-id="ad2f3-160">이 문제는 철저하게 검사되었고 이러한 공격이 수행될 가능성도 거의 없지만 알려지지 않은 형식과 신뢰할 수 없는 형식으로 데이터를 serialize하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-160">Although this issue has been examined thoroughly, and such an attack is considered unlikely, you should take the precaution of never serializing data with an unknown and untrusted type.</span></span>

- <span data-ttu-id="ad2f3-161">serialize된 중요한 데이터가 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-161">Serialized sensitive data might be vulnerable.</span></span>

  <span data-ttu-id="ad2f3-162">**XmlSerializer** 에서 데이터를 직렬화한 후 XML 파일이나 다른 데이터 저장소에 이를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-162">After the **XmlSerializer** has serialized data, it can be stored as an XML file or other data store.</span></span> <span data-ttu-id="ad2f3-163">데이터 저장소를 다른 프로세스가 사용할 수 있거나 인트라넷 또는 인터넷에서 볼 수 있는 경우에는 데이터가 도난당하여 해로운 목적으로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-163">If your data store is available to other processes, or is visible on an intranet or the Internet, the data can be stolen and used maliciously.</span></span> <span data-ttu-id="ad2f3-164">예를 들어 신용카드 번호가 포함된 주문을 serialize하는 애플리케이션을 만드는 경우에는 데이터가 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-164">For example, if you create an application that serializes orders that include credit card numbers, the data is highly sensitive.</span></span> <span data-ttu-id="ad2f3-165">이런 문제를 방지하기 위해 항상 데이터 저장소를 보호하고 공개되지 않도록 조치를 취해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-165">To help prevent this, always protect the store for your data and take steps to keep it private.</span></span>

## <a name="serialization-of-a-simple-class"></a><span data-ttu-id="ad2f3-166">간단한 클래스의 serialization</span><span class="sxs-lookup"><span data-stu-id="ad2f3-166">Serialization of a Simple Class</span></span>

<span data-ttu-id="ad2f3-167">다음 코드 예제에서는 public 필드가 있는 기본 클래스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-167">The following code example shows a basic class with a public field.</span></span>

```vb
Public Class OrderForm
    Public OrderDate As DateTime
End Class
```

```csharp
public class OrderForm
{
    public DateTime OrderDate;
}
```

<span data-ttu-id="ad2f3-168">이 클래스의 인스턴스를 serialize하면 다음과 같을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-168">When an instance of this class is serialized, it might resemble the following.</span></span>

```xml
<OrderForm>
    <OrderDate>12/12/01</OrderDate>
</OrderForm>
```

<span data-ttu-id="ad2f3-169">Serialization에 대한 다른 예제를 보려면 [XML Serialization 예제](examples-of-xml-serialization.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-169">For more examples of serialization, see [Examples of XML Serialization](examples-of-xml-serialization.md).</span></span>

## <a name="items-that-can-be-serialized"></a><span data-ttu-id="ad2f3-170">serialize할 수 있는 항목</span><span class="sxs-lookup"><span data-stu-id="ad2f3-170">Items That Can Be Serialized</span></span>

<span data-ttu-id="ad2f3-171">**XmlSerializer** 클래스를 사용하여 직렬화할 수 있는 항목은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-171">The following items can be serialized using the **XmlSerializer** class:</span></span>

- <span data-ttu-id="ad2f3-172">공용 클래스의 공용 읽기/쓰기 속성 및 필드</span><span class="sxs-lookup"><span data-stu-id="ad2f3-172">Public read/write properties and fields of public classes.</span></span>

- <span data-ttu-id="ad2f3-173">**ICollection** 또는 **IEnumerable** 을 구현하는 클래스</span><span class="sxs-lookup"><span data-stu-id="ad2f3-173">Classes that implement **ICollection** or **IEnumerable**.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ad2f3-174">public 속성이 아니라 컬렉션만 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-174">Only collections are serialized, not public properties.</span></span>

- <span data-ttu-id="ad2f3-175">**XmlElement** 개체</span><span class="sxs-lookup"><span data-stu-id="ad2f3-175">**XmlElement** objects.</span></span>

- <span data-ttu-id="ad2f3-176">**XmlNode** 개체</span><span class="sxs-lookup"><span data-stu-id="ad2f3-176">**XmlNode** objects.</span></span>

- <span data-ttu-id="ad2f3-177">**DataSet** 개체.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-177">**DataSet** objects.</span></span>

 <span data-ttu-id="ad2f3-178">개체 직렬화 또는 역직렬화에 대한 자세한 내용은 [방법: 개체 직렬화](how-to-serialize-an-object.md) 및 [방법: 개체 역직렬화](how-to-deserialize-an-object.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-178">For more information about serializing or deserializing objects, see [How to: Serialize an Object](how-to-serialize-an-object.md) and [How to: Deserialize an Object](how-to-deserialize-an-object.md).</span></span>

## <a name="advantages-of-using-xml-serialization"></a><span data-ttu-id="ad2f3-179">XML serialization 사용의 장점</span><span class="sxs-lookup"><span data-stu-id="ad2f3-179">Advantages of Using XML Serialization</span></span>

<span data-ttu-id="ad2f3-180">**XmlSerializer** 클래스를 사용하면 개체를 XML로 직렬화할 때 완전하고 유연하게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-180">The **XmlSerializer** class gives you complete and flexible control when you serialize an object as XML.</span></span> <span data-ttu-id="ad2f3-181">XML Web services를 만드는 경우 XML 출력이 특정 스키마를 따르도록 serialization을 제어하는 특성을 클래스와 멤버에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-181">If you are creating an XML Web service, you can apply attributes that control serialization to classes and members to ensure that the XML output conforms to a specific schema.</span></span>

<span data-ttu-id="ad2f3-182">예를 들어 **XmlSerializer** 를 사용하여 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-182">For example, **XmlSerializer** enables you to:</span></span>

- <span data-ttu-id="ad2f3-183">필드 또는 속성을 특성 또는 요소로 인코딩할 것인지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-183">Specify whether a field or property should be encoded as an attribute or an element.</span></span>

- <span data-ttu-id="ad2f3-184">사용할 XML 네임스페이스를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-184">Specify an XML namespace to use.</span></span>

- <span data-ttu-id="ad2f3-185">필드 또는 속성 이름이 부적절한 경우 요소 또는 특성의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-185">Specify the name of an element or attribute if a field or property name is inappropriate.</span></span>

<span data-ttu-id="ad2f3-186">XML serialization의 다른 장점은 생성되는 XML 스트림이 지정된 스키마를 따르기만 하면 개발하는 애플리케이션에 대한 제약 조건이 없다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-186">Another advantage of XML serialization is that you have no constraints on the applications you develop, as long as the XML stream that is generated conforms to a given schema.</span></span> <span data-ttu-id="ad2f3-187">책을 설명하는 데 사용되는 스키마를 예로 들어보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-187">Imagine a schema that is used to describe books.</span></span> <span data-ttu-id="ad2f3-188">이 경우 제목, 저자, 출판사 및 ISBN 번호 요소가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-188">It features a title, author, publisher, and ISBN number element.</span></span> <span data-ttu-id="ad2f3-189">XML 데이터를 책 주문 또는 책 재고 관리 등과 같은 원하는 방식으로 처리하는 애플리케이션을 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-189">You can develop an application that processes the XML data in any way you want, for example, as a book order, or as an inventory of books.</span></span> <span data-ttu-id="ad2f3-190">두 경우 모두 유일한 요구 사항은 XML 스트림이 지정된 XSD(XML 스키마 정의 언어) 스키마를 준수해야 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-190">In either case, the only requirement is that the XML stream conforms to the specified XML Schema definition language (XSD) schema.</span></span>

## <a name="xml-serialization-considerations"></a><span data-ttu-id="ad2f3-191">XML serialization 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ad2f3-191">XML Serialization Considerations</span></span>

<span data-ttu-id="ad2f3-192">다음은 **XmlSerializer** 클래스를 사용할 때 고려해야 할 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-192">The following should be considered when using the **XmlSerializer** class:</span></span>

- <span data-ttu-id="ad2f3-193">Sgen.exe 도구는 최적의 성능을 위해 serialization 어셈블리를 생성하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-193">The Sgen.exe tool is expressly designed to generate serialization assemblies for optimum performance.</span></span>

- <span data-ttu-id="ad2f3-194">serialize된 데이터에는 데이터 자체와 클래스의 구조만 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-194">The serialized data contains only the data itself and the structure of your classes.</span></span> <span data-ttu-id="ad2f3-195">형식 ID와 어셈블리 정보는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-195">Type identity and assembly information are not included.</span></span>

- <span data-ttu-id="ad2f3-196">public 속성 및 필드만 serialize될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-196">Only public properties and fields can be serialized.</span></span> <span data-ttu-id="ad2f3-197">속성에는 public 접근자(get 및 set 메서드)가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-197">Properties must have public accessors (get and set methods).</span></span> <span data-ttu-id="ad2f3-198">공용이 아닌 데이터를 serialize해야 하는 경우에는 XML serialization이 아닌 <xref:System.Runtime.Serialization.DataContractSerializer> 클래스를 사용하십시오.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-198">If you must serialize non-public data, use the <xref:System.Runtime.Serialization.DataContractSerializer> class rather than XML serialization.</span></span>

- <span data-ttu-id="ad2f3-199">클래스에는 **XmlSerializer** 에 의해 직렬화될 매개 변수가 없는 생성자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-199">A class must have a parameterless constructor to be serialized by **XmlSerializer**.</span></span>

- <span data-ttu-id="ad2f3-200">메서드는 serialize될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-200">Methods cannot be serialized.</span></span>

- <span data-ttu-id="ad2f3-201">**XmlSerializer** 는 다음과 같이 특정 요구 사항을 충족하는 경우 **IEnumerable** 또는 **ICollection** 을 서로 다르게 구현하는 클래스를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-201">**XmlSerializer** can process classes that implement **IEnumerable** or **ICollection** differently if they meet certain requirements, as follows.</span></span>

  <span data-ttu-id="ad2f3-202">**IEnumerable** 을 구현하는 클래스는 단일 매개 변수를 사용하는 공용 **Add** 메서드를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-202">A class that implements **IEnumerable** must implement a public **Add** method that takes a single parameter.</span></span> <span data-ttu-id="ad2f3-203">**Add** 메서드의 매개 변수는 **GetEnumerator** 메서드에서 반환된 **IEnumerator.Current** 속성에서 반환된 형식과 일관되어야 합니다(다형성).</span><span class="sxs-lookup"><span data-stu-id="ad2f3-203">The **Add** method's parameter must be consistent (polymorphic) with the type returned from the **IEnumerator.Current** property returned from the **GetEnumerator** method.</span></span>

  <span data-ttu-id="ad2f3-204">**IEnumerable** (예: **CollectionBase** ) 이외에 **ICollection** 을 구현하는 클래스에는 정수를 받는 공용 **Item** 이 인덱싱된 속성(C#에서는 인덱서)이 있어야 하며 **integer** 형식의 공용 **Count** 속성이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-204">A class that implements **ICollection** in addition to **IEnumerable** (such as **CollectionBase** ) must have a public **Item** indexed property (an indexer in C#) that takes an integer and it must have a public **Count** property of type **integer**.</span></span> <span data-ttu-id="ad2f3-205">**Add** 메서드로 전달되는 매개 변수는 **Item** 속성에서 반환된 형식과 같거나, 해당 기본 형식 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-205">The parameter passed to the **Add** method must be the same type as that returned from the **Item** property, or one of that type's bases.</span></span>

  <span data-ttu-id="ad2f3-206">**ICollection** 을 구현하는 클래스의 경우, 직렬화되는 값은 **GetEnumerator** 를 호출하는 대신 인덱싱된 **Item** 속성에서 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-206">For classes that implement **ICollection** , values to be serialized are retrieved from the indexed **Item** property rather than by calling **GetEnumerator**.</span></span> <span data-ttu-id="ad2f3-207">또한 다른 컬렉션 클래스( **ICollection** 을 구현하는 클래스)를 반환하는 public 필드를 제외하고 public 필드와 속성은 직렬화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-207">Also, public fields and properties are not serialized, with the exception of public fields that return another collection class (one that implements **ICollection** ).</span></span> <span data-ttu-id="ad2f3-208">예제를 보려면 [XML Serialization 예제](examples-of-xml-serialization.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-208">For an example, see [Examples of XML Serialization](examples-of-xml-serialization.md).</span></span>

## <a name="xsd-data-type-mapping"></a><span data-ttu-id="ad2f3-209">XSD 데이터 형식 매핑</span><span class="sxs-lookup"><span data-stu-id="ad2f3-209">XSD Data Type Mapping</span></span>

<span data-ttu-id="ad2f3-210">W3C 문서 [XML Schema Part 2: 데이터 형식](https://www.w3.org/TR/xmlschema-2/)은 XSD(XML 스키마 정의 언어) 스키마에서 허용되는 간단한 데이터 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-210">The W3C document titled [XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) specifies the simple data types that are allowed in an XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="ad2f3-211">이러한 형식(예: **int** 및 **decimal** )은 대부분 .NET에 해당 데이터 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-211">For many of these (for example, **int** and **decimal** ), there is a corresponding data type in .NET.</span></span> <span data-ttu-id="ad2f3-212">하지만 일부 XML 데이터 형식은 해당하는 .NET 데이터 형식이 없습니다(예: **NMTOKEN** 데이터 형식).</span><span class="sxs-lookup"><span data-stu-id="ad2f3-212">However, some XML data types do not have a corresponding .NET data type, for example, the **NMTOKEN** data type.</span></span> <span data-ttu-id="ad2f3-213">이러한 경우 [XML 스키마 정의 도구(Xsd.exe)](xml-schema-definition-tool-xsd-exe.md)를 사용하여 스키마에서 클래스를 생성하면 문자열 형식의 멤버에 적절한 특성이 적용되며 해당 **DataType** 속성이 XML 데이터 형식 이름으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-213">In such cases, if you use the XML Schema Definition tool ( [XML Schema Definition Tool (Xsd.exe)](xml-schema-definition-tool-xsd-exe.md)) to generate classes from a schema, an appropriate attribute is applied to a member of type string, and its **DataType** property is set to the XML data type name.</span></span> <span data-ttu-id="ad2f3-214">예를 들어 스키마에 XML 데이터 형식 **NMTOKEN** 의 “MyToken” 요소가 포함된 경우, 다음 예제처럼 생성되는 클래스에 멤버가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-214">For example, if a schema contains an element named "MyToken" with the XML data type **NMTOKEN** , the generated class might contain a member as shown in the following example.</span></span>

```vb
<XmlElement(DataType:="NMTOKEN")> _
Public MyToken As String
```

```csharp
[XmlElement(DataType = "NMTOKEN")]
public string MyToken;
```

<span data-ttu-id="ad2f3-215">마찬가지로 특정 XML 스키마(XSD)를 준수해야 하는 클래스를 만드는 경우 적절한 특성을 적용하고 해당 **DataType** 속성을 원하는 XML 데이터 형식 이름으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-215">Similarly, if you are creating a class that must conform to a specific XML Schema (XSD), you should apply the appropriate attribute and set its **DataType** property to the desired XML data type name.</span></span>

<span data-ttu-id="ad2f3-216">형식 매핑의 전체 목록에 대해서는 다음 특성 클래스에 대한 **DataType** 속성을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad2f3-216">For a complete list of type mappings, see the **DataType** property for any of the following attribute classes:</span></span>

- <xref:System.Xml.Serialization.SoapAttributeAttribute>

- <xref:System.Xml.Serialization.SoapElementAttribute>

- <xref:System.Xml.Serialization.XmlArrayItemAttribute>

- <xref:System.Xml.Serialization.XmlAttributeAttribute>

- <xref:System.Xml.Serialization.XmlElementAttribute>

- <xref:System.Xml.Serialization.XmlRootAttribute>

## <a name="see-also"></a><span data-ttu-id="ad2f3-217">참조</span><span class="sxs-lookup"><span data-stu-id="ad2f3-217">See also</span></span>

- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.IO.FileStream>
- [<span data-ttu-id="ad2f3-218">XML 및 SOAP serialization</span><span class="sxs-lookup"><span data-stu-id="ad2f3-218">XML and SOAP Serialization</span></span>](xml-and-soap-serialization.md)
- [<span data-ttu-id="ad2f3-219">이진 serialization</span><span class="sxs-lookup"><span data-stu-id="ad2f3-219">Binary Serialization</span></span>](binary-serialization.md)
- [<span data-ttu-id="ad2f3-220">serialization</span><span class="sxs-lookup"><span data-stu-id="ad2f3-220">Serialization</span></span>](index.md)
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="ad2f3-221">XML serialization 예제</span><span class="sxs-lookup"><span data-stu-id="ad2f3-221">Examples of XML Serialization</span></span>](examples-of-xml-serialization.md)
- [<span data-ttu-id="ad2f3-222">방법: 개체 직렬화</span><span class="sxs-lookup"><span data-stu-id="ad2f3-222">How to: Serialize an Object</span></span>](how-to-serialize-an-object.md)
- [<span data-ttu-id="ad2f3-223">방법: 개체 역직렬화</span><span class="sxs-lookup"><span data-stu-id="ad2f3-223">How to: Deserialize an Object</span></span>](how-to-deserialize-an-object.md)
