---
title: 제네릭의 공 분산과 반공 분산
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: b11b5fc93d9b7289e62d6abc9d3ca19027a107c5
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84287560"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="80cbd-102">제네릭의 공 분산과 반공 분산</span><span class="sxs-lookup"><span data-stu-id="80cbd-102">Covariance and Contravariance in Generics</span></span>
<span data-ttu-id="80cbd-103">공변성(Covariance)과 반공변성(Contravariance)은 원래 지정된 것보다 더 많이 파생되거나(더 구체적인) 더 적게 파생된 형식(덜 구체적인)을 사용할 수 있는 능력을 지칭하는 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="80cbd-104">제네릭 형식 매개 변수는 더욱 유연하게 제네릭 형식을 할당하고 사용할 수 있도록 공변성과 반공변성을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="80cbd-105">형식 시스템을 참조할 때 공변성, 반공변성 및 불변성의 정의는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="80cbd-106">이 예제에서는 `Base` 라는 기본 클래스와 `Derived`라는 파생 클래스가 있는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="80cbd-107">원래 지정된 것보다 더 많이 파생된 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="80cbd-108">`IEnumerable<Derived>`의 인스턴스(Visual Basic의 `IEnumerable(Of Derived)`)를 `IEnumerable<Base>` 형식의 변수에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="80cbd-109">원래 지정된 것보다 더 제네릭한(덜 파생적인) 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="80cbd-110">`Action<Base>`의 인스턴스(Visual Basic의 `Action(Of Base)`)를 `Action<Derived>` 형식의 변수에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="80cbd-111">원래 지정된 형식만 사용할 수 있다는 의미이므로, 불변하는 제네릭 형식 매개 변수는 공변성도, 반공변성도 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="80cbd-112">`List<Base>`의 인스턴스(Visual Basic의 `List(Of Base)`)를 `List<Derived>` 형식의 변수에 할당할 수 없고, 그 반대로도 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="80cbd-113">다음 코드에 표시된 것처럼, 공변 형식 매개 변수를 사용하여 일반적인 [다형성](../../csharp/programming-guide/classes-and-structs/polymorphism.md)과 매우 비슷한 할당을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="80cbd-114"><xref:System.Collections.Generic.List%601> 클래스는 <xref:System.Collections.Generic.IEnumerable%601> 인터페이스를 구현하므로 `List<Derived>` (Visual Basic의 경우`List(Of Derived)` )는 `IEnumerable<Derived>`를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="80cbd-115">나머지 작업은 공변 형식 매개 변수가 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="80cbd-116">그러나 반공변성은 직관적으로 이해하기가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="80cbd-117">다음 예제에서는 `Action<Base>` (Visual Basic의 경우`Action(Of Base)` ) 형식의 대리자를 만든 다음 이 대리자를 `Action<Derived>`형식의 변수에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="80cbd-118">이는 순서가 뒤바뀐 것처럼 보이지만 실제로는 형식이 안전한 코드로서 문제 없이 컴파일 및 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="80cbd-119">람다 식이 할당된 대리자와 일치하므로 `Base` 형식의 매개 변수 하나를 취하고 반환 값이 없는 메서드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="80cbd-120">결과로 얻은 대리자를 `Action<Derived>` 형식의 변수에 할당할 수 있습니다. `T` 대리자의 형식 매개 변수 <xref:System.Action%601> 가 반공변성을 지니기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="80cbd-121">`T` 에서 매개 변수 형식을 지정하므로 이는 형식이 안전한 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="80cbd-122">`Action<Base>` 형식의 대리자를 `Action<Derived>`형식의 대리자인 것처럼 호출하는 경우 해당 인수가 `Derived`형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="80cbd-123">메서드의 매개 변수가 `Base`형식이므로 이 인수를 내부 메서드에 항상 안전하게 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="80cbd-124">일반적으로 공변 형식 매개 변수는 대리자의 반환 형식으로 사용할 수 있으며, 반공변 형식 매개 변수는 매개 변수 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="80cbd-125">인터페이스의 경우 공변 형식 매개 변수는 인터페이스 메서드의 반환 형식으로 사용할 수 있으며, 반공변 형식 매개 변수는 인터페이스 메서드의 매개 변수 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="80cbd-126">공변성(Covariance) 및 반공변성(Contravariance)을 전체적으로 *차이*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="80cbd-127">공변 또는 반공변 여부가 표시되지 않은 제네릭 형식 매개 변수를 *고정(invariant)* 매개 변수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="80cbd-128">다음은 공용 언어 런타임의 가변성에 대한 간략한 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="80cbd-129">.NET Framework 4에서는 variant 형식 매개 변수가 제네릭 인터페이스와 제네릭 대리자 형식에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-129">In the .NET Framework 4, variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="80cbd-130">제네릭 인터페이스 또는 제네릭 대리자 형식은 공변 및 반공변 형식 매개 변수를 둘 다 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="80cbd-131">가변성은 참조 형식에만 적용되므로 variant 형식 매개 변수에 대한 값 형식을 지정하면 이 형식 매개 변수는 결과로 생성되는 형식에 대해 invariant가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="80cbd-132">대리자 결합에는 가변성이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="80cbd-133">즉, 두 대리자의 형식이 `Action<Derived>` 및 `Action<Base>` (Visual Basic의 경우`Action(Of Derived)` 및 `Action(Of Base)` )라고 할 때 결과의 형식이 안전하더라도 둘째 대리자를 첫째 대리자와 결합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="80cbd-134">가변성을 통해 둘째 대리자를 `Action<Derived>`형식의 변수에 할당할 수 있지만, 대리자를 결합하기 위해서는 해당 형식이 정확하게 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="80cbd-135">공변 형식 매개 변수가 있는 제네릭 인터페이스</span><span class="sxs-lookup"><span data-stu-id="80cbd-135">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="80cbd-136">.NET Framework 4부터는 여러 제네릭 인터페이스에 공변 형식 매개 변수가 있습니다(예: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>및 <xref:System.Linq.IGrouping%602>).</span><span class="sxs-lookup"><span data-stu-id="80cbd-136">Starting with the .NET Framework 4, several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="80cbd-137">이러한 인터페이스의 모든 형식 매개 변수는 공변성이므로, 형식 매개 변수는 멤버의 반환 형식에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-137">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="80cbd-138">다음 예제에서는 공변 형식 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-138">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="80cbd-139">이 예제에서는 두 가지 형식을 정의합니다. 그중 하나인 `Base` 에는 `PrintBases` (Visual Basic의 경우 `IEnumerable<Base>` )를 취하고 요소를 출력하는`IEnumerable(Of Base)` 라는 정적 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-139">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="80cbd-140">`Derived`는 `Base`에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-140">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="80cbd-141">이 예제에서는 빈 `List<Derived>` (Visual Basic의 경우`List(Of Derived)` )를 만든 다음 이 형식을 캐스팅하지 않은 채 `PrintBases` 에 전달하고 `IEnumerable<Base>` 형식의 변수에 할당하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-141">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="80cbd-142"><xref:System.Collections.Generic.List%601> 은 단일 공변 형식 매개 변수가 있는 <xref:System.Collections.Generic.IEnumerable%601>을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-142"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="80cbd-143">`IEnumerable<Derived>` 의 인스턴스를 `IEnumerable<Base>`대신 사용할 수 있는 것은 공변 형식 매개 변수 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-143">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="80cbd-144">반공변 제네릭 형식 매개 변수가 있는 제네릭 인터페이스</span><span class="sxs-lookup"><span data-stu-id="80cbd-144">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="80cbd-145">.NET Framework 4부터는 여러 제네릭 인터페이스에 반공변 형식 매개 변수가 있습니다(예: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> 및 <xref:System.Collections.Generic.IEqualityComparer%601>).</span><span class="sxs-lookup"><span data-stu-id="80cbd-145">Starting with the .NET Framework 4, several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="80cbd-146">이러한 인터페이스에는 반공변 형식 매개 변수만 있으므로 형식 매개 변수가 인터페이스 멤버의 매개 변수 형식으로만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-146">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="80cbd-147">다음 예제에서는 반공변 형식 매개 변수를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-147">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="80cbd-148">이 예제에서는`MustInherit` 속성을 사용하여 추상(Visual Basic의 경우 `Shape` ) `Area` 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-148">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="80cbd-149">이 예제에서는 또한 `ShapeAreaComparer` (Visual Basic의 경우 `IComparer<Shape>` )를 구현하는`IComparer(Of Shape)` 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-149">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="80cbd-150"><xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> 메서드 구현은 `Area` 속성의 값을 기반으로 하므로 `ShapeAreaComparer` 를 사용하여 `Shape` 개체를 영역별로 정렬할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-150">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="80cbd-151">`Circle` 클래스는 `Shape` 를 상속하고 `Area`를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-151">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="80cbd-152">이 예제에서는 <xref:System.Collections.Generic.SortedSet%601> (Visual Basic의 경우 `Circle` )을 받아 들이는 생성자를 사용하여 `IComparer<Circle>` 개체의`IComparer(Of Circle)` 을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-152">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="80cbd-153">하지만 이 예제에서는 `IComparer<Circle>`을 전달하는 대신 `ShapeAreaComparer` 를 구현하는 `IComparer<Shape>`개체를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-153">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="80cbd-154">이 예제에서는`Shape`제네릭 인터페이스의 형식 매개 변수가 반공변 형식이기 때문에 코드에서 더 많이 파생된 형식(`Circle`)의 비교자를 호출하더라도 더 적게 파생된 형식( <xref:System.Collections.Generic.IComparer%601> )의 비교자를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-154">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="80cbd-155">새 `Circle` 개체를 `SortedSet<Circle>`에 추가하면 기존 요소에 대해 새 요소를 비교할 때마다 `IComparer<Shape>.Compare` 개체의`IComparer(Of Shape).Compare` 메서드(Visual Basic의 경우 `ShapeAreaComparer` 메서드)가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-155">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="80cbd-156">메서드의 매개 변수 형식(`Shape`)은 전달되는 형식(`Circle`)보다 더 적게 파생되었으므로 호출에서 형식 안전성을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-156">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="80cbd-157">반공변성은 `ShapeAreaComparer` 가 `Shape`에서 파생되는 혼합된 형식 컬렉션뿐만 아니라 모든 단일 형식의 컬렉션을 정렬할 수 있게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-157">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="80cbd-158">variant 형식 매개 변수가 있는 제네릭 대리자</span><span class="sxs-lookup"><span data-stu-id="80cbd-158">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="80cbd-159">.NET Framework 4에서는 <xref:System.Func%602> 같은 `Func` 제네릭 대리자가 공변 반환 형식과 반공변 매개 변수 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-159">In the .NET Framework 4, the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="80cbd-160">`Action` 같은 <xref:System.Action%602>제네릭 대리자는 반공변 매개 변수 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-160">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="80cbd-161">즉, 더 많이 파생된 매개 변수 형식과 더 적게 파생된 반환 형식( `Func` 제네릭 대리자의 경우)이 있는 변수에 대리자를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-161">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="80cbd-162">`Func` 제네릭 대리자의 마지막 제네릭 형식 매개 변수는 대리자 시그니처에 반환 값의 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-162">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="80cbd-163">이 제네릭 형식 매개 변수는 공변(`out` 키워드)인 반면 다른 한 제네릭 형식 매개 변수는 반공변(`in` 키워드)입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-163">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="80cbd-164">다음 코드에서는 이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-164">The following code illustrates this.</span></span> <span data-ttu-id="80cbd-165">코드의 첫 부분에서는 `Base`라는 클래스, `Derived` 를 상속하는 `Base`라는 클래스 및 `static` 라는`Shared` 메서드(Visual Basic의 경우 `MyMethod`)가 있는 또 다른 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-165">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="80cbd-166">이 메서드는 `Base`의 인스턴스를 사용하고 `Derived`의 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-166">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="80cbd-167">인수가 `Derived`의 인스턴스이면 `MyMethod`에서 이 인스턴스를 반환하고, 인수가 `Base`의 인스턴스이면 `MyMethod`에서 `Derived`의 새 인스턴스를 반환합니다. 이 예제에서는 `Main()` 내에서 `Func<Base, Derived>`를 나타내고 이를 `Func(Of Base, Derived)` 변수에 저장하는 `MyMethod`(Visual Basic의 경우 `f1`)의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-167">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="80cbd-168">코드의 둘째 부분에서는 반환 형식이 공변적이기 때문에 `Func<Base, Base>` (Visual Basic의 경우`Func(Of Base, Base)` ) 형식의 변수에 대리자를 할당할 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-168">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="80cbd-169">코드의 셋째 부분에서는 매개 변수 형식이 반공변적이기 때문에 `Func<Derived, Derived>` (Visual Basic의 경우`Func(Of Derived, Derived)` ) 형식의 변수에 대리자를 할당할 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-169">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="80cbd-170">코드의 마지막 부분에서는 반공변 매개 변수 형식과 공변 반환 형식의 효과를 결합하여 `Func<Derived, Base>` (Visual Basic의 경우`Func(Of Derived, Base)` ) 형식의 변수에 대리자를 할당할 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-170">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="80cbd-171">제네릭 및 제네릭이 아닌 대리자의 가변성</span><span class="sxs-lookup"><span data-stu-id="80cbd-171">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="80cbd-172">위의 코드에서 `MyMethod` 의 시그니처는 생성된 제네릭 대리자 `Func<Base, Derived>` (Visual Basic의 경우`Func(Of Base, Derived)` )의 시그니처와 정확하게 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-172">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="80cbd-173">이 예제에서는 모든 대리자 형식이 제네릭 대리자 형식 <xref:System.Func%602>에서 생성되는 한 더 많이 파생된 매개 변수 형식과 더 적게 파생된 반환 형식이 있는 메서드 매개 변수 또는 변수에 이 제네릭 대리자를 저장할 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-173">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="80cbd-174">다음은 중요한 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-174">This is an important point.</span></span> <span data-ttu-id="80cbd-175">제네릭 대리자의 형식 매개 변수가 지니는 공변성 및 반공변성의 효과는 일반적인 대리자 바인딩이 지니는 공변성 및 반의 효과와 비슷합니다. 자세한 내용은 [대리자의 가변성(C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) 및 [대리자의 가변성(Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="80cbd-175">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="80cbd-176">그러나 대리자 바인딩의 가변성은 variant 형식 매개 변수가 있는 제네릭 대리자 형식뿐 아니라 모든 대리자 형식에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-176">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="80cbd-177">또한 대리자 바인딩이 가변성을 지니면 더 제한적인 매개 변수 형식과 덜 제한적인 반환 형식이 있는 임의의 대리자에 메서드를 바인딩할 수 있는 반면, 제네릭 대리자의 할당은 두 대리자 형식이 모두 동일한 제네릭 형식 정의에서 생성되는 경우에만 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-177">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="80cbd-178">다음 예제에서는 대리자 바인딩의 가변성과 제네릭 형식 매개 변수의 가변성이 결합된 효과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-178">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="80cbd-179">이 예제에서는 가장 적게 파생된 형식(`Type1`)부터 가장 많이 파생된 형식(`Type3`)까지 세 개의 형식을 포함하는 형식 계층을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-179">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="80cbd-180">일반적인 대리자 바인딩의 가변성은 `Type1` 의 매개 변수 형식과 `Type3` 의 반환 형식이 있는 제네릭 대리자에 `Type2` 의 매개 변수 형식과 `Type2`의 반환 형식이 있는 메서드를 바인딩하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-180">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="80cbd-181">결과로 생성된 제네릭 대리자는 제네릭 형식 매개 변수의 공 분산과 반공 분산을 사용하여 제네릭 대리자의 매개 변수 형식과 반환 형식이 각각 `Type3` 과 `Type1`인 다른 변수에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-181">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="80cbd-182">이 두 번째 할당을 수행하려면 변수 형식과 대리자 형식이 둘 다 같은 제네릭 형식 정의(이 예제의 경우 <xref:System.Func%602>)에서 생성된 것이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-182">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="80cbd-183">variant 제네릭 인터페이스 및 대리자 정의</span><span class="sxs-lookup"><span data-stu-id="80cbd-183">Defining Variant Generic Interfaces and Delegates</span></span>
 <span data-ttu-id="80cbd-184">.NET Framework 4부터는 Visual Basic과 C#에서 인터페이스와 대리자의 제네릭 형식 매개 변수를 공변 또는 반공변으로 표시하는 데 사용할 수 있는 키워드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-184">Starting with the .NET Framework 4, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="80cbd-185">.NET Framework 버전 2.0부터는 공용 언어 런타임에서 제네릭 형식 매개 변수에 대한 가변성 주석을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-185">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="80cbd-186">.NET Framework 4 이전에서는 이러한 주석이 있는 제네릭 클래스를 정의하는 유일한 방법이 MSIL(Microsoft Intermediate Language)을 사용하여 [Ilasm.exe (IL 어셈블러)](../../framework/tools/ilasm-exe-il-assembler.md)로 클래스를 컴파일하거나 동적 어셈블리에 클래스를 내보내는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-186">Prior to the .NET Framework 4, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="80cbd-187">공변 형식 매개 변수는 `out` 키워드(Visual Basic의 경우`Out` 키워드, `+` MSIL 어셈블러 [의 경우](../../framework/tools/ilasm-exe-il-assembler.md))로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-187">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="80cbd-188">공변 형식 매개 변수는 인터페이스에 속하는 메서드의 반환 값이나 대리자의 반환 형식으로 사용할 수 있지만</span><span class="sxs-lookup"><span data-stu-id="80cbd-188">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="80cbd-189">인터페이스 메서드에 대한 제네릭 형식 제약 조건으로는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-189">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="80cbd-190">인터페이스의 메서드에 제네릭 대리자 형식인 매개 변수가 있으면 인터페이스 형식의 공변 형식 매개 변수를 사용하여 대리자 형식의 반공변 형식 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-190">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="80cbd-191">반공변 형식 매개 변수는 `in` 키워드(Visual Basic의 경우`In` 키워드, `-` MSIL 어셈블러 [의 경우](../../framework/tools/ilasm-exe-il-assembler.md))로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-191">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="80cbd-192">반공변 형식 매개 변수는 인터페이스에 속하는 메서드의 매개 변수 형식이나 대리자의 매개 변수 형식으로 사용할 수 있으며</span><span class="sxs-lookup"><span data-stu-id="80cbd-192">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="80cbd-193">인터페이스 메서드의 제네릭 형식 제약 조건으로도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-193">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="80cbd-194">variant 형식 매개 변수를 사용할 수 있는 것은 인터페이스 형식과 대리자 형식뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-194">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="80cbd-195">인터페이스 형식이나 대리자 형식은 공변 및 반공변 형식 매개 변수를 둘 다 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-195">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="80cbd-196">Visual Basic과 C#에서는 공변 및 반공변 형식 매개 변수의 사용 규칙을 위반하거나 인터페이스와 대리자가 아닌 다른 형식의 형식 매개 변수에 공 분산 및 반공 분산 주석을 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-196">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="80cbd-197">[MSIL 어셈블러](../../framework/tools/ilasm-exe-il-assembler.md) 에서는 이러한 검사를 수행하지 않지만 규칙을 위반하는 형식을 로드하려고 하면 <xref:System.TypeLoadException> 이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-197">The [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="80cbd-198">자세한 내용과 예제 코드는 [제네릭 인터페이스의 가변성(C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) 및 [제네릭 인터페이스의 가변성(Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="80cbd-198">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="80cbd-199">variant 제네릭 인터페이스 및 대리자 형식의 목록</span><span class="sxs-lookup"><span data-stu-id="80cbd-199">List of Variant Generic Interface and Delegate Types</span></span>
 <span data-ttu-id="80cbd-200">.NET Framework 4에서는 다음 인터페이스 및 대리자 형식에서 공변 및/또는 반공변 형식 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="80cbd-200">In the .NET Framework 4, the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="80cbd-201">형식</span><span class="sxs-lookup"><span data-stu-id="80cbd-201">Type</span></span>|<span data-ttu-id="80cbd-202">공변 형식 매개 변수</span><span class="sxs-lookup"><span data-stu-id="80cbd-202">Covariant type parameters</span></span>|<span data-ttu-id="80cbd-203">반공변 형식 매개 변수</span><span class="sxs-lookup"><span data-stu-id="80cbd-203">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="80cbd-204"><xref:System.Action%601> - <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="80cbd-204"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="80cbd-205">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-205">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="80cbd-206">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-206">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="80cbd-207">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-207">Yes</span></span>|<span data-ttu-id="80cbd-208">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-208">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="80cbd-209">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-209">Yes</span></span>||  
|<span data-ttu-id="80cbd-210"><xref:System.Func%602> - <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="80cbd-210"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="80cbd-211">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-211">Yes</span></span>|<span data-ttu-id="80cbd-212">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-212">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="80cbd-213">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-213">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="80cbd-214">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-214">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="80cbd-215">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="80cbd-216">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-216">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="80cbd-217">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="80cbd-218">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-218">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="80cbd-219">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-219">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="80cbd-220">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="80cbd-221">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-221">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="80cbd-222">예</span><span class="sxs-lookup"><span data-stu-id="80cbd-222">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="80cbd-223">참조</span><span class="sxs-lookup"><span data-stu-id="80cbd-223">See also</span></span>

- [<span data-ttu-id="80cbd-224">공변성(Covariance) 및 반공변성(Contravariance)(C#)</span><span class="sxs-lookup"><span data-stu-id="80cbd-224">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="80cbd-225">공변성(covariance) 및 반공변성(contravariance)(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="80cbd-225">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="80cbd-226">대리자의 가변성(C#)</span><span class="sxs-lookup"><span data-stu-id="80cbd-226">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="80cbd-227">대리자의 가변성(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="80cbd-227">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
