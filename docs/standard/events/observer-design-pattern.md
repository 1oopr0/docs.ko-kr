---
title: 관찰자 디자인 패턴
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- IObserver(Of T) interface
- IObservable<T> interface
- IObserver<T> interface
- IObservable(Of T) interface
- observer design pattern [.NET Framework]
ms.assetid: 3680171f-f522-453c-aa4a-54f755a78f88
ms.openlocfilehash: 5794cd1ec9b63a6e151b35c28e09e29f86dcfac6
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84291268"
---
# <a name="observer-design-pattern"></a><span data-ttu-id="2f98e-102">관찰자 디자인 패턴</span><span class="sxs-lookup"><span data-stu-id="2f98e-102">Observer Design Pattern</span></span>

<span data-ttu-id="2f98e-103">관찰자 디자인 패턴은 구독자가 공급자에 등록하고 공급자로부터 알림을 받을 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-103">The observer design pattern enables a subscriber to register with and receive notifications from a provider.</span></span> <span data-ttu-id="2f98e-104">이는 푸시 기반 알림이 필요한 시나리오에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-104">It is suitable for any scenario that requires push-based notification.</span></span> <span data-ttu-id="2f98e-105">이 패턴은 ‘공급자’(‘주체’ 또는 ‘관찰 가능 대상’이라고도 함) 및 0개 이상의 ‘관찰자’를 정의합니다.    </span><span class="sxs-lookup"><span data-stu-id="2f98e-105">The pattern defines a *provider* (also known as a *subject* or an *observable*) and zero, one, or more *observers*.</span></span> <span data-ttu-id="2f98e-106">관찰자는 공급자에 등록하며 미리 정의된 조건, 이벤트 또는 상태 변경이 발생할 때마다 공급자가 해당 메서드 중 하나를 호출하여 자동으로 모든 관찰자에게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-106">Observers register with the provider, and whenever a predefined condition, event, or state change occurs, the provider automatically notifies all observers by calling one of their methods.</span></span> <span data-ttu-id="2f98e-107">이 메서드 호출에서 공급자는 관찰자에게 현재 상태 정보를 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-107">In this method call, the provider can also provide current state information to observers.</span></span> <span data-ttu-id="2f98e-108">.NET Framework에서는 제네릭 <xref:System.IObservable%601?displayProperty=nameWithType> 및 <xref:System.IObserver%601?displayProperty=nameWithType> 인터페이스를 구현하여 관찰자 디자인 패턴을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-108">In the .NET Framework, the observer design pattern is applied by implementing the generic <xref:System.IObservable%601?displayProperty=nameWithType> and <xref:System.IObserver%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="2f98e-109">제네릭 형식 매개 변수는 알림 정보를 제공하는 형식을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-109">The generic type parameter represents the type that provides notification information.</span></span>

## <a name="applying-the-pattern"></a><span data-ttu-id="2f98e-110">패턴 적용</span><span class="sxs-lookup"><span data-stu-id="2f98e-110">Applying the Pattern</span></span>

<span data-ttu-id="2f98e-111">관찰자 디자인 패턴은 데이터 소스(비즈니스 논리) 계층 및 사용자 인터페이스(표시) 계층과 같은 두 가지 구성 요소 또는 애플리케이션 계층의 명확한 구분을 지원하기 때문에 분산된 푸시 기반 알림에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-111">The observer design pattern is suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (business logic) layer and a user interface (display) layer.</span></span> <span data-ttu-id="2f98e-112">공급자가 콜백을 사용하여 해당 클라이언트에 현재 정보를 제공할 때마다 패턴을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-112">The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information.</span></span>

<span data-ttu-id="2f98e-113">패턴을 구현하려면 다음을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-113">Implementing the pattern requires that you provide the following:</span></span>

- <span data-ttu-id="2f98e-114">관찰자에게 알림을 전송하는 개체인 공급자 또는 주체.</span><span class="sxs-lookup"><span data-stu-id="2f98e-114">A provider or subject, which is the object that sends notifications to observers.</span></span> <span data-ttu-id="2f98e-115">공급자는 <xref:System.IObservable%601> 인터페이스를 구현하는 클래스 또는 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-115">A provider is a class or structure that implements the <xref:System.IObservable%601> interface.</span></span> <span data-ttu-id="2f98e-116">공급자는 공급자로부터 알림을 수신하려는 관찰자가 호출하는 단일 메서드 <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-116">The provider must implement a single method, <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType>, which is called by observers that wish to receive notifications from the provider.</span></span>

- <span data-ttu-id="2f98e-117">공급자로부터 알림을 수신하는 개체인 관찰자.</span><span class="sxs-lookup"><span data-stu-id="2f98e-117">An observer, which is an object that receives notifications from a provider.</span></span> <span data-ttu-id="2f98e-118">관찰자는 <xref:System.IObserver%601> 인터페이스를 구현하는 클래스 또는 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-118">An observer is a class or structure that implements the <xref:System.IObserver%601> interface.</span></span> <span data-ttu-id="2f98e-119">관찰자는 모두 공급자에 의해 호출되는 다음 세 개의 메서드를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-119">The observer must implement three methods, all of which are called by the provider:</span></span>

  - <span data-ttu-id="2f98e-120"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> - 관찰자에게 새 정보나 현재 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-120"><xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType>, which supplies the observer with new or current information.</span></span>

  - <span data-ttu-id="2f98e-121"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType> - 오류가 발생했음을 관찰자에게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-121"><xref:System.IObserver%601.OnError%2A?displayProperty=nameWithType>, which informs the observer that an error has occurred.</span></span>

  - <span data-ttu-id="2f98e-122"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> - 공급자가 알림 전송을 완료했음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-122"><xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType>, which indicates that the provider has finished sending notifications.</span></span>

- <span data-ttu-id="2f98e-123">공급자가 관찰자를 추적할 수 있게 해주는 메커니즘.</span><span class="sxs-lookup"><span data-stu-id="2f98e-123">A mechanism that allows the provider to keep track of observers.</span></span> <span data-ttu-id="2f98e-124">일반적으로 공급자는 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 개체와 같은 컨테이너 개체를 사용하여 알림을 구독한 <xref:System.IObserver%601> 구현에 대한 참조를 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-124">Typically, the provider uses a container object, such as a <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> object, to hold references to the <xref:System.IObserver%601> implementations that have subscribed to notifications.</span></span> <span data-ttu-id="2f98e-125">이 목적으로 스토리지 컨테이너를 사용하면 공급자가 0개에서 무한대 개수까지 관찰자를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-125">Using a storage container for this purpose enables the provider to handle zero to an unlimited number of observers.</span></span> <span data-ttu-id="2f98e-126">관찰자가 알림을 수신하는 순서는 정의되지 않습니다. 공급자가 임의 메서드를 사용하여 순서를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-126">The order in which observers receive notifications is not defined; the provider is free to use any method to determine the order.</span></span>

- <span data-ttu-id="2f98e-127">알림이 완료될 때 공급자가 관찰자를 제거할 수 있도록 하는 <xref:System.IDisposable> 구현.</span><span class="sxs-lookup"><span data-stu-id="2f98e-127">An <xref:System.IDisposable> implementation that enables the provider to remove observers when notification is complete.</span></span> <span data-ttu-id="2f98e-128">관찰자는 <xref:System.IObservable%601.Subscribe%2A> 메서드로부터 <xref:System.IDisposable> 구현에 대한 참조를 수신하므로 공급자가 알림 전송을 완료하기 전에 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 메서드를 호출하여 구독을 취소할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-128">Observers receive a reference to the <xref:System.IDisposable> implementation from the <xref:System.IObservable%601.Subscribe%2A> method, so they can also call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method to unsubscribe before the provider has finished sending notifications.</span></span>

- <span data-ttu-id="2f98e-129">공급자가 해당 관찰자에게 전송하는 데이터를 포함하는 개체.</span><span class="sxs-lookup"><span data-stu-id="2f98e-129">An object that contains the data that the provider sends to its observers.</span></span> <span data-ttu-id="2f98e-130">이 개체의 형식은 <xref:System.IObservable%601> 및 <xref:System.IObserver%601> 인터페이스의 제네릭 형식 매개 변수에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-130">The type of this object corresponds to the generic type parameter of the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="2f98e-131">이 개체는 <xref:System.IObservable%601> 구현과 동일할 수도 있지만 일반적으로 별도 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-131">Although this object can be the same as the <xref:System.IObservable%601> implementation, most commonly it is a separate type.</span></span>

> [!NOTE]
> <span data-ttu-id="2f98e-132">관찰자 디자인 패턴 구현 외에도 <xref:System.IObservable%601> 및 <xref:System.IObserver%601> 인터페이스를 사용하여 빌드된 라이브러리 탐색에 관심이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-132">In addition to implementing the observer design pattern, you may be interested in exploring libraries that are built using the <xref:System.IObservable%601> and <xref:System.IObserver%601> interfaces.</span></span> <span data-ttu-id="2f98e-133">예를 들어 [.NET용 사후 확장(Rx)](https://docs.microsoft.com/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103))은 비동기 프로그래밍을 지원하기 위해 일련의 확장 메서드와 LINQ 표준 시퀀스 연산자로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-133">For example, [Reactive Extensions for .NET (Rx)](https://docs.microsoft.com/previous-versions/dotnet/reactive-extensions/hh242985(v=vs.103)) consist of a set of extension methods and LINQ standard sequence operators to support asynchronous programming.</span></span>

## <a name="implementing-the-pattern"></a><span data-ttu-id="2f98e-134">패턴 구현</span><span class="sxs-lookup"><span data-stu-id="2f98e-134">Implementing the Pattern</span></span>

<span data-ttu-id="2f98e-135">다음 예제에서는 관찰자 디자인 패턴을 사용하여 공항의 수하물 찾는 곳 정보 시스템을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-135">The following example uses the observer design pattern to implement an airport baggage claim information system.</span></span> <span data-ttu-id="2f98e-136">`BaggageInfo` 클래스는 도착 항공편과 각 항공편의 수하물을 찾을 수 있는 컨베이어 벨트에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-136">A `BaggageInfo` class provides information about arriving flights and the carousels where baggage from each flight is available for pickup.</span></span> <span data-ttu-id="2f98e-137">다음 예제에서 이를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-137">It is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#1)]
[!code-vb[Conceptual.ObserverDesignPattern#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#1)]

<span data-ttu-id="2f98e-138">`BaggageHandler` 클래스는 도착 항공편 및 수하물을 찾을 수 있는 컨베이어 벨트에 대한 정보를 받아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-138">A `BaggageHandler` class is responsible for receiving information about arriving flights and baggage claim carousels.</span></span> <span data-ttu-id="2f98e-139">내부적으로 다음 두 개의 컬렉션을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-139">Internally, it maintains two collections:</span></span>

- <span data-ttu-id="2f98e-140">`observers` - 업데이트된 정보를 수신할 클라이언트 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-140">`observers` - A collection of clients that will receive updated information.</span></span>

- <span data-ttu-id="2f98e-141">`flights` - 항공편 및 할당된 컨베이어 벨트 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-141">`flights` - A collection of flights and their assigned carousels.</span></span>

<span data-ttu-id="2f98e-142">두 컬렉션 모두 `BaggageHandler` 클래스 생성자에서 인스턴스화되는 제네릭 <xref:System.Collections.Generic.List%601> 개체로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-142">Both collections are represented by generic <xref:System.Collections.Generic.List%601> objects that are instantiated in the `BaggageHandler` class constructor.</span></span> <span data-ttu-id="2f98e-143">`BaggageHandler` 클래스의 소스 코드는 다음 예제에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-143">The source code for the `BaggageHandler` class is shown in the following example.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#2)]
[!code-vb[Conceptual.ObserverDesignPattern#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#2)]

<span data-ttu-id="2f98e-144">업데이트된 정보를 수신하려는 클라이언트는 `BaggageHandler.Subscribe` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-144">Clients that wish to receive updated information call the `BaggageHandler.Subscribe` method.</span></span> <span data-ttu-id="2f98e-145">클라이언트가 이전에 알림을 구독하지 않은 경우 클라이언트의 <xref:System.IObserver%601> 구현에 대한 참조가 `observers` 컬렉션에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-145">If the client has not previously subscribed to notifications, a reference to the client's <xref:System.IObserver%601> implementation is added to the `observers` collection.</span></span>

<span data-ttu-id="2f98e-146">오버로드된 `BaggageHandler.BaggageStatus` 메서드를 호출하여 항공편의 수하물을 내리는 중인지 여부를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-146">The overloaded `BaggageHandler.BaggageStatus` method can be called to indicate that baggage from a flight either is being unloaded or is no longer being unloaded.</span></span> <span data-ttu-id="2f98e-147">내리는 중이면 메서드에 항공편 번호, 출발 공항 및 수하물을 내리는 중인 컨베이어 벨트가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-147">In the first case, the method is passed a flight number, the airport from which the flight originated, and the carousel where baggage is being unloaded.</span></span> <span data-ttu-id="2f98e-148">더 이상 내리지 않는 경우 메서드에 항공편 번호만 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-148">In the second case, the method is passed only a flight number.</span></span> <span data-ttu-id="2f98e-149">수하물을 내리는 경우 메서드는 메서드에 전달된 `BaggageInfo` 정보가 `flights` 컬렉션에 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-149">For baggage that is being unloaded, the method checks whether the `BaggageInfo` information passed to the method exists in the `flights` collection.</span></span> <span data-ttu-id="2f98e-150">그러지 않은 경우 메서드는 정보를 추가하고 각 관찰자의 `OnNext` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-150">If it does not, the method adds the information and calls each observer's `OnNext` method.</span></span> <span data-ttu-id="2f98e-151">더 이상 수하물을 내리지 않는 항공편의 경우 메서드는 항공편에 대한 정보가 `flights` 컬렉션에 저장되었는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-151">For flights whose baggage is no longer being unloaded, the method checks whether information on that flight is stored in the `flights` collection.</span></span> <span data-ttu-id="2f98e-152">저장된 경우 메서드는 각 관찰자의 `OnNext` 메서드를 호출하고 `flights` 컬렉션에서 `BaggageInfo` 개체를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-152">If it is, the method calls each observer's `OnNext` method and removes the `BaggageInfo` object from the `flights` collection.</span></span>

<span data-ttu-id="2f98e-153">그날의 마지막 항공편이 착륙하고 해당 수하물이 처리되면 `BaggageHandler.LastBaggageClaimed` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-153">When the last flight of the day has landed and its baggage has been processed, the `BaggageHandler.LastBaggageClaimed` method is called.</span></span> <span data-ttu-id="2f98e-154">이 메서드는 각 관찰자의 `OnCompleted` 메서드를 호출하여 모든 알림이 완료되었음을 나타내고 `observers` 컬렉션을 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-154">This method calls each observer's `OnCompleted` method to indicate that all notifications have completed, and then clears the `observers` collection.</span></span>

<span data-ttu-id="2f98e-155">공급자의 <xref:System.IObservable%601.Subscribe%2A> 메서드는 <xref:System.IObserver%601.OnCompleted%2A> 메서드가 호출되기 전에 관찰자가 알림 수신을 중지할 수 있도록 하는 <xref:System.IDisposable> 구현을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-155">The provider's <xref:System.IObservable%601.Subscribe%2A> method returns an <xref:System.IDisposable> implementation that enables observers to stop receiving notifications before the <xref:System.IObserver%601.OnCompleted%2A> method is called.</span></span> <span data-ttu-id="2f98e-156">`Unsubscriber(Of BaggageInfo)` 클래스의 소스 코드는 다음 예제에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-156">The source code for this `Unsubscriber(Of BaggageInfo)` class is shown in the following example.</span></span> <span data-ttu-id="2f98e-157">`BaggageHandler.Subscribe` 메서드에서 클래스가 인스턴스화되면 `observers` 컬렉션에 대한 참조 및 컬렉션에 추가된 관찰자에 대한 참조가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-157">When the class is instantiated in the `BaggageHandler.Subscribe` method, it is passed a reference to the `observers` collection and a reference to the observer that is added to the collection.</span></span> <span data-ttu-id="2f98e-158">이러한 참조는 지역 변수에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-158">These references are assigned to local variables.</span></span> <span data-ttu-id="2f98e-159">개체의 `Dispose` 메서드가 호출되면 관찰자가 `observers` 컬렉션에 여전히 있는지 여부를 확인하고, 있을 경우 관찰자를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-159">When the object's `Dispose` method is called, it checks whether the observer still exists in the `observers` collection, and, if it does, removes the observer.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/provider.cs#3)]
[!code-vb[Conceptual.ObserverDesignPattern#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/provider.vb#3)]

<span data-ttu-id="2f98e-160">다음 예제에서는 수하물 찾는 곳 정보를 표시하는 기본 클래스인 `ArrivalsMonitor`라는 <xref:System.IObserver%601> 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-160">The following example provides an <xref:System.IObserver%601> implementation named `ArrivalsMonitor`, which is a base class that displays baggage claim information.</span></span> <span data-ttu-id="2f98e-161">정보는 출발 도시 이름별 사전순으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-161">The information is displayed alphabetically, by the name of the originating city.</span></span> <span data-ttu-id="2f98e-162">`ArrivalsMonitor`의 메서드는 `overridable`(Visual Basic) 또는 `virtual`(C#)로 표시되므로 모두 파생 클래스를 통해 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-162">The methods of `ArrivalsMonitor` are marked as `overridable` (in Visual Basic) or `virtual` (in C#), so they can all be overridden by a derived class.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/observer.cs#4)]
[!code-vb[Conceptual.ObserverDesignPattern#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/observer.vb#4)]

<span data-ttu-id="2f98e-163">`ArrivalsMonitor` 클래스에는 `Subscribe` 및 `Unsubscribe` 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-163">The `ArrivalsMonitor` class includes the `Subscribe` and `Unsubscribe` methods.</span></span> <span data-ttu-id="2f98e-164">`Subscribe` 메서드를 통해 클래스는 <xref:System.IObservable%601.Subscribe%2A> 호출에서 반환된 <xref:System.IDisposable> 구현을 전용 변수에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-164">The `Subscribe` method enables the class to save the <xref:System.IDisposable> implementation returned by the call to <xref:System.IObservable%601.Subscribe%2A> to a private variable.</span></span> <span data-ttu-id="2f98e-165">`Unsubscribe` 메서드를 통해 클래스는 공급자의 <xref:System.IDisposable.Dispose%2A> 구현을 호출하여 알림 구독을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-165">The `Unsubscribe` method enables the class to unsubscribe from notifications by calling the provider's <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="2f98e-166">`ArrivalsMonitor`에서는 <xref:System.IObserver%601.OnNext%2A>, <xref:System.IObserver%601.OnError%2A> 및 <xref:System.IObserver%601.OnCompleted%2A> 메서드의 구현도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-166">`ArrivalsMonitor` also provides implementations of the <xref:System.IObserver%601.OnNext%2A>, <xref:System.IObserver%601.OnError%2A>, and <xref:System.IObserver%601.OnCompleted%2A> methods.</span></span> <span data-ttu-id="2f98e-167"><xref:System.IObserver%601.OnNext%2A> 구현에만 상당한 양의 코드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-167">Only the <xref:System.IObserver%601.OnNext%2A> implementation contains a significant amount of code.</span></span> <span data-ttu-id="2f98e-168">메서드는 도착 항공편의 출발 공항 및 수하물을 찾을 수 있는 컨베이어 벨트에 대한 정보를 유지 관리하는 private, sorted, generic <xref:System.Collections.Generic.List%601> 개체로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-168">The method works with a private, sorted, generic <xref:System.Collections.Generic.List%601> object that maintains information about the airports of origin for arriving flights and the carousels on which their baggage is available.</span></span> <span data-ttu-id="2f98e-169">`BaggageHandler` 클래스가 새 항공편 도착을 보고하면 <xref:System.IObserver%601.OnNext%2A> 메서드 구현에서 해당 항공편에 대한 정보를 목록에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-169">If the `BaggageHandler` class reports a new flight arrival, the <xref:System.IObserver%601.OnNext%2A> method implementation adds information about that flight to the list.</span></span> <span data-ttu-id="2f98e-170">`BaggageHandler` 클래스가 항공편의 수하물을 내렸다고 보고하면 <xref:System.IObserver%601.OnNext%2A> 메서드가 목록에서 해당 항공편을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-170">If the `BaggageHandler` class reports that the flight's baggage has been unloaded, the <xref:System.IObserver%601.OnNext%2A> method removes that flight from the list.</span></span> <span data-ttu-id="2f98e-171">변경될 때마다 목록이 정렬되고 콘솔에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-171">Whenever a change is made, the list is sorted and displayed to the console.</span></span>

<span data-ttu-id="2f98e-172">다음 예제에는 `BaggageHandler` 클래스를 인스턴스화하는 애플리케이션 진입점과 `ArrivalsMonitor` 클래스의 두 인스턴스가 포함되어 있으며, `BaggageHandler.BaggageStatus` 메서드를 사용하여 도착 항공편에 대한 정보를 추가하고 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-172">The following example contains the application entry point that instantiates the `BaggageHandler` class as well as two instances of the `ArrivalsMonitor` class, and uses the `BaggageHandler.BaggageStatus` method to add and remove information about arriving flights.</span></span> <span data-ttu-id="2f98e-173">각각의 경우에서 관찰자는 업데이트를 수신하고 수하물을 찾는 곳 정보를 올바르게 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-173">In each case, the observers receive updates and correctly display baggage claim information.</span></span>

[!code-csharp[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.observerdesignpattern/cs/program.cs#5)]
[!code-vb[Conceptual.ObserverDesignPattern#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.observerdesignpattern/vb/module1.vb#5)]

## <a name="related-topics"></a><span data-ttu-id="2f98e-174">관련 항목</span><span class="sxs-lookup"><span data-stu-id="2f98e-174">Related Topics</span></span>

|<span data-ttu-id="2f98e-175">제목</span><span class="sxs-lookup"><span data-stu-id="2f98e-175">Title</span></span>|<span data-ttu-id="2f98e-176">설명</span><span class="sxs-lookup"><span data-stu-id="2f98e-176">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="2f98e-177">관찰자 디자인 패턴 유용한 정보</span><span class="sxs-lookup"><span data-stu-id="2f98e-177">Observer Design Pattern Best Practices</span></span>](observer-design-pattern-best-practices.md)|<span data-ttu-id="2f98e-178">관찰자 디자인 패턴을 구현하는 애플리케이션을 개발할 때 채택할 모범 사례를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-178">Describes best practices to adopt when developing applications that implement the observer design pattern.</span></span>|
|[<span data-ttu-id="2f98e-179">방법: 공급자 구현</span><span class="sxs-lookup"><span data-stu-id="2f98e-179">How to: Implement a Provider</span></span>](how-to-implement-a-provider.md)|<span data-ttu-id="2f98e-180">온도 모니터링 애플리케이션에 대한 공급자의 단계별 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-180">Provides a step-by-step implementation of a provider for a temperature monitoring application.</span></span>|
|[<span data-ttu-id="2f98e-181">방법: 관찰자 구현</span><span class="sxs-lookup"><span data-stu-id="2f98e-181">How to: Implement an Observer</span></span>](how-to-implement-an-observer.md)|<span data-ttu-id="2f98e-182">온도 모니터링 애플리케이션에 대한 관찰자의 단계별 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2f98e-182">Provides a step-by-step implementation of an observer for a temperature monitoring application.</span></span>|
