---
title: Windows에서 관리되는 스레딩 및 관리되지 않는 스레딩
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
ms.openlocfilehash: de823297540d5ce3740a26614dbb9a82881decf3
ms.sourcegitcommit: 40de8df14289e1e05b40d6e5c1daabd3c286d70c
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/22/2020
ms.locfileid: "86924385"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="2c7c8-102">Windows에서 관리되는 스레딩 및 관리되지 않는 스레딩</span><span class="sxs-lookup"><span data-stu-id="2c7c8-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="2c7c8-103">공용 언어 런타임에 의해 만들어진 스레드 및 런타임 외부에서 만들어져 코드를 실행하기 위해 관리되는 환경에 들어가는 스레드를 비롯한 모든 스레드는 <xref:System.Threading.Thread> 클래스를 통해 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="2c7c8-104">런타임은 해당 프로세스에서 관리되는 실행 환경 내에서 코드를 실행한 적이 있는 모든 스레드를 모니터링하며,</span><span class="sxs-lookup"><span data-stu-id="2c7c8-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="2c7c8-105">다른 모든 스레드는 추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-105">It does not track any other threads.</span></span> <span data-ttu-id="2c7c8-106">스레드는 COM interop(런타임이 관리되는 개체를 관리되지 않는 환경에 COM 개체로 노출하므로), COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 함수 및 플랫폼 호출을 통해 관리되는 실행 환경에 들어갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="2c7c8-107">관리되지 않는 스레드가 COM 호출 가능 래퍼를 통해 런타임에 들어가면 시스템에서는 해당 스레드의 스레드 로컬 저장소를 확인하여 내부의 관리되는 <xref:System.Threading.Thread> 개체를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="2c7c8-108">이 개체를 찾은 경우 런타임이 이미 이 스레드에 대해 알고 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="2c7c8-109">그러나 이 개체를 찾을 수 없으면 런타임은 새 <xref:System.Threading.Thread> 개체를 빌드하여 해당 스레드의 스레드 로컬 저장소에 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="2c7c8-110">관리되는 스레딩에서 <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> 는 안정적인 관리되는 스레드 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="2c7c8-111">이는 이 값을 가져온 애플리케이션 도메인과 관계없이 스레드 수명 동안 다른 모든 스레드의 값과 충돌하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="2c7c8-112">Win32 스레딩에서 관리되는 스레딩으로 매핑</span><span class="sxs-lookup"><span data-stu-id="2c7c8-112">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="2c7c8-113">다음 테이블에는 Win32 스레딩 요소가 대략적으로 동일한 런타임 요소에 매핑되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-113">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="2c7c8-114">이 매핑은 동일한 기능을 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-114">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="2c7c8-115">예를 들어, **TerminateThread** 는 **finally** 절을 실행하거나 리소스를 해제하지 않고 방지될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-115">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="2c7c8-116">그러나 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> 는 모든 롤백 코드를 실행하고 모든 리소스를 회수하며 <xref:System.Threading.Thread.ResetAbort%2A>를 사용하여 거부될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-116">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="2c7c8-117">기능에 대해 가정하기 전에 설명서를 주의해서 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-117">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="2c7c8-118">Win32</span><span class="sxs-lookup"><span data-stu-id="2c7c8-118">In Win32</span></span>|<span data-ttu-id="2c7c8-119">공용 언어 런타임</span><span class="sxs-lookup"><span data-stu-id="2c7c8-119">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="2c7c8-120">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-120">**CreateThread**</span></span>|<span data-ttu-id="2c7c8-121">**Thread** 와 <xref:System.Threading.ThreadStart>의 조합</span><span class="sxs-lookup"><span data-stu-id="2c7c8-121">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="2c7c8-122">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-122">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-123">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-123">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-124">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-124">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-125">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-125">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-126">스레드 핸들의**WaitForSingleObject**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-126">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-127">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-127">**ExitThread**</span></span>|<span data-ttu-id="2c7c8-128">동일한 요소 없음</span><span class="sxs-lookup"><span data-stu-id="2c7c8-128">No equivalent</span></span>|  
|<span data-ttu-id="2c7c8-129">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-129">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-130">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="2c7c8-130">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-131">동일한 요소 없음</span><span class="sxs-lookup"><span data-stu-id="2c7c8-131">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-132">동일한 요소 없음</span><span class="sxs-lookup"><span data-stu-id="2c7c8-132">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="2c7c8-133">**CoInitializeEx** (OLE32.DLL)와 비슷함</span><span class="sxs-lookup"><span data-stu-id="2c7c8-133">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="2c7c8-134">관리되는 스레드 및 COM 아파트</span><span class="sxs-lookup"><span data-stu-id="2c7c8-134">Managed threads and COM apartments</span></span>

<span data-ttu-id="2c7c8-135">관리되는 스레드는 [단일 스레드](/windows/desktop/com/single-threaded-apartments) 또는 [다중 스레드](/windows/desktop/com/multithreaded-apartments) 아파트를 호스트할 것임을 나타내기 위해 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-135">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="2c7c8-136">(COM 스레딩 아키텍처에 대한 자세한 내용은 [프로세스, 스레드 및 아파트](/windows/desktop/com/processes--threads--and-apartments)를 참조하세요.) <xref:System.Threading.Thread.GetApartmentState%2A> 클래스의 <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.Threading.Thread.TrySetApartmentState%2A> 및 <xref:System.Threading.Thread> 메서드는 스레드의 아파트 상태를 반환하고 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-136">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="2c7c8-137">상태가 설정되지 않은 경우 <xref:System.Threading.Thread.GetApartmentState%2A>는 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-137">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2c7c8-138">이 속성은 스레드가 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 상태일 때만 설정될 수 있으며, 한 스레드에 대해 한 번만 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-138">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="2c7c8-139">스레드가 시작되기 전에 아파트 상태가 설정되지 않은 경우 스레드가 MTA(다중 스레드 아파트)로 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-139">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="2c7c8-140">종료자 스레드 및 <xref:System.Threading.ThreadPool> 에 의해 제어되는 모든 스레드는 MTA입니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-140">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="2c7c8-141">애플리케이션 시작 코드의 경우 아파트 상태를 제어하는 유일한 방법은 <xref:System.MTAThreadAttribute> 또는 <xref:System.STAThreadAttribute> 를 진입점 프로시저에 적용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-141">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="2c7c8-142">.NET Framework 1.0 및 1.1에서는 <xref:System.Threading.Thread.ApartmentState%2A> 속성을 코드의 첫 번째 줄로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-142">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="2c7c8-143">.NET Framework 2.0에서는 이러한 설정이 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-143">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="2c7c8-144">COM에 노출된 관리되는 개체는 자유 스레드된 마샬러를 집계한 것처럼 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-144">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="2c7c8-145">즉, 모든 COM 아파트에서 자유 스레드 방식으로 이러한 개체를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-145">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="2c7c8-146">이 자유 스레드 동작을 노출하지 않는 관리되는 개체만이 <xref:System.EnterpriseServices.ServicedComponent> 또는 <xref:System.Runtime.InteropServices.StandardOleMarshalObject>에서 파생되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-146">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="2c7c8-147">관리되는 세계에는 컨텍스트 및 컨텍스트 바인딩된 관리되는 인스턴스를 사용하지 않는 한 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>에 대한 지원이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-147">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="2c7c8-148">엔터프라이즈 서비스를 사용 중인 경우 개체는 <xref:System.EnterpriseServices.ServicedComponent>(이 자체는 <xref:System.ContextBoundObject>에서 파생됨)에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-148">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="2c7c8-149">관리 코드가 COM 개체를 호출할 때는 항상 COM 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-149">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="2c7c8-150">즉, 관리 코드는 OLE32에서 지시하는 대로 COM 아파트 프록시 및 COM+ 1.0 컨텍스트 래퍼를 통해 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-150">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="2c7c8-151">차단 문제</span><span class="sxs-lookup"><span data-stu-id="2c7c8-151">Blocking issues</span></span>  

<span data-ttu-id="2c7c8-152">스레드가 비관리 코드에서 스레드를 차단한 운영 체제에 대해 관리되지 않는 호출을 수행할 경우 런타임이 <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> 또는 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>에 대해 스레드를 제어하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-152">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2c7c8-153"><xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>의 경우 런타임은 스레드에 **Abort** 를 표시하고 스레드가 관리 코드에 다시 들어가면 스레드를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-153">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="2c7c8-154">관리되지 않는 차단이 아니라 관리되는 차단을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-154">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="2c7c8-155"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>등은 모두 <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>에 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-155"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2c7c8-156">또한 스레드가 단일 스레드 아파트에 있는 경우 이러한 모든 관리되는 차단 작업은 스레드가 차단되어 있는 동안 올바르게 아파트에 메시지를 펌핑합니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-156">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="2c7c8-157">스레드 및 파이버</span><span class="sxs-lookup"><span data-stu-id="2c7c8-157">Threads and fibers</span></span>

<span data-ttu-id="2c7c8-158">.NET 스레딩 모델은 [파이버](/windows/desktop/procthread/fibers)를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-158">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="2c7c8-159">파이버를 사용하여 구현된 관리되지 않는 함수를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-159">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="2c7c8-160">이러한 호출로 인해 .NET 런타임에서 크래시가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c7c8-160">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="2c7c8-161">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2c7c8-161">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
