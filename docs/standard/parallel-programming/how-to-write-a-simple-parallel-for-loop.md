---
title: '방법: 간단한 Parallel.For 루프 작성'
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Parallel.For, How to Write
- for loop, parallel construction in .NET
- parallel for loops, how to use
ms.assetid: 9029ba7f-a9d1-4526-8c84-c88716dba5d4
ms.openlocfilehash: b18e110b86389dd5d28bbc370e207aaaf7571aaf
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290735"
---
# <a name="how-to-write-a-simple-parallelfor-loop"></a><span data-ttu-id="dc907-102">방법: 간단한 Parallel.For 루프 작성</span><span class="sxs-lookup"><span data-stu-id="dc907-102">How to: Write a Simple Parallel.For Loop</span></span>

<span data-ttu-id="dc907-103">이 항목에는 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드를 설명하는 두 가지 예제가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-103">This topic contains two examples that illustrate the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dc907-104">첫 번째 예제에서는 <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> 메서드 오버로드를 사용하고, 두 번째 예제에서는 <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> 오버로드를 사용합니다. <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드의 가장 간단한 오버로드 중 두 개입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-104">The first uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> method overload, and the second uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> overload, the two simplest overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dc907-105">루프를 취소하거나, 루프 반복을 중단하거나, 스레드 로컬 상태를 유지할 필요가 없는 경우 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드의 이러한 두 오버로드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-105">You can use these two overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method when you do not need to cancel the loop, break out of the loop iterations, or maintain any thread-local state.</span></span>

> [!NOTE]
> <span data-ttu-id="dc907-106">이 문서에서는 람다 식을 사용하여 TPL에 대리자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-106">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="dc907-107">C# 또는 Visual Basic의 람다 식을 잘 모르는 경우 [PLINQ 및 TPL의 람다 식](lambda-expressions-in-plinq-and-tpl.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="dc907-107">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="dc907-108">첫 번째 예제에서는 단일 디렉터리에 있는 파일의 크기를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-108">The first example calculates the size of files in a single directory.</span></span> <span data-ttu-id="dc907-109">두 번째 예제에서는 두 행렬의 곱을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-109">The second computes the product of two matrices.</span></span>

## <a name="directory-size-example"></a><span data-ttu-id="dc907-110">디렉터리 크기 예제</span><span class="sxs-lookup"><span data-stu-id="dc907-110">Directory size example</span></span>

<span data-ttu-id="dc907-111">이 예제는 디렉터리에 있는 파일의 전체 크기를 계산하는 간단한 명령줄 유틸리티입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-111">This example is a simple command-line utility that calculates the total size of files in a directory.</span></span> <span data-ttu-id="dc907-112">단일 디렉터리 경로를 인수로 요구하고 해당 디렉터리에 있는 파일 수와 전체 크기를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-112">It expects a single directory path as an argument, and reports the number and total size of the files in that directory.</span></span> <span data-ttu-id="dc907-113">디렉터리가 있는지 확인한 후 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드를 사용하여 디렉터리에 있는 파일을 열거하고 해당 파일 크기를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-113">After verifying that the directory exists, it uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to enumerate the files in the directory and determine their file sizes.</span></span> <span data-ttu-id="dc907-114">각 파일 크기가 `totalSize` 변수에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-114">Each file size is then added to the `totalSize` variable.</span></span> <span data-ttu-id="dc907-115">추가가 원자성 작업으로 수행되도록 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>를 호출하여 추가가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-115">Note that the addition is performed by calling the <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> so that the addition is performed as an atomic operation.</span></span> <span data-ttu-id="dc907-116">그렇지 않은 경우 여러 작업이 `totalSize` 변수를 동시에 업데이트하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-116">Otherwise, multiple tasks could try to update the `totalSize` variable simultaneously.</span></span>

[!code-csharp[Conceptual.Parallel.For#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.parallel.for/cs/for1.cs#1)]
[!code-vb[Conceptual.Parallel.For#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.parallel.for/vb/for1.vb#1)]

## <a name="matrix-and-stopwatch-example"></a><span data-ttu-id="dc907-117">행렬 및 스톱워치 예제</span><span class="sxs-lookup"><span data-stu-id="dc907-117">Matrix and stopwatch example</span></span>

<span data-ttu-id="dc907-118">이 예제에서는 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드를 사용하여 두 행렬의 곱을 컴퓨팅합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-118">This example uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to compute the product of two matrices.</span></span> <span data-ttu-id="dc907-119">또한 <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> 클래스를 사용하여 병렬 루프와 비병렬 루프의 성능을 비교하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-119">It also shows how to use the <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class to compare the performance of a parallel loop with a non-parallel loop.</span></span> <span data-ttu-id="dc907-120">대용량의 출력을 생성할 수 있으므로 예제에서는 출력을 파일로 리디렉션할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-120">Note that, because it can generate a large volume of output, the example allows output to be redirected to a file.</span></span>

[!code-csharp[TPL_Parallel#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_parallel/cs/simpleparallelfor.cs#01)]
[!code-vb[TPL_Parallel#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_parallel/vb/simpleparallelfor.vb#01)]

<span data-ttu-id="dc907-121">루프를 포함하여 코드를 병렬 처리하는 경우 한 가지 중요한 목표는 병렬 처리의 오버헤드가 성능 혜택보다 큰 지점까지 과도하게 병렬 처리하지 않고 최대한 많은 프로세서를 활용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-121">When parallelizing any code, including loops, one important goal is to utilize the processors as much as possible without over parallelizing to the point where the overhead for parallel processing negates any performance benefits.</span></span> <span data-ttu-id="dc907-122">이 특정 예제에서는 내부 루프에서 많은 작업이 수행되지 않으므로 외부 루프만 병렬 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-122">In this particular example, only the outer loop is parallelized because there is not very much work performed in the inner loop.</span></span> <span data-ttu-id="dc907-123">적은 작업량과 원치 않는 캐시 결과로 인해 중첩된 병렬 루프에서 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-123">The combination of a small amount of work and undesirable cache effects can result in performance degradation in nested parallel loops.</span></span> <span data-ttu-id="dc907-124">따라서 외부 루프만 병렬 처리하는 것이 대부분의 시스템에서 동시성의 이점을 극대화하는 가장 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-124">Therefore, parallelizing the outer loop only is the best way to maximize the benefits of concurrency on most systems.</span></span>

## <a name="the-delegate"></a><span data-ttu-id="dc907-125">대리자</span><span class="sxs-lookup"><span data-stu-id="dc907-125">The Delegate</span></span>

<span data-ttu-id="dc907-126">이 <xref:System.Threading.Tasks.Parallel.For%2A> 오버로드의 세 번째 매개 변수는 `Action<int>`(C#) 또는 `Action(Of Integer)`(Visual Basic) 형식의 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-126">The third parameter of this overload of <xref:System.Threading.Tasks.Parallel.For%2A> is a delegate of type `Action<int>` in C# or `Action(Of Integer)` in Visual Basic.</span></span> <span data-ttu-id="dc907-127">`Action` 대리자는 0개, 1개 또는 16개의 형식 매개 변수가 있는지에 관계없이 항상 void를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-127">An `Action` delegate, whether it has zero, one or sixteen type parameters, always returns void.</span></span> <span data-ttu-id="dc907-128">Visual Basic에서 `Action`의 동작은 `Sub`를 사용하여 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-128">In Visual Basic, the behavior of an `Action` is defined with a `Sub`.</span></span> <span data-ttu-id="dc907-129">예제에서는 람다 식을 사용하여 대리자를 만들지만 다른 방법으로도 대리자를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-129">The example uses a lambda expression to create the delegate, but you can create the delegate in other ways as well.</span></span> <span data-ttu-id="dc907-130">자세한 내용은 [PLINQ 및 TPL의 람다 식](lambda-expressions-in-plinq-and-tpl.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="dc907-130">For more information, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

## <a name="the-iteration-value"></a><span data-ttu-id="dc907-131">반복 값</span><span class="sxs-lookup"><span data-stu-id="dc907-131">The Iteration Value</span></span>

<span data-ttu-id="dc907-132">대리자는 값이 현재 반복인 단일 입력 매개 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-132">The delegate takes a single input parameter whose value is the current iteration.</span></span> <span data-ttu-id="dc907-133">이 반복 값은 런타임에서 제공되며, 해당 시작 값은 현재 스레드에서 처리 중인 소스 세그먼트(파티션)의 첫 번째 요소 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-133">This iteration value is supplied by the runtime and its starting value is the index of the first element on the segment (partition) of the source that is being processed on the current thread.</span></span>

<span data-ttu-id="dc907-134">동시성 수준보다 더 많은 제어가 필요한 경우 <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> 입력 매개 변수를 사용하는 오버로드 중 하나(예: <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType>)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-134">If you require more control over the concurrency level, use one of the overloads that takes a <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> input parameter, such as: <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType>.</span></span>

## <a name="return-value-and-exception-handling"></a><span data-ttu-id="dc907-135">반환 값 및 예외 처리</span><span class="sxs-lookup"><span data-stu-id="dc907-135">Return Value and Exception Handling</span></span>

<span data-ttu-id="dc907-136">모든 스레드가 완료되면 <xref:System.Threading.Tasks.Parallel.For%2A>에서 <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-136"><xref:System.Threading.Tasks.Parallel.For%2A> returns a <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> object when all threads have completed.</span></span> <span data-ttu-id="dc907-137">이 반환 값은 <xref:System.Threading.Tasks.ParallelLoopResult>가 완료될 때까지 실행된 마지막 반복과 같은 정보를 저장하기 때문에 루프 반복을 수동으로 중지 또는 중단하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-137">This return value is useful when you are stopping or breaking loop iteration manually, because the <xref:System.Threading.Tasks.ParallelLoopResult> stores information such as the last iteration that ran to completion.</span></span> <span data-ttu-id="dc907-138">스레드 중 하나에서 하나 이상의 예외가 발생하는 경우 <xref:System.AggregateException?displayProperty=nameWithType>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-138">If one or more exceptions occur on one of the threads, a <xref:System.AggregateException?displayProperty=nameWithType> will be thrown.</span></span>

<span data-ttu-id="dc907-139">이 예제의 코드에서는 <xref:System.Threading.Tasks.Parallel.For%2A>의 반환 값이 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-139">In the code in this example, the return value of <xref:System.Threading.Tasks.Parallel.For%2A> is not used.</span></span>

## <a name="analysis-and-performance"></a><span data-ttu-id="dc907-140">분석 및 성능</span><span class="sxs-lookup"><span data-stu-id="dc907-140">Analysis and Performance</span></span>

<span data-ttu-id="dc907-141">성능 마법사를 사용하여 컴퓨터의 CPU 사용량을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-141">You can use the Performance Wizard to view CPU usage on your computer.</span></span> <span data-ttu-id="dc907-142">실험적으로 행렬의 열과 행 수를 늘려봅니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-142">As an experiment, increase the number of columns and rows in the matrices.</span></span> <span data-ttu-id="dc907-143">행렬이 클수록 병렬 및 순차적 계산 버전 간의 성능 차이가 커집니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-143">The larger the matrices, the greater the performance difference between the parallel and sequential versions of the computation.</span></span> <span data-ttu-id="dc907-144">행렬이 작으면 병렬 루프를 설정하는 오버헤드 때문에 순차적 버전이 더 빨리 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-144">When the matrix is small, the sequential version will run faster because of the overhead in setting up the parallel loop.</span></span>

<span data-ttu-id="dc907-145">콘솔 또는 파일 시스템과 같은 공유 리소스에 대한 동기 호출은 병렬 루프의 성능을 상당히 저하시킵니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-145">Synchronous calls to shared resources, like the Console or the File System, will significantly degrade the performance of a parallel loop.</span></span> <span data-ttu-id="dc907-146">성능을 측정하는 경우 루프 내에서 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>과 같은 호출을 사용하지 않도록 하세요.</span><span class="sxs-lookup"><span data-stu-id="dc907-146">When measuring performance, try to avoid calls such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> within the loop.</span></span>

## <a name="compile-the-code"></a><span data-ttu-id="dc907-147">코드 컴파일</span><span class="sxs-lookup"><span data-stu-id="dc907-147">Compile the Code</span></span>

<span data-ttu-id="dc907-148">이 코드를 복사하여 Visual Studio 프로젝트에 붙여넣습니다.</span><span class="sxs-lookup"><span data-stu-id="dc907-148">Copy and paste this code into a Visual Studio project.</span></span>

## <a name="see-also"></a><span data-ttu-id="dc907-149">참고 항목</span><span class="sxs-lookup"><span data-stu-id="dc907-149">See also</span></span>

- <xref:System.Threading.Tasks.Parallel.For%2A>
- <xref:System.Threading.Tasks.Parallel.ForEach%2A>
- [<span data-ttu-id="dc907-150">데이터 병렬 처리</span><span class="sxs-lookup"><span data-stu-id="dc907-150">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)
- [<span data-ttu-id="dc907-151">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="dc907-151">Parallel Programming</span></span>](index.md)
