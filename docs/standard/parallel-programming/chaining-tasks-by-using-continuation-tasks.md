---
title: 연속 작업을 사용하여 작업 연결
description: .NET에서 연속 작업을 사용하여 작업을 연결하는 방법을 알아봅니다. 연속 작업은 다른 작업에서 호출하는 비동기 작업입니다.
ms.date: 02/11/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
ms.openlocfilehash: 90317f3db5bcf2371494e14a1ca1dd16d049e0bd
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662474"
---
# <a name="chaining-tasks-by-using-continuation-tasks"></a><span data-ttu-id="a20b1-104">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="a20b1-104">Chaining Tasks by Using Continuation Tasks</span></span>
<span data-ttu-id="a20b1-105">비동기 프로그래밍에서는 한 비동기 작업이 완료 시 두 번째 작업을 호출하고 해당 작업에 데이터를 전달하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-105">In asynchronous programming, it is common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.</span></span> <span data-ttu-id="a20b1-106">일반적으로 연속 작업은 콜백 메서드를 통해 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-106">Traditionally, continuations have been done by using callback methods.</span></span> <span data-ttu-id="a20b1-107">작업 병렬 라이브러리에서는 *연속 작업*이 동일한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-107">In the Task Parallel Library, the same functionality is provided by *continuation tasks*.</span></span> <span data-ttu-id="a20b1-108">연속 작업(연속이라고도 함)은 선행 작업이 완료될 때 다른 작업( *선행*이라고 함)이 호출하는 비동기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-108">A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent finishes.</span></span>  
  
 <span data-ttu-id="a20b1-109">연속은 비교적 사용이 용이하지만 강력하고 유연합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-109">Continuations are relatively easy to use, but are nevertheless powerful and flexible.</span></span> <span data-ttu-id="a20b1-110">예를 들어 다음 작업을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-110">For example, you can:</span></span>  
  
- <span data-ttu-id="a20b1-111">선행 작업의 데이터를 연속 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-111">Pass data from the antecedent to the continuation.</span></span>  
  
- <span data-ttu-id="a20b1-112">연속 작업이 호출되거나 호출되지 않는 정확한 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-112">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>  
  
- <span data-ttu-id="a20b1-113">시작되기 전이나 실행 중일 때 함께 연속 작업을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-113">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>  
  
- <span data-ttu-id="a20b1-114">연속 작업을 예약하는 방법에 대한 힌트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-114">Provide hints about how the continuation should be scheduled.</span></span>  
  
- <span data-ttu-id="a20b1-115">동일한 선행 작업에서 여러 개의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-115">Invoke multiple continuations from the same antecedent.</span></span>  
  
- <span data-ttu-id="a20b1-116">여러 선행 작업 중 하나 또는 모두가 완료되면 하나의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-116">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>  
  
- <span data-ttu-id="a20b1-117">연속 작업을 임의 길이까지 차례로 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-117">Chain continuations one after another to any arbitrary length.</span></span>  
  
- <span data-ttu-id="a20b1-118">연속 작업을 사용하여 선행 작업에서 발생한 예외를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-118">Use a continuation to handle exceptions thrown by the antecedent.</span></span>  
  
## <a name="about-continuations"></a><span data-ttu-id="a20b1-119">연속 작업 정보</span><span class="sxs-lookup"><span data-stu-id="a20b1-119">About continuations</span></span>  
 <span data-ttu-id="a20b1-120">연속 작업은 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 상태로 만들어지는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-120">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="a20b1-121">선행 작업이 완료되면 자동으로 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-121">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="a20b1-122">사용자 코드에서 연속 작업에 대해 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 를 호출하면 <xref:System.InvalidOperationException?displayProperty=nameWithType> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-122">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>  
  
 <span data-ttu-id="a20b1-123">연속 작업 자체는 <xref:System.Threading.Tasks.Task> 이며 작업이 시작된 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-123">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="a20b1-124">연속 작업이 완료될 때까지 차단하려면 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-124">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>  
  
## <a name="creating-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="a20b1-125">단일 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="a20b1-125">Creating a continuation for a single antecedent</span></span>  
 <span data-ttu-id="a20b1-126"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업이 완료되었을 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-126">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a20b1-127">다음 예제에서는 기본 패턴을 보여줍니다(이해하기 쉽도록 예외 처리는 생략됨).</span><span class="sxs-lookup"><span data-stu-id="a20b1-127">The following example shows the basic pattern (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="a20b1-128">현재 요일의 이름을 나타내는 `taskA`개체를 반환하는 선행 작업 <xref:System.DayOfWeek> 를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-128">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="a20b1-129">선행 작업이 완료되면 연속 작업 `continuation`에 선행 작업이 전달되고 해당 결과를 포함하는 문자열을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-129">When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result.</span></span>

> [!NOTE]
> <span data-ttu-id="a20b1-130">이 문서의 C# 샘플은 `Main` 메서드에서 `async` 한정자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-130">The C# samples in this article make use of the `async` modifier on the `Main` method.</span></span> <span data-ttu-id="a20b1-131">해당 기능은 C# 7.1 이상에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-131">That feature is available in C# 7.1 and later.</span></span> <span data-ttu-id="a20b1-132">이전 버전은 이 샘플 코드를 컴파일하는 경우 [`CS5001`](../../csharp/misc/cs5001.md)을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-132">Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code.</span></span> <span data-ttu-id="a20b1-133">언어 버전을 C# 7.1 이상으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-133">You'll need to set the language version to C# 7.1 or newer.</span></span> <span data-ttu-id="a20b1-134">[언어 버전 구성](../../csharp/language-reference/configure-language-version.md)에 관한 문서에서 언어 버전을 구성하는 방법을 알아볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-134">You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).</span></span>
  
 [!code-csharp[TPL_Continuations#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/simple1.cs#1)]
 [!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]  
  
## <a name="creating-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="a20b1-135">여러 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="a20b1-135">Creating a continuation for multiple antecedents</span></span>  
 <span data-ttu-id="a20b1-136">작업 그룹 중 하나 또는 모두가 완료되었을 때 실행되는 연속 작업을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-136">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="a20b1-137">모든 선행 작업이 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는`Shared` ) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-137">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a20b1-138">선행 작업 중 하나가 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는`Shared` ) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-138">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a20b1-139"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 오버로드 호출은 호출 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-139">Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span>  <span data-ttu-id="a20b1-140">그러나 일반적으로는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 메서드를 제외하고 모두 호출하여 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성을 검색하므로, 호출 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-140">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>  
  
 <span data-ttu-id="a20b1-141">다음 예제에서는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 메서드를 호출하여 10개 선행 작업의 결과를 반영하는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-141">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks.</span></span> <span data-ttu-id="a20b1-142">각 선행 작업은 1에서 10까지의 인덱스 값을 제곱합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-142">Each antecedent task squares an index value that ranges from one to 10.</span></span> <span data-ttu-id="a20b1-143">선행 작업이 성공적으로 완료될 경우( <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>임) 연속 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 각 선행 작업에서 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 값의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-143">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="a20b1-144">예제에서는 값을 더하여 1과 10 사이의 모든 숫자의 제곱 합계를 컴퓨팅합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-144">The example adds them to compute the sum of squares for all numbers between one and 10.</span></span>  
  
 [!code-csharp[TPL_Continuations#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/whenall1.cs#5)]
 [!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]  
  
## <a name="continuation-options"></a><span data-ttu-id="a20b1-145">연속 옵션</span><span class="sxs-lookup"><span data-stu-id="a20b1-145">Continuation options</span></span>  
 <span data-ttu-id="a20b1-146">단일 작업 연속을 만드는 경우 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 열거형 값을 받는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 오버로드를 사용하여 연속 작업이 시작되는 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-146">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="a20b1-147">예를 들어 선행 작업이 성공적으로 완료되거나 오류 상태로 완료되는 경우에만 연속 작업이 실행되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-147">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="a20b1-148">선행 작업이 연속 작업을 호출할 준비가 되었을 때 조건이 true가 아니면 연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 바로 전환되며 그 후에 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-148">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.</span></span>  
  
 <span data-ttu-id="a20b1-149"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드 오버로드와 같은 많은 다중 작업 연속 메서드에는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 매개 변수도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-149">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="a20b1-150">그러나 모든 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형 멤버의 하위 집합만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-150">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="a20b1-151"><xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형에 해당 항목이 있는 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 값(예: <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>및 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>)을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-151">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a20b1-152">다중 작업 연속에 `NotOn` 또는 `OnlyOn` 옵션을 지정하는 경우 런타임에 <xref:System.ArgumentOutOfRangeException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-152">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>  
  
 <span data-ttu-id="a20b1-153">작업 연속 옵션에 대한 자세한 내용은 <xref:System.Threading.Tasks.TaskContinuationOptions> 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-153">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>  
  
## <a name="passing-data-to-a-continuation"></a><span data-ttu-id="a20b1-154">연속 작업에 데이터 전달</span><span class="sxs-lookup"><span data-stu-id="a20b1-154">Passing Data to a Continuation</span></span>  
 <span data-ttu-id="a20b1-155"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드는 연속 작업의 사용자 대리자에게 선행 작업에 대한 참조를 인수로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-155">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="a20b1-156">선행 작업이 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 개체이고 작업이 완료될 때까지 실행된 경우 연속 작업이 해당 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-156">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>  
  
 <span data-ttu-id="a20b1-157"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-157">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="a20b1-158">그러나 작업이 취소되거나 오류가 발생한 경우 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스하려고 하면 <xref:System.AggregateException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-158">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="a20b1-159">다음 예제와 같이 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> 옵션을 사용하여 이 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-159">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Continuations#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result1.cs#2)]
 [!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]  
  
 <span data-ttu-id="a20b1-160">선행 작업이 성공적으로 완료될 때까지 실행되지 않은 경우에도 연속 작업을 실행하려면 예외로부터 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-160">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="a20b1-161">한 가지 방법은 선행 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성을 테스트하고 상태가 <xref:System.Threading.Tasks.Task%601.Result%2A> 또는 <xref:System.Threading.Tasks.TaskStatus.Faulted> 가 아닌 경우에만 <xref:System.Threading.Tasks.TaskStatus.Canceled>속성에 액세스하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-161">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="a20b1-162">선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 검사할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-162">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="a20b1-163">자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-163">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="a20b1-164">다음 예제에서는 상태가 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 인 경우에만 선행 작업의 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>속성에 액세스하도록 이전 예제를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-164">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result2.cs#7)]
 [!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]  
  
## <a name="canceling-a-continuation"></a><span data-ttu-id="a20b1-165">연속 작업 취소</span><span class="sxs-lookup"><span data-stu-id="a20b1-165">Canceling a Continuation</span></span>  
 <span data-ttu-id="a20b1-166">다음과 같은 경우 연속 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-166">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>  
  
- <span data-ttu-id="a20b1-167">취소 요청에 대한 응답으로 <xref:System.OperationCanceledException> 예외를 발생시키는 경우.</span><span class="sxs-lookup"><span data-stu-id="a20b1-167">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="a20b1-168">모든 작업과 마찬가지로 연속 작업에 전달된 것과 동일한 토큰이 예외에 포함되어 있으면 협조적 취소의 인정으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-168">As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.</span></span>  
  
- <span data-ttu-id="a20b1-169">연속 작업에 <xref:System.Threading.CancellationToken?displayProperty=nameWithType> 속성이 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 인 `true`이 전달된 경우.</span><span class="sxs-lookup"><span data-stu-id="a20b1-169">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="a20b1-170">이 경우에는 연속 작업이 시작되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-170">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>  
  
- <span data-ttu-id="a20b1-171"><xref:System.Threading.Tasks.TaskContinuationOptions> 인수로 설정된 조건이 충족되지 않았으므로 연속 작업이 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-171">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="a20b1-172">예를 들어 선행 작업이 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 상태로 전환되는 경우 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> 옵션이 전달된 연속 작업이 실행되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-172">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="a20b1-173">작업과 해당 연속 작업이 동일한 논리 작업의 두 부분을 나타내는 경우 다음 예제와 같이 두 작업에 모두 동일한 취소 토큰을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-173">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="a20b1-174">취소 토큰은 33으로 나눌 수 있는 정수 목록을 생성하는 선행 작업으로 구성되며 연속 작업에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-174">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="a20b1-175">그런 다음 연속 작업이 목록을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-175">The continuation in turn displays the list.</span></span> <span data-ttu-id="a20b1-176">선행 작업과 연속 작업은 모두 임의 간격 동안 정기적으로 일시 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-176">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="a20b1-177">또한 <xref:System.Threading.Timer?displayProperty=nameWithType> 개체는 5초 시간 제한 간격 후에 `Elapsed` 메서드를 실행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-177">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="a20b1-178">이 예제에서는 현재 실행 중인 작업이 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드를 호출하게 하는 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-178">This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a20b1-179">선행 작업이나 해당 연속 작업이 실행 중일 때 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출할지 여부는 임의로 생성된 일시 중지 기간에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-179">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="a20b1-180">선행 작업이 취소되면 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-180">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="a20b1-181">선행 작업이 취소되지 않은 경우에도 토큰을 사용하여 연속 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-181">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>  
  
 [!code-csharp[TPL_Continuations#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation1.cs#3)]
 [!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]  
  
 <span data-ttu-id="a20b1-182">연속 작업을 만들 때 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> 옵션을 지정하면 연속 작업에 취소 토큰을 제공하지 않고 선행 작업이 취소된 경우에도 연속 작업이 실행되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-182">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="a20b1-183">다음은 간단한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-183">The following is a simple example.</span></span>  
  
 [!code-csharp[TPL_Continuations#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation2.cs#8)]
 [!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]  
  
 <span data-ttu-id="a20b1-184">연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환된 후 연속 작업에 대해 지정된 <xref:System.Threading.Tasks.TaskContinuationOptions> 에 따라 이후의 연속 작업에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-184">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>  
  
 <span data-ttu-id="a20b1-185">삭제된 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-185">Continuations that are disposed will not start.</span></span>  
  
## <a name="continuations-and-child-tasks"></a><span data-ttu-id="a20b1-186">연속 작업 및 자식 작업</span><span class="sxs-lookup"><span data-stu-id="a20b1-186">Continuations and Child Tasks</span></span>  
 <span data-ttu-id="a20b1-187">연속 작업은 선행 작업 및 연결된 모든 자식 작업이 완료될 때까지 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-187">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="a20b1-188">연속 작업은 분리된 자식 작업이 완료되기를 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-188">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="a20b1-189">다음 두 예제에서는 연속 작업을 만드는 선행 작업에 연결된 자식 작업과 분리된 자식 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-189">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="a20b1-190">다음 예제에서는 모든 자식 작업이 완료된 후에만 연속 작업이 실행되며 예제를 여러 번 실행해도 매번 동일한 출력이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-190">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="a20b1-191">기본적으로 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 기본 작업 생성 옵션이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>인 부모 작업을 만들기 때문에 예제에서는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-191">The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/attached1.cs#9)]
 [!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]  
  
 <span data-ttu-id="a20b1-192">그러나 자식 작업이 선행 작업에서 분리된 경우 자식 작업의 상태에 관계없이 선행 작업이 종료된 즉시 연속 작업이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-192">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="a20b1-193">따라서 다음 예제를 여러 번 실행하면 작업 스케줄러가 각 자식 작업을 처리한 방식에 따라 다른 출력이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-193">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>  
  
 [!code-csharp[TPL_Continuations#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/detached1.cs#10)]
 [!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]  
  
 <span data-ttu-id="a20b1-194">선행 작업의 최종 상태는 연결된 자식 작업의 최종 상태에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-194">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="a20b1-195">분리된 자식 작업의 상태는 부모에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-195">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="a20b1-196">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-196">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="associating-state-with-continuations"></a><span data-ttu-id="a20b1-197">연속 작업에 상태 연결</span><span class="sxs-lookup"><span data-stu-id="a20b1-197">Associating State with Continuations</span></span>  
 <span data-ttu-id="a20b1-198">연속 작업에 임의 상태를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-198">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="a20b1-199"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드는 각각 연속 상태를 나타내는 <xref:System.Object> 값을 받는 오버로드된 버전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-199">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="a20b1-200">나중에 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 속성을 사용하여 이 상태 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-200">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a20b1-201">값을 제공하지 않을 경우 이 상태 개체는 `null` 입니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-201">This state object is `null` if you do not provide a value.</span></span>  
  
 <span data-ttu-id="a20b1-202">연속 상태는 [APM(비동기 프로그래밍 모델)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) 을 사용하는 기존 코드를 TPL을 사용하도록 변환하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-202">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="a20b1-203">APM에서는 일반적으로 **Begin**_Method_ 메서드에 개체 상태를 제공하고 나중에 <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> 속성을 통해 해당 상태에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-203">In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a20b1-204"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드를 사용하면 APM을 사용하는 코드를 TPL을 사용하도록 변환할 때 이 상태를 보존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-204">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>  
  
 <span data-ttu-id="a20b1-205">Visual Studio 디버거에서 <xref:System.Threading.Tasks.Task> 개체로 작업하는 경우에도 연속 상태가 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-205">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="a20b1-206">예를 들어 **병렬 작업** 창의 **작업** 열에는 각 작업에 대한 상태 개체의 문자열 표현이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-206">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="a20b1-207">**병렬 작업** 창에 대한 자세한 내용은 [작업 창 사용](/visualstudio/debugger/using-the-tasks-window)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-207">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>  
  
 <span data-ttu-id="a20b1-208">다음 예제에서는 연속 상태를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-208">The following example shows how to use continuation state.</span></span> <span data-ttu-id="a20b1-209">연속 작업 체인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-209">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="a20b1-210">각 작업은 <xref:System.DateTime> 메서드의 `state` 매개 변수에 대해 현재 시간인 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-210">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="a20b1-211">각 <xref:System.DateTime> 개체는 연속 작업이 만들어진 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-211">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="a20b1-212">각 작업은 작업 완료 시간을 나타내는 두 번째 <xref:System.DateTime> 개체를 결과로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-212">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="a20b1-213">이 예제에서는 모든 작업이 완료된 후 만든 시간과 각 연속 작업의 완료 시간이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-213">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>  
  
 [!code-csharp[TPL_ContinuationState#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
## <a name="handling-exceptions-thrown-from-continuations"></a><span data-ttu-id="a20b1-214">연속 작업에서 발생한 예외 처리</span><span class="sxs-lookup"><span data-stu-id="a20b1-214">Handling Exceptions Thrown from Continuations</span></span>  
 <span data-ttu-id="a20b1-215">선행-연속 관계는 부모-자식 관계가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-215">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="a20b1-216">연속 작업에서 발생한 예외는 선행 작업으로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-216">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="a20b1-217">따라서 다른 작업에서 처리하는 것처럼 연속 작업에서 발생한 예외를 다음과 같이 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-217">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>  
  
- <span data-ttu-id="a20b1-218"><xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>또는 <xref:System.Threading.Tasks.Task.WaitAny%2A> 메서드나 해당하는 제네릭 항목을 사용하여 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-218">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="a20b1-219">다음 예제와 같이 동일한 `try` 문에서 선행 작업과 해당 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-219">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>  
  
     [!code-csharp[TPL_Continuations#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception1.cs#6)]
     [!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]  
  
- <span data-ttu-id="a20b1-220">두 번째 연속 작업을 사용하여 첫 번째 연속 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-220">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="a20b1-221">다음 예제에서는 작업이 존재하지 않는 파일을 읽으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-221">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="a20b1-222">그런 다음 연속 작업이 선행 작업의 예외 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-222">The continuation then displays information about the exception in the antecedent task.</span></span>  
  
     [!code-csharp[TPL_Continuations#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#4)]
     [!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]  
  
     <span data-ttu-id="a20b1-223"><xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> 옵션으로 실행되었기 때문에 연속 작업은 선행 작업에서 예외가 발생한 경우에만 실행되므로 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null`이 아니라고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-223">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="a20b1-224">선행 작업에 예외가 발생했는지 여부에 관계없이 연속 작업이 실행되는 경우 다음 코드 조각과 같이 예외를 처리하기 전에 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null` 이 아닌지 여부를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-224">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>  
  
     [!code-csharp[TPL_Continuations#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#11)]
     [!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]  
  
     <span data-ttu-id="a20b1-225">자세한 내용은 [예외 처리](exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-225">For more information, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>  
  
- <span data-ttu-id="a20b1-226">연속 작업이 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> 옵션으로 만든 연결된 자식 작업인 경우 다른 연결된 자식과 마찬가지로 부모가 해당 예외를 호출 스레드로 다시 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="a20b1-226">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="a20b1-227">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a20b1-227">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a20b1-228">참조</span><span class="sxs-lookup"><span data-stu-id="a20b1-228">See also</span></span>

- [<span data-ttu-id="a20b1-229">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="a20b1-229">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
