---
title: 강력한 이름의 어셈블리 만들기 및 사용
description: 이 문서에서는 .NET에서 강력한 이름으로 어셈블리에 서명하고 나중에 해당 이름으로 참조하는 프로세스를 보여 줍니다.
ms.date: 08/19/2019
helpviewer_keywords:
- strong-name bypass feature
- strong-named assemblies, about strong-named assemblies
- strong-named assemblies
- signing assemblies
- assemblies [.NET Framework], signing
- strong-named assemblies, scenarios
- assemblies [.NET Framework], strong-named
- strong-named assemblies, loading into trusted application domains
- assembly binding, strong-named
ms.assetid: ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9
ms.openlocfilehash: 79c8cf2c21210fd80392a8aacf92840c11a36e43
ms.sourcegitcommit: d6bd7903d7d46698e9d89d3725f3bb4876891aa3
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/13/2020
ms.locfileid: "83378527"
---
# <a name="create-and-use-strong-named-assemblies"></a><span data-ttu-id="0f11e-103">강력한 이름의 어셈블리 만들기 및 사용</span><span class="sxs-lookup"><span data-stu-id="0f11e-103">Create and use strong-named assemblies</span></span>

<span data-ttu-id="0f11e-104">강력한 이름은 간단한 텍스트 이름, 버전 번호 및 문화권 정보(제공되는 경우)를 포함하는 어셈블리 ID와 공개 키 및 디지털 서명으로 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-104">A strong name consists of the assembly's identity—its simple text name, version number, and culture information (if provided)—plus a public key and a digital signature.</span></span> <span data-ttu-id="0f11e-105">디지털 서명은 해당 프라이빗 키를 사용하여 어셈블리 파일에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-105">It is generated from an assembly file using the corresponding private key.</span></span> <span data-ttu-id="0f11e-106">어셈블리 파일은 어셈블리를 구성하는 모든 파일의 이름과 해시가 들어 있는 어셈블리 매니페스트를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-106">(The assembly file contains the assembly manifest, which contains the names and hashes of all the files that make up the assembly.)</span></span>

> [!WARNING]
> <span data-ttu-id="0f11e-107">강력한 이름을 보안용으로 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="0f11e-107">Do not rely on strong names for security.</span></span> <span data-ttu-id="0f11e-108">강력한 이름은 고유한 ID를 제공할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-108">They provide a unique identity only.</span></span>

<span data-ttu-id="0f11e-109">강력한 이름의 어셈블리는 다른 강력한 이름의 어셈블리에서 형식만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-109">A strong-named assembly can only use types from other strong-named assemblies.</span></span> <span data-ttu-id="0f11e-110">그러지 않으면 강력한 이름의 어셈블리 무결성이 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-110">Otherwise, the integrity of the strong-named assembly would be compromised.</span></span>

> [!NOTE]
> <span data-ttu-id="0f11e-111">.NET Core가 강력한 이름의 어셈블리를 지원하고 .NET Core 라이브러리의 모든 어셈블리는 서명되어 있지만 대부분의 타사 어셈블리에는 강력한 이름이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-111">Although .NET Core supports strong-named assemblies, and all assemblies in the .NET Core library are signed, the majority of third-party assemblies do not need strong names.</span></span> <span data-ttu-id="0f11e-112">자세한 내용은 GitHub의 [강력한 이름 서명](https://github.com/dotnet/runtime/blob/master/docs/project/strong-name-signing.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f11e-112">For more information, see [Strong Name Signing](https://github.com/dotnet/runtime/blob/master/docs/project/strong-name-signing.md) on GitHub.</span></span>

## <a name="strong-name-scenario"></a><span data-ttu-id="0f11e-113">강력한 이름 시나리오</span><span class="sxs-lookup"><span data-stu-id="0f11e-113">Strong name scenario</span></span>

<span data-ttu-id="0f11e-114">다음 시나리오에서는 강력한 이름이 있는 어셈블리에 서명하고 나중에 이 이름을 사용하여 해당 어셈블리를 참조하는 과정에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-114">The following scenario outlines the process of signing an assembly with a strong name and later referencing it by that name.</span></span>

1. <span data-ttu-id="0f11e-115">다음 방법 중 하나를 사용하여 강력한 이름의 어셈블리 A를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-115">Assembly A is created with a strong name using one of the following methods:</span></span>

    - <span data-ttu-id="0f11e-116">강력한 이름 만들기를 지원하는 개발 환경(예: Visual Studio)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-116">Using a development environment that supports creating strong names, such as Visual Studio.</span></span>

    - <span data-ttu-id="0f11e-117">[Sn.exe(강력한 이름 도구)](../../framework/tools/sn-exe-strong-name-tool.md)를 사용하여 암호화 키 쌍을 만들고 명령줄 컴파일러 또는 [Al.exe(어셈블리 링커)](../../framework/tools/al-exe-assembly-linker.md)를 사용하여 해당 키 쌍을 어셈블리에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-117">Creating a cryptographic key pair using the [Strong Name tool (Sn.exe)](../../framework/tools/sn-exe-strong-name-tool.md) and assigning that key pair to the assembly using either a command-line compiler or the [Assembly Linker (Al.exe)](../../framework/tools/al-exe-assembly-linker.md).</span></span> <span data-ttu-id="0f11e-118">Windows SDK는 Sn.exe와 Al.exe를 모두 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-118">The Windows SDK provides both Sn.exe and Al.exe.</span></span>

2. <span data-ttu-id="0f11e-119">개발 환경 또는 도구에서는 개발자 프라이빗 키를 사용하여 어셈블리 매니페스트가 포함된 파일의 해시에 서명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-119">The development environment or tool signs the hash of the file containing the assembly's manifest with the developer's private key.</span></span> <span data-ttu-id="0f11e-120">이 디지털 서명은 어셈블리 A의 매니페스트가 포함된 PE(이식 가능한 실행) 파일에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-120">This digital signature is stored in the portable executable (PE) file that contains Assembly A's manifest.</span></span>

3. <span data-ttu-id="0f11e-121">어셈블리 B는 어셈블리 A의 소비자입니다. 어셈블리 B의 매니페스트에 있는 참조 섹션에는 어셈블리 A의 공개 키를 나타내는 토큰이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-121">Assembly B is a consumer of Assembly A. The reference section of Assembly B's manifest includes a token that represents Assembly A's public key.</span></span> <span data-ttu-id="0f11e-122">토큰은 전체 공개 키의 일부이며, 공간을 절약하기 위해 키 자체 대신 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-122">A token is a portion of the full public key and is used rather than the key itself to save space.</span></span>

4. <span data-ttu-id="0f11e-123">어셈블리가 전역 어셈블리 캐시에 있는 경우 공용 언어 런타임은 강력한 이름 서명을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-123">The common language runtime verifies the strong name signature when the assembly is placed in the global assembly cache.</span></span> <span data-ttu-id="0f11e-124">런타임에 강력한 이름으로 바인딩할 때 공용 언어 런타임은 어셈블리 B의 매니페스트에 저장된 키와 어셈블리 A의 강력한 이름을 생성하는 데 사용된 키를 비교합니다. .NET Framework 보안 검사를 통과하고 바인딩에 성공하면, 어셈블리 B에서 어셈블리 A의 비트가 변조되지 않았고 실제로 어셈블리 A의 개발자가 이러한 비트를 전달했음을 보증합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-124">When binding by strong name at run time, the common language runtime compares the key stored in Assembly B's manifest with the key used to generate the strong name for Assembly A. If the .NET Framework security checks pass and the bind succeeds, Assembly B has a guarantee that Assembly A's bits have not been tampered with and that these bits actually come from the developers of Assembly A.</span></span>

> [!NOTE]
> <span data-ttu-id="0f11e-125">이 시나리오에서는 신뢰 문제를 다루지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-125">This scenario doesn't address trust issues.</span></span> <span data-ttu-id="0f11e-126">어셈블리에는 강력한 이름 외에도 전체 Microsoft Authenticode 서명이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-126">Assemblies can carry full Microsoft Authenticode signatures in addition to a strong name.</span></span> <span data-ttu-id="0f11e-127">Authenticode 서명에는 신뢰 관계를 설정하는 인증서가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-127">Authenticode signatures include a certificate that establishes trust.</span></span> <span data-ttu-id="0f11e-128">강력한 이름에는 이런 방식으로 코드에 서명하지 않아도 된다는 점에 유의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-128">It's important to note that strong names don't require code to be signed in this way.</span></span> <span data-ttu-id="0f11e-129">강력한 이름은 고유한 ID를 제공할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-129">Strong names only provide a unique identity.</span></span>

## <a name="bypass-signature-verification-of-trusted-assemblies"></a><span data-ttu-id="0f11e-130">신뢰할 수 있는 어셈블리의 시그니처 확인 건너뛰기</span><span class="sxs-lookup"><span data-stu-id="0f11e-130">Bypass signature verification of trusted assemblies</span></span>

<span data-ttu-id="0f11e-131">.NET Framework 3.5 서비스 팩 1부터, 어셈블리가 완전 신뢰 애플리케이션 도메인(예: `MyComputer` 영역의 기본 애플리케이션 도메인)에 로드될 때 강력한 이름 시그니처의 유효성을 검사하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-131">Starting with the .NET Framework 3.5 Service Pack 1, strong-name signatures are not validated when an assembly is loaded into a full-trust application domain, such as the default application domain for the `MyComputer` zone.</span></span> <span data-ttu-id="0f11e-132">이를 강력한 이름 건너뛰기 기능이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-132">This is referred to as the strong-name bypass feature.</span></span> <span data-ttu-id="0f11e-133">완전 신뢰 환경에서는 <xref:System.Security.Permissions.StrongNameIdentityPermission>에 대한 요청이 해당 서명과 관계없이 서명된 완전 신뢰 어셈블리에 대해 항상 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-133">In a full-trust environment, demands for <xref:System.Security.Permissions.StrongNameIdentityPermission> always succeed for signed, full-trust assemblies, regardless of their signature.</span></span> <span data-ttu-id="0f11e-134">강력한 이름 건너뛰기 기능을 사용하면 이러한 상황에서 완전 신뢰 어셈블리의 강력한 이름 서명을 확인하는 데 따르는 불필요한 오버헤드가 발생하지 않으므로 어셈블리가 더 빠르게 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-134">The strong-name bypass feature avoids the unnecessary overhead of strong-name signature verification of full-trust assemblies in this situation, allowing the assemblies to load faster.</span></span>

<span data-ttu-id="0f11e-135">건너뛰기 기능은 강력한 이름으로 서명되었으며 다음과 같은 특징이 있는 모든 어셈블리에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-135">The bypass feature applies to any assembly that is signed with a strong name and that has the following characteristics:</span></span>

- <span data-ttu-id="0f11e-136"><xref:System.Security.Policy.StrongName> 증명 정보 없이 완전 신뢰 가능(예: `MyComputer` 영역 증명 정보 보유)</span><span class="sxs-lookup"><span data-stu-id="0f11e-136">Fully trusted without <xref:System.Security.Policy.StrongName> evidence (for example, has `MyComputer` zone evidence).</span></span>

- <span data-ttu-id="0f11e-137">완전히 신뢰할 수 있는 <xref:System.AppDomain>에 로드됨</span><span class="sxs-lookup"><span data-stu-id="0f11e-137">Loaded into a fully trusted <xref:System.AppDomain>.</span></span>

- <span data-ttu-id="0f11e-138">해당 <xref:System.AppDomain>의 <xref:System.AppDomainSetup.ApplicationBase%2A> 속성 아래에 있는 위치에서 로드됨</span><span class="sxs-lookup"><span data-stu-id="0f11e-138">Loaded from a location under the <xref:System.AppDomainSetup.ApplicationBase%2A> property of that <xref:System.AppDomain>.</span></span>

- <span data-ttu-id="0f11e-139">서명이 연기되지 않음</span><span class="sxs-lookup"><span data-stu-id="0f11e-139">Not delay-signed.</span></span>

<span data-ttu-id="0f11e-140">개별 애플리케이션 또는 컴퓨터에 대해 이 기능을 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-140">This feature can be disabled for individual applications or for a computer.</span></span> <span data-ttu-id="0f11e-141">[방법: 강력한 이름 건너뛰기 기능 사용 안 함](disable-strong-name-bypass-feature.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0f11e-141">See [How to: Disable the strong-name bypass feature](disable-strong-name-bypass-feature.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="0f11e-142">관련 항목</span><span class="sxs-lookup"><span data-stu-id="0f11e-142">Related topics</span></span>

|<span data-ttu-id="0f11e-143">제목</span><span class="sxs-lookup"><span data-stu-id="0f11e-143">Title</span></span>|<span data-ttu-id="0f11e-144">설명</span><span class="sxs-lookup"><span data-stu-id="0f11e-144">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="0f11e-145">방법: 퍼블릭/프라이빗 키 쌍 만들기</span><span class="sxs-lookup"><span data-stu-id="0f11e-145">How to: Create a public-private key pair</span></span>](create-public-private-key-pair.md)|<span data-ttu-id="0f11e-146">어셈블리 서명을 위해 암호화 키 쌍을 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-146">Describes how to create a cryptographic key pair for signing an assembly.</span></span>|
|[<span data-ttu-id="0f11e-147">방법: 강력한 이름으로 어셈블리 서명</span><span class="sxs-lookup"><span data-stu-id="0f11e-147">How to: Sign an assembly with a strong name</span></span>](sign-strong-name.md)|<span data-ttu-id="0f11e-148">강력한 이름의 어셈블리를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-148">Describes how to create a strong-named assembly.</span></span>|
|[<span data-ttu-id="0f11e-149">향상된 강력한 이름 지정</span><span class="sxs-lookup"><span data-stu-id="0f11e-149">Enhanced strong naming</span></span>](enhanced-strong-naming.md)|<span data-ttu-id="0f11e-150">.NET Framework 4.5에서 강력한 이름에 대해 향상된 기능을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-150">Describes enhancements to strong-names in the .NET Framework 4.5.</span></span>|
|[<span data-ttu-id="0f11e-151">방법: 강력한 이름의 어셈블리 참조</span><span class="sxs-lookup"><span data-stu-id="0f11e-151">How to: Reference a strong-named assembly</span></span>](reference-strong-named.md)|<span data-ttu-id="0f11e-152">컴파일 타임 또는 런타임에 강력한 이름의 어셈블리에 있는 형식 또는 리소스를 참조하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-152">Describes how to reference types or resources in a strong-named assembly at compile time or run time.</span></span>|
|[<span data-ttu-id="0f11e-153">방법: 강력한 이름 건너뛰기 기능 사용 안 함</span><span class="sxs-lookup"><span data-stu-id="0f11e-153">How to: Disable the strong-name bypass feature</span></span>](disable-strong-name-bypass-feature.md)|<span data-ttu-id="0f11e-154">강력한 이름 서명의 유효성 검사를 건너뛰는 기능을 비활성화하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-154">Describes how to disable the feature that bypasses the validation of strong-name signatures.</span></span> <span data-ttu-id="0f11e-155">이 기능은 모든 애플리케이션 또는 특정 애플리케이션에 대해 비활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-155">This feature can be disabled for all or for specific applications.</span></span>|
|[<span data-ttu-id="0f11e-156">어셈블리 만들기</span><span class="sxs-lookup"><span data-stu-id="0f11e-156">Create assemblies</span></span>](create.md)|<span data-ttu-id="0f11e-157">단일 파일 어셈블리와 다중 파일 어셈블리에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-157">Provides an overview of single-file and multifile assemblies.</span></span>|
|[<span data-ttu-id="0f11e-158">Visual Studio에서 어셈블리 서명을 연기하는 방법</span><span class="sxs-lookup"><span data-stu-id="0f11e-158">How to delay sign an assembly in Visual Studio</span></span>](/visualstudio/ide/managing-assembly-and-manifest-signing#how-to-sign-an-assembly-in-visual-studio)|<span data-ttu-id="0f11e-159">어셈블리를 만든 후 강력한 이름의 어셈블리에 서명하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-159">Explains how to sign an assembly with a strong name after the assembly has been created.</span></span>|
|[<span data-ttu-id="0f11e-160">Sn.exe(강력한 이름 도구)</span><span class="sxs-lookup"><span data-stu-id="0f11e-160">Sn.exe (Strong Name tool)</span></span>](../../framework/tools/sn-exe-strong-name-tool.md)|<span data-ttu-id="0f11e-161">강력한 이름의 어셈블리를 만들 수 있도록 지원하는 .NET Framework에 포함된 도구에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-161">Describes the tool included in the .NET Framework that helps create assemblies with strong names.</span></span> <span data-ttu-id="0f11e-162">이 도구는 키 관리, 서명 생성 및 서명 확인을 위한 옵션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-162">This tool provides options for key management, signature generation, and signature verification.</span></span>|
|[<span data-ttu-id="0f11e-163">Al.exe(어셈블리 링커)</span><span class="sxs-lookup"><span data-stu-id="0f11e-163">Al.exe (Assembly linker)</span></span>](../../framework/tools/al-exe-assembly-linker.md)|<span data-ttu-id="0f11e-164">모듈 또는 리소스 파일에서 어셈블리 매니페스트가 있는 파일을 생성하는 .NET Framework에 포함된 도구에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0f11e-164">Describes the tool included in the .NET Framework that generates a file that has an assembly manifest from modules or resource files.</span></span>|
