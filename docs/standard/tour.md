---
title: .NET 둘러보기
description: .NET의 몇 가지 주요 기능에 대한 둘러보기입니다.
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.technology: dotnet-standard
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: a44c3692dc9ed9b3de37955191edfb279403f152
ms.sourcegitcommit: 0c3ce6d2e7586d925a30f231f32046b7b3934acb
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/08/2020
ms.locfileid: "89516023"
---
# <a name="tour-of-net"></a><span data-ttu-id="2034b-103">.NET 둘러보기</span><span class="sxs-lookup"><span data-stu-id="2034b-103">Tour of .NET</span></span>

<span data-ttu-id="2034b-104">.NET은 범용 개발 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-104">.NET is a general purpose development platform.</span></span> <span data-ttu-id="2034b-105">여러 플랫폼에서 다양한 시나리오가 가능하게 하는 다양한 프로그래밍 언어 지원, 비동기 및 동시 실행 프로그래밍 모델 및 기본 상호 운용성과 같은 여러 중요한 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-105">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="2034b-106">이 문서에서는 .NET의 몇 가지 주요 기능을 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-106">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="2034b-107">.NET의 구조와 사용 목적은 [.NET 아키텍처 구성 요소](components.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-107">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="2034b-108">코드 샘플을 실행하는 방법</span><span class="sxs-lookup"><span data-stu-id="2034b-108">How to run the code samples</span></span>

<span data-ttu-id="2034b-109">코드 샘플을 실행하기 위한 개발 환경 설정 방법은 [시작](get-started.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-109">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="2034b-110">이 페이지의 코드 샘플을 복사하여 샘플을 실행할 환경에 붙여넣으세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-110">Copy and paste code samples from this page into your environment to execute them.</span></span>

## <a name="programming-languages"></a><span data-ttu-id="2034b-111">프로그래밍 언어</span><span class="sxs-lookup"><span data-stu-id="2034b-111">Programming languages</span></span>

<span data-ttu-id="2034b-112">.NET은 여러 프로그래밍 언어를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-112">.NET supports multiple programming languages.</span></span> <span data-ttu-id="2034b-113">.NET 구현은 무엇보다 언어와 관련이 없는 런타임과 언어 상호 운용성을 지정하는 [CLI(공용 언어 인프라)](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/)를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-113">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="2034b-114">즉 어떤 .NET 언어를 선택해도 .NET에서 앱과 서비스를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-114">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="2034b-115">Microsoft에서는 C#과 F#, Visual Basic 이 세 가지 .NET 언어를 적극적으로 개발하고 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-115">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic.</span></span>

* <span data-ttu-id="2034b-116">C#은 C 스타일 언어의 표현력과 우아함은 그대로 유지하면서 간단하고 형식이 안전한 개체 지향 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-116">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="2034b-117">C나 이와 비슷한 언어에 익숙한 사용자라면 누구나 거의 문제 없이 C#을 사용할 수 있을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-117">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="2034b-118">C#에 대한 자세한 내용은 [C# 가이드](../csharp/index.yml)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-118">Check out the [C# Guide](../csharp/index.yml) to learn more about C#.</span></span>

* <span data-ttu-id="2034b-119">F#은 일반적인 개체 지향 프로그래밍과 명령형 프로그래밍을 지원하며 다양한 플랫폼에서 사용할 수 있는 함수 우선 프로그래밍 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-119">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="2034b-120">F#에 대한 자세한 내용을 보려면 [F# 가이드](../fsharp/index.yml)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-120">Check out the [F# Guide](../fsharp/index.yml) to learn more about F#.</span></span>

* <span data-ttu-id="2034b-121">Visual Basic은 .NET에서 실행되는 다양한 앱을 만들 수 있는 배우기 쉬운 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-121">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="2034b-122">.NET 언어 중에서 Visual Basic 구문이 일반적인 인간 언어와 가장 유사하여 소프트웨어를 처음 개발하는 사람도 쉽게 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-122">Among the .NET languages, the syntax of Visual Basic is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="2034b-123">자동 메모리 관리</span><span class="sxs-lookup"><span data-stu-id="2034b-123">Automatic memory management</span></span>

<span data-ttu-id="2034b-124">.NET에서는 [GC(가비지 수집)](garbage-collection/index.md)를 사용하여 프로그램의 메모리를 자동으로 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-124">.NET uses [garbage collection (GC)](garbage-collection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="2034b-125">GC는 메모리 관리를 지연하는 방식으로 작동하며 메모리를 즉각적으로 수집하기보다는 앱의 처리량을 우선합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-125">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="2034b-126">.NET GC의 자세한 내용은 [GC(가비지 수집) 기본 사항](garbage-collection/fundamentals.md)을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-126">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbage-collection/fundamentals.md).</span></span>

<span data-ttu-id="2034b-127">다음 두 줄에서는 모두 메모리를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-127">The following two lines both allocate memory:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

<span data-ttu-id="2034b-128">할당 취소는 가비지 수집기의 예약 실행을 통해 메모리를 회수할 때 자동으로 수행되기 때문에 메모리 할당을 취소하는 유사 키워드는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-128">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="2034b-129">가비지 수집기는 *메모리 안전성*을 보장해주는 서비스 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-129">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="2034b-130">프로그램이 할당된 메모리만 액세스하면 메모리가 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-130">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="2034b-131">예를 들어 런타임은 앱이 배열의 범위를 넘어 할당되지 않은 메모리를 액세스하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-131">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="2034b-132">다음 예제에서 런타임은 <xref:System.IndexOutOfRangeException> 예외를 throw하여 메모리 안전성을 강화합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-132">In the following example, the runtime throws an <xref:System.IndexOutOfRangeException> exception to enforce memory safety:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="2034b-133">관리되지 않는 리소스로 작업하기</span><span class="sxs-lookup"><span data-stu-id="2034b-133">Working with unmanaged resources</span></span>

<span data-ttu-id="2034b-134">일부 개체는 *관리되지 않는 리소스*를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-134">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="2034b-135">관리되지 않는 리소스는 .NET 런타임에서 자동 유지 관리되지 않는 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-135">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="2034b-136">예를 들어, 파일 핸들은 관리되지 않는 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-136">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="2034b-137"><xref:System.IO.FileStream> 개체는 관리되는 개체이지만, 관리되지 않는 파일 핸들을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-137">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="2034b-138"><xref:System.IO.FileStream> 사용을 마치면 파일 핸들을 릴리스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-138">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="2034b-139">.NET에서는 관리되지 않는 리소스를 참조하는 개체가 <xref:System.IDisposable> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-139">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="2034b-140">개체 사용을 마치면 관리되지 않는 모든 리소스 릴리스를 담당하는 개체의 <xref:System.IDisposable.Dispose> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-140">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="2034b-141">다음 예제와 같이 .NET 언어는 이러한 개체에 대해 편리한 [`using` 문](../csharp/language-reference/keywords/using.md)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-141">.NET languages provide a convenient [`using` statement](../csharp/language-reference/keywords/using.md) for such objects, as shown in the following example:</span></span>

[!code-csharp[UnmanagedResources](../../samples/snippets/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

<span data-ttu-id="2034b-142">`using` 블록이 완료되면 .NET 런타임은 파일 핸들을 릴리스하는 `stream` 개체의 <xref:System.IDisposable.Dispose> 메서드를 자동으로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-142">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="2034b-143">예외로 인해 블록에 대한 제어가 없어지는 경우에도 런타임은 같은 방식으로 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-143">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="2034b-144">자세한 내용은 다음 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-144">For more details, see the following topics:</span></span>

* <span data-ttu-id="2034b-145">C#의 경우 [using 문(C# 참조)](../csharp/language-reference/keywords/using-statement.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-145">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="2034b-146">F#의 경우 [리소스 관리: use 키워드](../fsharp/language-reference/resource-management-the-use-keyword.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-146">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="2034b-147">Visual Basic의 경우 [Using 문(Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-147">For Visual Basic, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="2034b-148">형식 안전성</span><span class="sxs-lookup"><span data-stu-id="2034b-148">Type safety</span></span>

<span data-ttu-id="2034b-149">개체는 특정 형식의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-149">An object is an instance of a specific type.</span></span> <span data-ttu-id="2034b-150">지정된 개체에 허용되는 유일한 작업은 해당 형식의 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-150">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="2034b-151">`Dog` 형식에는 `Jump` 및 `WagTail` 메서드가 있을 수 있지만 `SumTotal` 메서드는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-151">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="2034b-152">프로그램은 지정된 형식에 속하는 메서드만 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-152">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="2034b-153">다른 모든 호출에서는 컴파일 시간 오류 또는 런타임 예외가 발생합니다(동적 기능 또는 `object`를 사용하는 경우).</span><span class="sxs-lookup"><span data-stu-id="2034b-153">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="2034b-154">.NET 언어는 기본 및 파생 클래스의 계층 구조로 이루어진 개체 지향 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-154">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="2034b-155">.NET 런타임에서는 개체 계층 구조에 맞는 개체 캐스트 및 호출만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-155">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="2034b-156">.NET 언어에서 정의된 모든 형식은 기본 <xref:System.Object> 형식에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-156">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

<span data-ttu-id="2034b-157">또한 형식 안전성은 접근자 키워드의 충실도를 보장하여 캡슐화 적용을 지원하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-157">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="2034b-158">접근자 키워드는 다른 코드에서 지정된 형식의 멤버에 대한 액세스를 제어하는 아티팩트입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-158">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="2034b-159">일반적으로 형식 내에서 해당 동작을 관리하는 데 사용하는 다양한 종류의 데이터에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-159">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

<span data-ttu-id="2034b-160">C#, Visual Basic 및 F# 지원 로컬 *형식 유추*.</span><span class="sxs-lookup"><span data-stu-id="2034b-160">C#, Visual Basic, and F# support local *type inference*.</span></span> <span data-ttu-id="2034b-161">형식 유추는 컴파일러가 오른쪽에 있는 식에서 왼쪽에 있는 식의 형식을 유추함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-161">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="2034b-162">형식 안전성이 손상되거나 무시되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-162">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="2034b-163">결과 형식은 강력한 형식이며 수반되는 모든 특성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-163">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="2034b-164">이전 예제에서 `dog`는 형식 유추를 도입하도록 다시 작성하고 나머지는 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-164">From the previous example, `dog` is rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

<span data-ttu-id="2034b-165">F#에는 C# 및 Visual Basic에 있는 메서드-지역 형식 유추보다 더 심화된 형식 유추 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-165">F# has even further type inference capabilities than the method-local type inference found in C# and Visual Basic.</span></span> <span data-ttu-id="2034b-166">자세한 내용은 [형식 유추](../fsharp/language-reference/type-inference.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-166">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="2034b-167">대리자 및 람다 식</span><span class="sxs-lookup"><span data-stu-id="2034b-167">Delegates and lambdas</span></span>

<span data-ttu-id="2034b-168">대리자는 메서드 시그니처로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-168">A delegate is represented by a method signature.</span></span> <span data-ttu-id="2034b-169">해당 시그니처가 있는 모든 메서드는 대리자에 할당할 수 있으며 대리자가 호출될 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-169">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="2034b-170">대리자는 형식이 안전하다는 점을 제외하면 C++ 함수 포인터와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-170">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="2034b-171">대리자는 CLR 형식 시스템 내에서 일종의 연결이 끊긴 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-171">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="2034b-172">일반 메서드는 클래스에 연결되고 정적 또는 인스턴스 호출 규칙을 통해서만 직접 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-172">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="2034b-173">.NET에서 대리자는 이벤트 처리기에서, 비동기 작업을 정의할 때, LINQ의 토대인 람다 식에서 일반적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-173">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="2034b-174">자세한 내용은 [대리자 및 람다 식](delegates-lambdas.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-174">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="2034b-175">제네릭</span><span class="sxs-lookup"><span data-stu-id="2034b-175">Generics</span></span>

<span data-ttu-id="2034b-176">제네릭은 프로그래머가 해당 클래스를 디자인할 때 *형식 매개 변수*를 도입할 수 있게 합니다. 이렇게 하면 클라이언트 코드(형식의 사용자)에서 형식 매개 변수 대신 사용할 형식을 정확하게 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-176">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="2034b-177">제네릭은 프로그래머가 제네릭 데이터 구조를 구현할 수 있도록 돕기 위해 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-177">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="2034b-178">제네릭이 도입되기 전에는 `List` 같은 형식을 제네릭으로 만들기 위해 `object` 형식인 요소로 작업해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-178">Before their arrival, in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="2034b-179">따라서 미묘한 런타임 오류와 함께 다양한 성능 및 의미 체계 문제가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-179">This had various performance and semantic problems, along with possible subtle run-time errors.</span></span> <span data-ttu-id="2034b-180">일반적인 런타임 오류는 데이터 구조에 정수와 문자열이 둘 다 포함된 경우 및 목록 멤버를 처리하는 동안 <xref:System.InvalidCastException>에서 throw되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-180">A common run-time error is when a data structure contains, for example, both integers and strings, and an <xref:System.InvalidCastException> is thrown while processing the list's members.</span></span>

<span data-ttu-id="2034b-181">다음 샘플에서는 <xref:System.Collections.Generic.List%601> 형식 인스턴스를 사용하여 실행 중인 기본 프로그램을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-181">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

[!code-csharp[GenericsShort](../../samples/snippets/csharp/snippets/tour/GenericsShort.csx)]

<span data-ttu-id="2034b-182">자세한 내용은 [제네릭 형식(제네릭) 개요](generics.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-182">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="2034b-183">비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="2034b-183">Async programming</span></span>

<span data-ttu-id="2034b-184">비동기 프로그래밍은 런타임, 프레임워크 라이브러리 및 .NET 언어 구문의 비동기 지원을 포함하는 .NET 내의 최고급 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-184">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="2034b-185">내부적으로 운영 체제를 활용하여 I/O 바인딩된 작업을 최대한 효율적으로 수행하는 개체(예: `Task`)를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-185">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="2034b-186">.NET의 비동기 프로그래밍에 대해 자세히 알아보려면 [비동기 개요](async.md) 항목부터 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-186">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="2034b-187">LINQ(Language-Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="2034b-187">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="2034b-188">LINQ는 데이터에 적용할 간단하고 선언적인 코드를 작성할 수 있게 해주는 C# 및 Visual Basic에 대한 강력한 기능 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-188">LINQ is a powerful set of features for C# and Visual Basic that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="2034b-189">데이터는 다양한 형식(예: 메모리 내 개체, SQL 데이터베이스 또는 XML 문서)일 수 있지만 작성하는 LINQ 코드는 일반적으로 각 데이터 소스마다 다르게 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-189">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="2034b-190">자세히 알아보고 몇 가지 샘플을 확인하려면 [LINQ(Language-Integrated Query) 개요](./linq/index.md) 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-190">To learn more and see some samples, see the [LINQ (Language Integrated Query) overview](./linq/index.md) article.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="2034b-191">기본 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="2034b-191">Native interoperability</span></span>

<span data-ttu-id="2034b-192">모든 운영 체제에는 시스템 서비스를 제공하는 API(애플리케이션 프로그래밍 인터페이스)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-192">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="2034b-193">.NET은 이러한 API를 호출하는 여러 가지 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-193">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="2034b-194">기본 상호 운용성은 대체로 “플랫폼 호출” 또는 줄여서 P/Invoke를 통해 수행되며, Linux 및 Windows 플랫폼에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-194">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="2034b-195">기본 상호 운용성을 수행하는 Windows 전용 방법은 “COM interop”라고 하며, 관리 코드에서 [COM 구성 요소](/cpp/atl/introduction-to-com)로 작업하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-195">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](/cpp/atl/introduction-to-com) in managed code.</span></span> <span data-ttu-id="2034b-196">이 방법은 P/Invoke 인프라를 기반으로 하지만 약간 다른 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-196">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="2034b-197">Java 및 Objective-C에 대한 Mono(및 Xamarin)의 상호 운용성 지원은 대부분 비슷하게 작성되었습니다. 즉, 동일한 원칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-197">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="2034b-198">기본 상호 운용성에 대한 자세한 내용은 [기본 상호 운용성](native-interop/index.md) 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-198">For more information about native interoperability, see the [Native interoperability](native-interop/index.md) article.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="2034b-199">안전하지 않은 코드</span><span class="sxs-lookup"><span data-stu-id="2034b-199">Unsafe code</span></span>

<span data-ttu-id="2034b-200">언어 지원에 따라 CLR에서는 기본 메모리에 액세스하고 `unsafe` 코드를 통해 포인터 연산을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-200">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="2034b-201">이러한 작업은 특정 알고리즘 및 시스템 상호 운용성에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-201">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="2034b-202">강력하기는 하지만, 시스템 API와의 상호 운용하거나 가장 효율적인 알고리즘을 구현하는 데 필요한 경우가 아니면 안전하지 않은 코드는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-202">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="2034b-203">안전하지 않은 코드는 환경에 따라 다르게 실행될 수도 있고 가비지 수집기 및 형식 안전성의 이점을 잃을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-203">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="2034b-204">안전하지 않은 코드를 최대한 제한 및 중앙 집중화하고 해당 코드를 철저히 테스트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-204">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="2034b-205">다음 예제에서는 `StringBuilder` 클래스에서 `ToString()` 메서드의 수정된 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-205">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="2034b-206">`unsafe` 코드를 통해 메모리 청크를 직접 이동하여 알고리즘을 효율적으로 구현할 수 있는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2034b-206">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

[!code-csharp[Unsafe](../../samples/snippets/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a><span data-ttu-id="2034b-207">다음 단계</span><span class="sxs-lookup"><span data-stu-id="2034b-207">Next steps</span></span>

<span data-ttu-id="2034b-208">C# 기능을 살펴보고 싶은 경우 [C# 둘러보기](../csharp/tour-of-csharp/index.md)를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-208">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="2034b-209">F# 기능을 살펴보고 싶은 경우 [F# 둘러보기](../fsharp/tour.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-209">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="2034b-210">사용자가 직접 코드 작성을 시작하려는 경우에는 [시작](get-started.md)을 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-210">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="2034b-211">.NET의 중요한 구성 요소에 대해 알아보려면 [.NET 아키텍처 구성 요소](components.md)를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2034b-211">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>
