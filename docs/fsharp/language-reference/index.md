---
title: 언어 참조
description: 이 참조 자료에서 언어 토큰, 개념, 형식, 식 및 컴파일러 지원 구문 토픽에 대한 F# 언어 기능 정보를 찾을 수 있습니다.
ms.date: 05/16/2016
ms.openlocfilehash: 43272c6684c8fc763e8f99611901f35695f48981
ms.sourcegitcommit: c37e8d4642fef647ebab0e1c618ecc29ddfe2a0f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/06/2020
ms.locfileid: "87854960"
---
# <a name="f-language-reference"></a><span data-ttu-id="0e2e4-103">F# 언어 참조</span><span class="sxs-lookup"><span data-stu-id="0e2e4-103">F# Language Reference</span></span>

<span data-ttu-id="0e2e4-104">이 섹션에서는 .NET을 대상으로 하는 다중 패러다임 프로그래밍 언어인 F# 언어를 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-104">This section is a reference for the F# language, a multi-paradigm programming language targeting .NET.</span></span> <span data-ttu-id="0e2e4-105">F# 언어는 함수형, 개체 지향 그리고 명령형의 프로그래밍 모델을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-105">The F# language supports functional, object-oriented, and imperative programming models.</span></span>

## <a name="f-tokens"></a><span data-ttu-id="0e2e4-106">F# 토큰</span><span class="sxs-lookup"><span data-stu-id="0e2e4-106">F# Tokens</span></span>

<span data-ttu-id="0e2e4-107">다음 표에서는 F#의 토큰으로 사용되는 키워드, 기호, 리터럴의 테이블을 제공하는 참조 문서를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-107">The following table shows reference articles that provide tables of keywords, symbols, and literals that are used as tokens in F#.</span></span>

|<span data-ttu-id="0e2e4-108">제목</span><span class="sxs-lookup"><span data-stu-id="0e2e4-108">Title</span></span>|<span data-ttu-id="0e2e4-109">Description</span><span class="sxs-lookup"><span data-stu-id="0e2e4-109">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0e2e4-110">키워드 참조</span><span class="sxs-lookup"><span data-stu-id="0e2e4-110">Keyword Reference</span></span>](keyword-reference.md)|<span data-ttu-id="0e2e4-111">모든 F# 언어 키워드에 대한 정보 링크를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-111">Contains links to information about all F# language keywords.</span></span>|
|[<span data-ttu-id="0e2e4-112">기호 및 연산자 참조</span><span class="sxs-lookup"><span data-stu-id="0e2e4-112">Symbol and Operator Reference</span></span>](./symbol-and-operator-reference/index.md)|<span data-ttu-id="0e2e4-113">F# 언어에서 사용되는 기호와 연산자의 테이블을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-113">Contains a table of symbols and operators that are used in the F# language.</span></span>|
|[<span data-ttu-id="0e2e4-114">리터럴</span><span class="sxs-lookup"><span data-stu-id="0e2e4-114">Literals</span></span>](literals.md)|<span data-ttu-id="0e2e4-115">F#의 리터럴 값 구문 그리고 F# 리터럴에 대한 형식 정보를 지정하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-115">Describes the syntax for literal values in F# and how to specify type information for F# literals.</span></span>|

## <a name="f-language-concepts"></a><span data-ttu-id="0e2e4-116">F# 언어 개념</span><span class="sxs-lookup"><span data-stu-id="0e2e4-116">F# Language Concepts</span></span>

<span data-ttu-id="0e2e4-117">다음 표에서는 언어 개념을 설명하는 사용 가능한 참조 항목을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-117">The following table shows reference topics available that describe language concepts.</span></span>

|<span data-ttu-id="0e2e4-118">제목</span><span class="sxs-lookup"><span data-stu-id="0e2e4-118">Title</span></span>|<span data-ttu-id="0e2e4-119">Description</span><span class="sxs-lookup"><span data-stu-id="0e2e4-119">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0e2e4-120">함수</span><span class="sxs-lookup"><span data-stu-id="0e2e4-120">Functions</span></span>](./functions/index.md)|<span data-ttu-id="0e2e4-121">함수는 모든 프로그래밍 언어에서 프로그램 실행의 기본 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-121">Functions are the fundamental unit of program execution in any programming language.</span></span> <span data-ttu-id="0e2e4-122">다른 언어와 마찬가지로 F# 함수는 이름을 가지며, 매개 변수 및 인수를 사용할 수 있고, 본문을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-122">As in other languages, an F# function has a name, can have parameters and take arguments, and has a body.</span></span> <span data-ttu-id="0e2e4-123">또한 F#은 함수를 값으로 처리, 식에 명명되지 않은 함수 사용, 함수를 합성하여 새로운 함수 생성, 커리된 함수, 함수 인수를 부분적으로 적용하는 방식의 암시적 함수 정의 등 함수형 프로그래밍 구문도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-123">F# also supports functional programming constructs such as treating functions as values, using unnamed functions in expressions, composition of functions to form new functions, curried functions, and the implicit definition of functions by way of the partial application of function arguments.</span></span>|
|[<span data-ttu-id="0e2e4-124">F# 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-124">F# Types</span></span>](fsharp-types.md)|<span data-ttu-id="0e2e4-125">F#에 사용되는 형식 그리고 F# 형식을 명명하고 설명하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-125">Describes the types that are used in F# and how F# types are named and described.</span></span>|
|[<span data-ttu-id="0e2e4-126">형식 유추</span><span class="sxs-lookup"><span data-stu-id="0e2e4-126">Type Inference</span></span>](type-inference.md)|<span data-ttu-id="0e2e4-127">F# 컴파일러가 값, 변수, 매개 변수 및 반환 값의 형식을 유추하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-127">Describes how the F# compiler infers the types of values, variables, parameters, and return values.</span></span>|
|[<span data-ttu-id="0e2e4-128">자동 일반화</span><span class="sxs-lookup"><span data-stu-id="0e2e4-128">Automatic Generalization</span></span>](./generics/automatic-generalization.md)|<span data-ttu-id="0e2e4-129">F#의 일반 구문에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-129">Describes generic constructs in F#.</span></span>|
|[<span data-ttu-id="0e2e4-130">상속</span><span class="sxs-lookup"><span data-stu-id="0e2e4-130">Inheritance</span></span>](inheritance.md)|<span data-ttu-id="0e2e4-131">개체 지향 프로그래밍에서 "동등" 관계 또는 하위 유형을 모델링하는 데 사용되는 상속에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-131">Describes inheritance, which is used to model the "is-a" relationship, or subtyping, in object-oriented programming.</span></span>|
|[<span data-ttu-id="0e2e4-132">멤버</span><span class="sxs-lookup"><span data-stu-id="0e2e4-132">Members</span></span>](./members/index.md)|<span data-ttu-id="0e2e4-133">F# 개체 형식의 멤버에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-133">Describes members of F# object types.</span></span>|
|[<span data-ttu-id="0e2e4-134">매개 변수 및 인수</span><span class="sxs-lookup"><span data-stu-id="0e2e4-134">Parameters and Arguments</span></span>](Parameters-and-Arguments.md)|<span data-ttu-id="0e2e4-135">매개 변수를 정의하고 함수, 메서드 및 속성에 인수를 전달하기 위한 언어 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-135">Describes language support for defining parameters and passing arguments to functions, methods, and properties.</span></span> <span data-ttu-id="0e2e4-136">참조를 통한 전달 방법에 대한 자세한 내용을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-136">It includes information about how to pass by reference.</span></span>|
|[<span data-ttu-id="0e2e4-137">연산자 오버로드</span><span class="sxs-lookup"><span data-stu-id="0e2e4-137">Operator Overloading</span></span>](operator-overloading.md)|<span data-ttu-id="0e2e4-138">전역 수준에서 클래스 또는 레코드 형식에 산술 연산자를 오버로드하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-138">Describes how to overload arithmetic operators in a class or record type, and at the global level.</span></span>|
|[<span data-ttu-id="0e2e4-139">캐스팅 및 변환</span><span class="sxs-lookup"><span data-stu-id="0e2e4-139">Casting and Conversions</span></span>](casting-and-conversions.md)|<span data-ttu-id="0e2e4-140">F#의 형식 변환 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-140">Describes support for type conversions in F#.</span></span>|
|[<span data-ttu-id="0e2e4-141">Access Control</span><span class="sxs-lookup"><span data-stu-id="0e2e4-141">Access Control</span></span>](access-control.md)|<span data-ttu-id="0e2e4-142">F#의 액세스 제어에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-142">Describes access control in F#.</span></span> <span data-ttu-id="0e2e4-143">액세스 제어란 형식, 메서드, 함수 등의 특정 프로그램 요소를 사용할 수 있는 클라이언트를 선언한다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-143">Access control means declaring what clients are able to use certain program elements, such as types, methods, functions, and so on.</span></span>|
|[<span data-ttu-id="0e2e4-144">패턴 일치</span><span class="sxs-lookup"><span data-stu-id="0e2e4-144">Pattern Matching</span></span>](pattern-matching.md)|<span data-ttu-id="0e2e4-145">입력 데이터 변환에 적용되는 규칙이며 F# 언어 전체에서 사용되는 패턴을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-145">Describes patterns, which are rules for transforming input data and are used throughout the F# language.</span></span> <span data-ttu-id="0e2e4-146">데이터를 패턴과 비교하거나, 데이터를 구성 부분으로 분해하거나, 다양한 방법으로 데이터에서 정보를 추출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-146">You can compare data with a pattern, decompose data into constituent parts, or extract information from data in various ways.</span></span>|
|[<span data-ttu-id="0e2e4-147">활성 패턴</span><span class="sxs-lookup"><span data-stu-id="0e2e4-147">Active Patterns</span></span>](active-patterns.md)|<span data-ttu-id="0e2e4-148">활성 패턴에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-148">Describes active patterns.</span></span> <span data-ttu-id="0e2e4-149">활성 패턴을 사용하여 입력 데이터를 분할하는 명명된 파티션을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-149">Active patterns enable you to define named partitions that subdivide input data.</span></span> <span data-ttu-id="0e2e4-150">활성 패턴을 사용하여 각 파티션에 대한 사용자 지정 방식으로 데이터를 분해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-150">You can use active patterns to decompose data in a customized manner for each partition.</span></span>|
|[<span data-ttu-id="0e2e4-151">어설션</span><span class="sxs-lookup"><span data-stu-id="0e2e4-151">Assertions</span></span>](assertions.md)|<span data-ttu-id="0e2e4-152">식을 테스트하는 데 사용할 수 있는 디버깅 기능인 `assert` 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-152">Describes the `assert` expression, which is a debugging feature that you can use to test an expression.</span></span> <span data-ttu-id="0e2e4-153">디버그 모드에서 실패 시 어설션에서 시스템 오류 대화 상자를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-153">Upon failure in Debug mode, an assertion generates a system error dialog box.</span></span>|
|[<span data-ttu-id="0e2e4-154">예외 처리</span><span class="sxs-lookup"><span data-stu-id="0e2e4-154">Exception Handling</span></span>](./exception-handling/index.md)|<span data-ttu-id="0e2e4-155">F# 언어의 예외 처리 지원에 대한 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-155">Contains information about exception handling support in the F# language.</span></span>|
|[<span data-ttu-id="0e2e4-156">attributes</span><span class="sxs-lookup"><span data-stu-id="0e2e4-156">attributes</span></span>](attributes.md)|<span data-ttu-id="0e2e4-157">프로그래밍 구문에 메타데이터를 적용할 수 있도록 지원하는 특성에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-157">Describes attributes, which enable metadata to be applied to a programming construct.</span></span>|
|[<span data-ttu-id="0e2e4-158">리소스 관리: `use` 키워드</span><span class="sxs-lookup"><span data-stu-id="0e2e4-158">Resource Management: The `use` Keyword</span></span>](resource-management-the-use-keyword.md)|<span data-ttu-id="0e2e4-159">리소스의 초기화 및 해제를 제어할 수 있는 `use` 및 `using` 키워드에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-159">Describes the keywords `use` and `using`, which can control the initialization and release of resources</span></span>|
|[<span data-ttu-id="0e2e4-160">namespaces</span><span class="sxs-lookup"><span data-stu-id="0e2e4-160">namespaces</span></span>](namespaces.md)|<span data-ttu-id="0e2e4-161">F#의 네임스페이스 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-161">Describes namespace support in F#.</span></span> <span data-ttu-id="0e2e4-162">네임스페이스를 통해 프로그램 요소의 그룹에 이름을 연결하여 관련 기능 영역으로 코드를 체계화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-162">A namespace lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of program elements.</span></span>|
|[<span data-ttu-id="0e2e4-163">모듈</span><span class="sxs-lookup"><span data-stu-id="0e2e4-163">Modules</span></span>](modules.md)|<span data-ttu-id="0e2e4-164">모듈에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-164">Describes modules.</span></span> <span data-ttu-id="0e2e4-165">F# 모듈은 F# 프로그램에서 값, 형식 및 함수 값과 같은 F# 코드의 그룹화입니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-165">An F# module is a grouping of F# code, such as values, types, and function values, in an F# program.</span></span> <span data-ttu-id="0e2e4-166">모듈로 코드를 그룹화하면 관련 코드를 함께 유지하고, 프로그램의 이름 충돌을 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-166">Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</span></span>|
|[<span data-ttu-id="0e2e4-167">가져오기 선언: `open` 키워드</span><span class="sxs-lookup"><span data-stu-id="0e2e4-167">Import Declarations: The `open` Keyword</span></span>](import-declarations-the-open-keyword.md)|<span data-ttu-id="0e2e4-168">`open`의 작동 방식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-168">Describes how `open` works.</span></span> <span data-ttu-id="0e2e4-169">가져오기 선언은 정규화된 이름을 사용하지 않고 참조할 수 있는 요소의 모듈 또는 네임스페이스를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-169">An import declaration specifies a module or namespace whose elements you can reference without using a fully qualified name.</span></span>|
|[<span data-ttu-id="0e2e4-170">시그니처</span><span class="sxs-lookup"><span data-stu-id="0e2e4-170">Signatures</span></span>](signature-files.md)|<span data-ttu-id="0e2e4-171">시그니처 및 시그니처 파일에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-171">Describes signatures and signature files.</span></span> <span data-ttu-id="0e2e4-172">서명 파일에는 형식, 네임스페이스, 모듈 등 F# 프로그램 요소 집합의 공개 서명에 대한 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-172">A signature file contains information about the public signatures of a set of F# program elements, such as types, namespaces, and modules.</span></span> <span data-ttu-id="0e2e4-173">이러한 프로그램 요소의 접근성을 지정하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-173">It can be used to specify the accessibility of these program elements.</span></span>|
|[<span data-ttu-id="0e2e4-174">XML 문서</span><span class="sxs-lookup"><span data-stu-id="0e2e4-174">XML Documentation</span></span>](xml-documentation.md)|<span data-ttu-id="0e2e4-175">삼중 슬래시 주석이라고도 하는 XML 문서 주석에 대한 설명서 파일 생성 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-175">Describes support for generating documentation files for XML doc comments, also known as triple slash comments.</span></span> <span data-ttu-id="0e2e4-176">다른 .NET 언어와 마찬가지로 F#의 코드 주석에서 문서를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-176">You can produce documentation from code comments in F# as in other .NET languages.</span></span>|
|[<span data-ttu-id="0e2e4-177">자세한 구문</span><span class="sxs-lookup"><span data-stu-id="0e2e4-177">Verbose Syntax</span></span>](verbose-syntax.md)|<span data-ttu-id="0e2e4-178">간단한 구문을 사용할 수 없는 경우의 F# 구문에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-178">Describes the syntax for F# constructs when lightweight syntax is not enabled.</span></span> <span data-ttu-id="0e2e4-179">자세한 구문은 코드 파일 맨 위에 있는 `#light "off"` 지시문으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-179">Verbose syntax is indicated by the `#light "off"` directive at the top of the code file.</span></span>|
|[<span data-ttu-id="0e2e4-180">일반 텍스트 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-180">Plain Text Formatting</span></span>](plaintext-formatting.md)|<span data-ttu-id="0e2e4-181">F# 애플리케이션 및 스크립트에서 sprintf 및 기타 일반 텍스트 형식을 사용하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-181">Learn how to use sprintf and other plain text formatting in F# applications and scripts.</span></span>|

## <a name="f-types"></a><span data-ttu-id="0e2e4-182">F# 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-182">F# Types</span></span>

<span data-ttu-id="0e2e4-183">다음 표에서는 F# 언어에서 지원하는 형식을 설명하는 사용 가능한 참조 항목을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-183">The following table shows reference topics available that describe types supported by the F# language.</span></span>

|<span data-ttu-id="0e2e4-184">제목</span><span class="sxs-lookup"><span data-stu-id="0e2e4-184">Title</span></span>|<span data-ttu-id="0e2e4-185">Description</span><span class="sxs-lookup"><span data-stu-id="0e2e4-185">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0e2e4-186">값</span><span class="sxs-lookup"><span data-stu-id="0e2e4-186">values</span></span>](./values/index.md)|<span data-ttu-id="0e2e4-187">특정 형식을 가진 변경 불가능한 수량인 값에 대해 설명합니다. 값은 정수 또는 부동 소수점 숫자, 문자 또는 텍스트, 목록, 시퀀스, 배열, 튜플, 구분된 공용 구조체, 레코드, 클래스 형식 또는 함수 값이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-187">Describes values, which are immutable quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>|
|[<span data-ttu-id="0e2e4-188">기본 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-188">Basic Types</span></span>](basic-types.md)|<span data-ttu-id="0e2e4-189">F# 언어에 사용되는 기본 형식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-189">Describes the fundamental basic types that are used in the F# language.</span></span> <span data-ttu-id="0e2e4-190">또한 각 유형의 해당 .NET 형식과 최소 및 최대값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-190">It also provides the corresponding .NET types and the minimum and maximum values for each type.</span></span>|
|[<span data-ttu-id="0e2e4-191">단위 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-191">Unit Type</span></span>](unit-type.md)|<span data-ttu-id="0e2e4-192">특정 값이 없음을 나타내는 형식인 `unit` 형식에 대해 설명합니다. `unit` 형식은 다른 값이 없거나 필요하지 않을 때 표시자 역할을 하는 단일 값만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-192">Describes the `unit` type, which is a type that indicates the absence of a specific value; the `unit` type has only a single value, which acts as a placeholder when no other value exists or is needed.</span></span>|
|[<span data-ttu-id="0e2e4-193">문자열</span><span class="sxs-lookup"><span data-stu-id="0e2e4-193">Strings</span></span>](strings.md)|<span data-ttu-id="0e2e4-194">F#의 문자열에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-194">Describes strings in F#.</span></span> <span data-ttu-id="0e2e4-195">`string` 형식은 유니코드 문자 시퀀스로 변경할 수 없는 텍스트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-195">The `string` type represents immutable text, as a sequence of Unicode characters.</span></span> <span data-ttu-id="0e2e4-196">`string`은 .NET Framework에서 `System.String`의 별칭입니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-196">`string` is an alias for `System.String` in the .NET Framework.</span></span>|
|[<span data-ttu-id="0e2e4-197">튜플</span><span class="sxs-lookup"><span data-stu-id="0e2e4-197">Tuples</span></span>](tuples.md)|<span data-ttu-id="0e2e4-198">가능한 여러 형식의 명명되지는 않았지만 순서가 지정된 값에 대한 그룹화인 튜플에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-198">Describes tuples, which are groupings of unnamed but ordered values of possibly different types.</span></span>|
|[<span data-ttu-id="0e2e4-199">F# 컬렉션 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-199">F# Collection Types</span></span>](fsharp-collection-types.md)|<span data-ttu-id="0e2e4-200">배열, 목록, 시퀀스(seq), 맵 및 집합에 대한 형식을 비롯하여 F# 함수 컬렉션 형식을 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-200">An overview of the F# functional collection types, including types for arrays, lists, sequences (seq), maps, and sets.</span></span>|
|[<span data-ttu-id="0e2e4-201">목록</span><span class="sxs-lookup"><span data-stu-id="0e2e4-201">Lists</span></span>](lists.md)|<span data-ttu-id="0e2e4-202">목록에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-202">Describes lists.</span></span> <span data-ttu-id="0e2e4-203">F#의 목록은 동일 형식의 순서가 지정되고 변경할 수 없는 일련의 모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-203">A list in F# is an ordered, immutable series of elements all of the same type.</span></span>|
|[<span data-ttu-id="0e2e4-204">Options</span><span class="sxs-lookup"><span data-stu-id="0e2e4-204">Options</span></span>](options.md)|<span data-ttu-id="0e2e4-205">옵션 형식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-205">Describes the option type.</span></span> <span data-ttu-id="0e2e4-206">F#의 옵션은 값이 있거나 없을 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-206">An option in F# is used when a value may or may not exist.</span></span> <span data-ttu-id="0e2e4-207">옵션에는 기본 형식이 있으며 해당 형식의 값을 보유하거나 값을 보유하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-207">An option has an underlying type and may either hold a value of that type or it may not have a value.</span></span>|
|[<span data-ttu-id="0e2e4-208">시퀀스</span><span class="sxs-lookup"><span data-stu-id="0e2e4-208">Sequences</span></span>](sequences.md)|<span data-ttu-id="0e2e4-209">시퀀스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-209">Describes sequences.</span></span> <span data-ttu-id="0e2e4-210">시퀀스란 한 형식을 가진 일련의 모든 논리적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-210">A sequence is a logical series of elements all of one type.</span></span> <span data-ttu-id="0e2e4-211">개별 시퀀스 요소는 필요한 경우에만 계산되므로, 표현이 리터럴 요소 개수가 나타내는 것보다 작을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-211">Individual sequence elements are only computed if necessary, so the representation may be smaller than a literal element count indicates.</span></span>|
|[<span data-ttu-id="0e2e4-212">배열</span><span class="sxs-lookup"><span data-stu-id="0e2e4-212">Arrays</span></span>](arrays.md)|<span data-ttu-id="0e2e4-213">배열에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-213">Describes arrays.</span></span> <span data-ttu-id="0e2e4-214">배열은 동일한 형식의 모든 연속 데이터 요소의 변경 가능한 시퀀스로 고정 크기이며 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-214">Arrays are fixed-size, zero-based, mutable sequences of consecutive data elements, all of the same type.</span></span>|
|[<span data-ttu-id="0e2e4-215">레코드</span><span class="sxs-lookup"><span data-stu-id="0e2e4-215">Records</span></span>](records.md)|<span data-ttu-id="0e2e4-216">레코드에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-216">Describes records.</span></span> <span data-ttu-id="0e2e4-217">레코드는 명명된 값의 간단한 집계(경우에 따라 멤버가 포함된)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-217">Records represent simple aggregates of named values, optionally with members.</span></span>|
|[<span data-ttu-id="0e2e4-218">구별된 공용 구조체</span><span class="sxs-lookup"><span data-stu-id="0e2e4-218">Discriminated Unions</span></span>](discriminated-unions.md)|<span data-ttu-id="0e2e4-219">구분된 공용 구조체에 대해 설명합니다. 구분된 공용 구조체는 다양한 명명된 사례 중 하나인 값을 지원하며, 각 사례는 서로 다른 값과 형식을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-219">Describes discriminated unions, which provide support for values that may be one of a variety of named cases, each with possibly different values and types.</span></span>|
|[<span data-ttu-id="0e2e4-220">열거형</span><span class="sxs-lookup"><span data-stu-id="0e2e4-220">Enumerations</span></span>](enumerations.md)|<span data-ttu-id="0e2e4-221">열거형은 명명된 값의 정의된 집합을 포함하는 형식이라는 것을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-221">Describes enumerations are types that have a defined set of named values.</span></span> <span data-ttu-id="0e2e4-222">코드를 더 읽기 쉽고 유지 가능하도록 만들기 위해 리터럴 대신 이를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-222">You can use them in place of literals to make code more readable and maintainable.</span></span>|
|[<span data-ttu-id="0e2e4-223">참조 셀</span><span class="sxs-lookup"><span data-stu-id="0e2e4-223">Reference Cells</span></span>](reference-cells.md)|<span data-ttu-id="0e2e4-224">참조 의미론을 통해 변경 가능한 값을 만드는 데 사용할 수 있는 스토리지 위치인 참조 셀에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-224">Describes reference cells, which are storage locations that enable you to create mutable variables with reference semantics.</span></span>|
|[<span data-ttu-id="0e2e4-225">형식 약어</span><span class="sxs-lookup"><span data-stu-id="0e2e4-225">Type Abbreviations</span></span>](type-abbreviations.md)|<span data-ttu-id="0e2e4-226">형식의 대체 이름인 형식 약어에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-226">Describes type abbreviations, which are alternate names for types.</span></span>|
|[<span data-ttu-id="0e2e4-227">클래스</span><span class="sxs-lookup"><span data-stu-id="0e2e4-227">Classes</span></span>](classes.md)|<span data-ttu-id="0e2e4-228">속성, 메서드 및 이벤트를 가질 수 있는 개체를 나타내는 형식인 클래스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-228">Describes classes, which are types that represent objects that can have properties, methods, and events.</span></span>|
|[<span data-ttu-id="0e2e4-229">구조체</span><span class="sxs-lookup"><span data-stu-id="0e2e4-229">Structures</span></span>](structures.md)|<span data-ttu-id="0e2e4-230">데이터의 양이 적고 동작이 단순한 형식에 대해 클래스보다 효율적일 수 있는 간단한 개체 형식인 구조체에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-230">Describes structures, which are compact object types that can be more efficient than a class for types that have a small amount of data and simple behavior.</span></span>|
|[<span data-ttu-id="0e2e4-231">인터페이스</span><span class="sxs-lookup"><span data-stu-id="0e2e4-231">Interfaces</span></span>](interfaces.md)|<span data-ttu-id="0e2e4-232">다른 클래스에서 구현하는 관련 멤버의 집합을 지정하는 인터페이스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-232">Describes interfaces, which specify sets of related members that other classes implement.</span></span>|
|[<span data-ttu-id="0e2e4-233">추상 클래스</span><span class="sxs-lookup"><span data-stu-id="0e2e4-233">Abstract Classes</span></span>](abstract-classes.md)|<span data-ttu-id="0e2e4-234">파생된 클래스에서 구현할 수 있도록 일부 또는 모든 멤버를 구현되지 않은 상태로 유지하는 클래스인 추상 클래스에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-234">Describes abstract classes, which are classes that leave some or all members unimplemented, so that implementations can be provided by derived classes.</span></span>|
|[<span data-ttu-id="0e2e4-235">형식 확장</span><span class="sxs-lookup"><span data-stu-id="0e2e4-235">Type Extensions</span></span>](type-extensions.md)|<span data-ttu-id="0e2e4-236">이전에 정의된 개체 형식에 새 멤버를 추가할 수 있는 형식 확장에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-236">Describes type extensions, which let you add new members to a previously defined object type.</span></span>|
|[<span data-ttu-id="0e2e4-237">유연한 형식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-237">Flexible Types</span></span>](flexible-types.md)|<span data-ttu-id="0e2e4-238">유연한 형식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-238">Describes flexible types.</span></span> <span data-ttu-id="0e2e4-239">유연한 형식 주석은 매개 변수, 변수 또는 값에 지정된 형식과 호환되는 형식을 갖고 있음을 나타냅니다. 호환성은 클래스 또는 인터페이스의 개체 지향 계층 구조에서의 위치로 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-239">A flexible type annotation is an indication that a parameter, variable, or value has a type that is compatible with type specified, where compatibility is determined by position in an object-oriented hierarchy of classes or interfaces.</span></span>|
|[<span data-ttu-id="0e2e4-240">대리자</span><span class="sxs-lookup"><span data-stu-id="0e2e4-240">Delegates</span></span>](delegates.md)|<span data-ttu-id="0e2e4-241">함수 호출을 개체로 나타내는 대리자에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-241">Describes delegates, which represent a function call as an object.</span></span>|
|[<span data-ttu-id="0e2e4-242">측정 단위</span><span class="sxs-lookup"><span data-stu-id="0e2e4-242">Units of Measure</span></span>](units-of-measure.md)|<span data-ttu-id="0e2e4-243">측정 단위에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-243">Describes units of measure.</span></span> <span data-ttu-id="0e2e4-244">F#의 부동 소수점 값은 연결된 측정 단위를 포함할 수 있으며, 측정 단위는 일반적으로 길이, 볼륨, 질량 등을 나타내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-244">Floating point values in F# can have associated units of measure, which are typically used to indicate length, volume, mass, and so on.</span></span>|
|[<span data-ttu-id="0e2e4-245">형식 공급자</span><span class="sxs-lookup"><span data-stu-id="0e2e4-245">Type Providers</span></span>](../tutorials/type-providers/index.md)|<span data-ttu-id="0e2e4-246">형식 공급자를 설명하고 기본 제공 형식 공급자를 사용하여 데이터베이스 및 웹 서비스에 액세스하는 연습 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-246">Describes type provides and provides links to walkthroughs on using the built-in type providers to access databases and web services.</span></span>|

## <a name="f-expressions"></a><span data-ttu-id="0e2e4-247">F# 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-247">F# Expressions</span></span>

<span data-ttu-id="0e2e4-248">다음 표에는 F# 식을 설명하는 항목이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-248">The following table lists topics that describe F# expressions.</span></span>

|<span data-ttu-id="0e2e4-249">제목</span><span class="sxs-lookup"><span data-stu-id="0e2e4-249">Title</span></span>|<span data-ttu-id="0e2e4-250">Description</span><span class="sxs-lookup"><span data-stu-id="0e2e4-250">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0e2e4-251">조건식: `if...then...else`</span><span class="sxs-lookup"><span data-stu-id="0e2e4-251">Conditional Expressions: `if...then...else`</span></span>](conditional-expressions-if-then-else.md)|<span data-ttu-id="0e2e4-252">코드의 다른 분기를 실행하고 지정된 부울 식에 따라 다른 값을 평가하는 `if...then...else` 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-252">Describes the `if...then...else` expression, which runs different branches of code and also evaluates to a different value depending on the Boolean expression given.</span></span>|
|[<span data-ttu-id="0e2e4-253">일치 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-253">Match Expressions</span></span>](match-expressions.md)|<span data-ttu-id="0e2e4-254">분기 제어를 제공하는 `match` 식에 대해 설명합니다. 분기 제어는 특정 패턴의 집합을 사용한 식 비교를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-254">Describes the `match` expression, which provides branching control that is based on the comparison of an expression with a set of patterns.</span></span>|
|[<span data-ttu-id="0e2e4-255">루프: `for...to` 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-255">Loops: `for...to` Expression</span></span>](loops-for-to-expression.md)|<span data-ttu-id="0e2e4-256">루프 변수 값의 범위에 대해 루프를 반복하는 데 사용되는 `for...to` 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-256">Describes the `for...to` expression, which is used to iterate in a loop over a range of values of a loop variable.</span></span>|
|[<span data-ttu-id="0e2e4-257">루프: `for...in` 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-257">Loops: `for...in` Expression</span></span>](loops-for-in-expression.md)|<span data-ttu-id="0e2e4-258">범위 식, 시퀀스, 목록, 배열, 열거형을 지원하는 기타 구문 등 열거 가능한 컬렉션에서 특정 패턴의 일치를 반복하는 데 사용되는 루프 구문인 `for...in` 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-258">Describes the `for...in` expression, a looping construct that is used to iterate over the matches of a pattern in an enumerable collection such as a range expression, sequence, list, array, or other construct that supports enumeration.</span></span>|
|[<span data-ttu-id="0e2e4-259">루프: `while...do` 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-259">Loops: `while...do` Expression</span></span>](loops-while-do-expression.md)|<span data-ttu-id="0e2e4-260">지정된 테스트 조건이 참인 동안 반복 실행(루프)을 수행하는 데 사용되는 `while...do` 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-260">Describes the `while...do` expression, which is used to perform iterative execution (looping) while a specified test condition is true.</span></span>|
|[<span data-ttu-id="0e2e4-261">개체 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-261">Object Expressions</span></span>](object-expressions.md)|<span data-ttu-id="0e2e4-262">동적으로 생성된 익명 개체 형식의 새 인스턴스를 만드는 개체 식에 대해 설명합니다. 익명 개체 형식은 기존의 기본 형식, 인터페이스 또는 인터페이스의 집합을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-262">Describes object expressions, which are expressions that create new instances of a dynamically created, anonymous object type that is based on an existing base type, interface, or set of interfaces.</span></span>|
|[<span data-ttu-id="0e2e4-263">Lazy 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-263">Lazy Expressions</span></span>](lazy-expressions.md)|<span data-ttu-id="0e2e4-264">즉시 평가되지 않는 대신 결과가 실제로 필요할 때 평가되는 계산인 지연 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-264">Describes lazy expressions, which are computations that are not evaluated immediately, but are instead evaluated when the result is actually needed.</span></span>|
|[<span data-ttu-id="0e2e4-265">계산 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-265">Computation Expressions</span></span>](computation-expressions.md)|<span data-ttu-id="0e2e4-266">제어 흐름 구문 및 바인딩을 사용하여 순차화하고 결합할 수 있는 계산을 작성하도록 간편한 구문을 제공하는 F#의 계산 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-266">Describes computation expressions in F#, which provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings.</span></span> <span data-ttu-id="0e2e4-267">함수형 프로그램에서 데이터, 컨트롤 및 부작용을 관리하는 데 사용할 수 있는 함수형 프로그래밍 기능인 *monads*에 대한 간편한 구문을 제공하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-267">They can be used to provide a convenient syntax for *monads*, a functional programming feature that can be used to manage data, control, and side effects in functional programs.</span></span> <span data-ttu-id="0e2e4-268">계산 식의 한 가지 형식인 비동기 워크플로는 비동기 및 병렬 계산을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-268">One type of computation expression, the asynchronous workflow, provides support for asynchronous and parallel computations.</span></span> <span data-ttu-id="0e2e4-269">자세한 내용은 [비동기 워크플로](asynchronous-workflows.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-269">For more information, see [Asynchronous Workflows](asynchronous-workflows.md).</span></span>|
|[<span data-ttu-id="0e2e4-270">비동기 워크플로</span><span class="sxs-lookup"><span data-stu-id="0e2e4-270">Asynchronous Workflows</span></span>](asynchronous-workflows.md)|<span data-ttu-id="0e2e4-271">동기 코드를 자연스럽게 작성하는 방식과 매우 유사한 방식으로 비동기 코드를 작성할 수 있도록 하는 언어 기능인 비동기 워크플로에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-271">Describes asynchronous workflows, a language feature that lets you write asynchronous code in a way that is very close to the way you would naturally write synchronous code.</span></span>|
|[<span data-ttu-id="0e2e4-272">코드 인용</span><span class="sxs-lookup"><span data-stu-id="0e2e4-272">Code Quotations</span></span>](code-quotations.md)|<span data-ttu-id="0e2e4-273">F# 코드 식을 프로그래밍 방식으로 생성하여 사용할 수 있도록 지원하는 언어 기능인 코드 인용에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-273">Describes code quotations, a language feature that enables you to generate and work with F# code expressions programmatically.</span></span>|
|[<span data-ttu-id="0e2e4-274">쿼리 식</span><span class="sxs-lookup"><span data-stu-id="0e2e4-274">Query Expressions</span></span>](query-expressions.md)|<span data-ttu-id="0e2e4-275">F#의 LINQ를 구현하고 데이터 원본 또는 열거 가능한 컬렉션에 대한 쿼리를 작성할 수 있도록 지원하는 언어 기능인 쿼리 식에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-275">Describes query expressions, a language feature that implements LINQ for F# and enables you to write queries against a data source or enumerable collection.</span></span>|

## <a name="compiler-supported-constructs"></a><span data-ttu-id="0e2e4-276">컴파일러 지원 구문</span><span class="sxs-lookup"><span data-stu-id="0e2e4-276">Compiler-supported Constructs</span></span>

<span data-ttu-id="0e2e4-277">다음 표에는 특별한 컴파일러 지원 구문을 설명하는 항목이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-277">The following table lists topics that describe special compiler-supported constructs.</span></span>

|<span data-ttu-id="0e2e4-278">항목</span><span class="sxs-lookup"><span data-stu-id="0e2e4-278">Topic</span></span>|<span data-ttu-id="0e2e4-279">Description</span><span class="sxs-lookup"><span data-stu-id="0e2e4-279">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="0e2e4-280">컴파일러 옵션</span><span class="sxs-lookup"><span data-stu-id="0e2e4-280">Compiler Options</span></span>](compiler-options.md)|<span data-ttu-id="0e2e4-281">F# 컴파일러에 대한 명령줄 옵션에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-281">Describes the command-line options for the F# compiler.</span></span>|
|[<span data-ttu-id="0e2e4-282">컴파일러 지시문</span><span class="sxs-lookup"><span data-stu-id="0e2e4-282">Compiler Directives</span></span>](compiler-directives.md)|<span data-ttu-id="0e2e4-283">처리기 지시문 및 컴파일러 지시문에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-283">Describes processor directives and compiler directives.</span></span>|
|[<span data-ttu-id="0e2e4-284">소스 줄, 파일 및 경로 식별자</span><span class="sxs-lookup"><span data-stu-id="0e2e4-284">Source Line, File, and Path Identifiers</span></span>](source-line-file-path-identifiers.md)|<span data-ttu-id="0e2e4-285">코드의 소스 줄 번호, 디렉터리 및 파일 이름에 액세스할 수 있도록 지원하는 기본 제공 값인 `__LINE__`, `__SOURCE_DIRECTORY__` 및 `__SOURCE_FILE__` 식별자에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0e2e4-285">Describes the identifiers `__LINE__`, `__SOURCE_DIRECTORY__`, and `__SOURCE_FILE__`, which are built-in values that enable you to access the source line number, directory and file name in your code.</span></span>|
