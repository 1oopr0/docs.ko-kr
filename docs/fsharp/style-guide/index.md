---
title: F# 스타일 가이드
description: 좋은 F# 코드의 5가지 원칙에 대해 알아봅니다.
ms.date: 12/10/2018
ms.openlocfilehash: 9f47257626e04b09b546de2ae315d48d791678be
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223654"
---
# <a name="f-style-guide"></a><span data-ttu-id="226eb-103">F# 스타일 가이드</span><span class="sxs-lookup"><span data-stu-id="226eb-103">F# style guide</span></span>

<span data-ttu-id="226eb-104">다음 문서에서는 F# 코드 서식 지정 지침과 언어 기능 및 사용 방법에 대한 주제별 지침을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-104">The following articles describe guidelines for formatting F# code and topical guidance for features of the language and how they should be used.</span></span>

<span data-ttu-id="226eb-105">이 지침은 다양한 프로그래머 그룹이 포함된 대규모 코드베이스에서 F# 사용을 기반으로 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-105">This guidance has been formulated based on the use of F# in large codebases with a diverse group of programmers.</span></span> <span data-ttu-id="226eb-106">이 지침에서는 일반적으로 F#의 성공적인 사용을 유도하고 시간이 지남에 따라 프로그램에 대한 요구 사항이 변경될 때 불만을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-106">This guidance generally leads to successful use of F# and minimizes frustrations when requirements for programs change over time.</span></span>

## <a name="five-principles-of-good-f-code"></a><span data-ttu-id="226eb-107">좋은 F# 코드의 5가지 원칙</span><span class="sxs-lookup"><span data-stu-id="226eb-107">Five principles of good F# code</span></span>

<span data-ttu-id="226eb-108">특히 시간이 지남에 따라 변경되는 시스템에서 F# 코드를 작성할 때마다 다음과 같은 원칙을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-108">Keep the following principles in mind any time you write F# code, especially in systems that will change over time.</span></span> <span data-ttu-id="226eb-109">추가 문서의 모든 지침은 이러한 다섯 가지 요소에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-109">Every piece of guidance in further articles stems from these five points.</span></span>

1. <span data-ttu-id="226eb-110">**좋은 F# 코드는 간결하고 표현적이며 구성 가능합니다.**</span><span class="sxs-lookup"><span data-stu-id="226eb-110">**Good F# code is succinct, expressive, and composable**</span></span>

    <span data-ttu-id="226eb-111">F#에는 더 적은 코드 줄로 작업을 표현하고 일반 기능을 다시 사용할 수 있는 많은 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-111">F# has many features that allow you to express actions in fewer lines of code and reuse generic functionality.</span></span> <span data-ttu-id="226eb-112">F# 핵심 라이브러리에는 일반적인 데이터 컬렉션을 사용하기 위한 유용한 많은 형식과 함수도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-112">The F# core library also contains many useful types and functions for working with common collections of data.</span></span> <span data-ttu-id="226eb-113">사용자 고유의 함수와 F# 핵심 라이브러리(또는 다른 라이브러리)의 컴퍼지션은 일상적인 자연스러운 F# 프로그래밍의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-113">Composition of your own functions and those in the F# core library (or other libraries) is a part of routine idiomatic F# programming.</span></span> <span data-ttu-id="226eb-114">일반적인 더 적은 코드 줄로 문제에 대한 솔루션을 표현할 수 있다면 다른 개발자(또는 미래의 자신)는 고마워할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-114">As a general rule, if you can express a solution to a problem in fewer lines of code, other developers (or your future self) will be appreciative.</span></span> <span data-ttu-id="226eb-115">또한 FSharp.Core와 같은 라이브러리, F#에서 실행되는 [방대한 .NET 라이브러리](../../../api/index.md) 또는 복잡한 작업을 수행해야 하는 경우 [NuGet](https://www.nuget.org/)의 타사 패키지를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-115">It's also highly recommended that you use a library such as FSharp.Core, the [vast .NET libraries](../../../api/index.md) that F# runs on, or a third-party package on [NuGet](https://www.nuget.org/) when you need to do a nontrivial task.</span></span>

2. <span data-ttu-id="226eb-116">**좋은 F# 코드는 상호 운용이 가능합니다.**</span><span class="sxs-lookup"><span data-stu-id="226eb-116">**Good F# code is interoperable**</span></span>

    <span data-ttu-id="226eb-117">상호 운용성은 다른 언어로 된 코드를 사용하는 등 여러 가지 형태를 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-117">Interoperation can take multiple forms, including consuming code in different languages.</span></span> <span data-ttu-id="226eb-118">다른 호출자가 상호 운영하는 코드의 경계는 호출자가 F#에 있더라도 올바르게 작동하는 데 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-118">The boundaries of your code that other callers interoperate with are critical pieces to get right, even if the callers are also in F#.</span></span> <span data-ttu-id="226eb-119">F#을 작성할 때 C#과 같은 다른 언어에서 작업을 수행하는 경우를 포함하여 다른 코드에서 작성 중인 코드를 호출하는 방법을 항상 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-119">When writing F#, you should always be thinking about how other code will call into the code you're writing, including if they do so from another language like C#.</span></span> <span data-ttu-id="226eb-120">[F# 구성 요소 디자인 지침](component-design-guidelines.md)은 상호 운용성을 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-120">The [F# Component Design Guidelines](component-design-guidelines.md) describe interoperability in detail.</span></span>

3. <span data-ttu-id="226eb-121">**좋은 F# 코드는 개체 방향이 아닌 개체 프로그래밍을 사용합니다.**</span><span class="sxs-lookup"><span data-stu-id="226eb-121">**Good F# code makes use of object programming, not object orientation**</span></span>

    <span data-ttu-id="226eb-122">F#은 [클래스](../language-reference/classes.md), [인터페이스](../language-reference/interfaces.md), [액세스 한정자](../language-reference/access-control.md), [추상 클래스](../language-reference/abstract-classes.md) 등을 비롯하여 .NET의 개체를 사용한 프로그래밍을 완벽하게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-122">F# has full support for programming with objects in .NET, including [classes](../language-reference/classes.md), [interfaces](../language-reference/interfaces.md), [access modifiers](../language-reference/access-control.md), [abstract classes](../language-reference/abstract-classes.md), and so on.</span></span> <span data-ttu-id="226eb-123">컨텍스트를 인식해야 하는 함수와 같은 보다 복잡한 기능 코드의 경우 개체는 함수가 할 수 없는 방식으로 컨텍스트 정보를 쉽게 캡슐화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-123">For more complicated functional code, such as functions that must be context-aware, objects can easily encapsulate contextual information in ways that functions cannot.</span></span> <span data-ttu-id="226eb-124">[선택적 매개 변수](../language-reference/members/methods.md#optional-arguments)와 같은 기능과 [오버로딩](../language-reference/members/methods.md#overloaded-methods)을 신중하게 사용하면 호출자가 이 기능을 보다 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-124">Features such as [optional parameters](../language-reference/members/methods.md#optional-arguments) and careful use of [overloading](../language-reference/members/methods.md#overloaded-methods) can make consumption of this functionality easier for callers.</span></span>

4. <span data-ttu-id="226eb-125">**좋은 F# 코드는 변형 노출 없이 잘 수행됩니다.**</span><span class="sxs-lookup"><span data-stu-id="226eb-125">**Good F# code performs well without exposing mutation**</span></span>

    <span data-ttu-id="226eb-126">고성능 코드를 작성하기 위해서는 변형을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-126">It's no secret that to write high-performance code, you must use mutation.</span></span> <span data-ttu-id="226eb-127">컴퓨터가 작동하는 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-127">It's how computers work, after all.</span></span> <span data-ttu-id="226eb-128">이러한 코드는 오류가 발생하기 쉬우며 올바른 방법을 찾기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-128">Such code is often error-prone and difficult to get right.</span></span> <span data-ttu-id="226eb-129">호출자에 대한 변형 노출을 방지하세요.</span><span class="sxs-lookup"><span data-stu-id="226eb-129">Avoid exposing mutation to callers.</span></span> <span data-ttu-id="226eb-130">대신 성능이 중요한 경우 [변형 기반 구현을 숨기는 기능 인터페이스를 빌드](conventions.md#performance)하세요.</span><span class="sxs-lookup"><span data-stu-id="226eb-130">Instead, [build a functional interface that hides a mutation-based implementation](conventions.md#performance) when performance is critical.</span></span>

5. <span data-ttu-id="226eb-131">**올바른 F# 코드는 도구화가 가능합니다.**</span><span class="sxs-lookup"><span data-stu-id="226eb-131">**Good F# code is toolable**</span></span>

    <span data-ttu-id="226eb-132">도구는 대규모 코드베이스에서 작업하는 데 유용하며 F# 언어 도구에서 보다 효과적으로 사용할 수 있도록 F# 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-132">Tools are invaluable for working in large codebases, and you can write F# code such that it can be used more effectively with F# language tooling.</span></span> <span data-ttu-id="226eb-133">디버거를 사용하여 중간 값을 검사할 수 있도록 지점 없는 프로그래밍 스타일로 과용하지 않도록 하는 것이 한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-133">One example is making sure you don't overdo it with a point-free style of programming, so that intermediate values can be inspected with a debugger.</span></span> <span data-ttu-id="226eb-134">또 다른 예는 편집기의 도구 설명이 호출 사이트에서 해당 주석을 표시할 수 있도록 구성을 설명하는 [XML 문서 주석](../language-reference/xml-documentation.md)을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-134">Another example is using [XML documentation comments](../language-reference/xml-documentation.md) describing constructs such that tooltips in editors can display those comments at the call site.</span></span> <span data-ttu-id="226eb-135">다른 프로그래머가 해당 도구를 사용하여 코드를 읽고, 탐색하고, 디버깅하고, 조작하는 방법에 대해 항상 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-135">Always think about how your code will be read, navigated, debugged, and manipulated by other programmers with their tools.</span></span>

## <a name="next-steps"></a><span data-ttu-id="226eb-136">다음 단계</span><span class="sxs-lookup"><span data-stu-id="226eb-136">Next steps</span></span>

<span data-ttu-id="226eb-137">[F# 코드 서식 지정 지침](formatting.md)은 읽기 쉽도록 코드의 서식을 지정하는 방법에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-137">The [F# code formatting guidelines](formatting.md) provide guidance on how to format code so that it is easy to read.</span></span>

<span data-ttu-id="226eb-138">[F# 코딩 규칙](conventions.md)은 큰 F# 코드베이스의 장기 유지 관리에 도움이 되는 F# 프로그래밍 관용구에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-138">The [F# coding conventions](conventions.md) provide guidance for F# programming idioms that will help the long-term maintenance of larger F# codebases.</span></span>

<span data-ttu-id="226eb-139">[F# 구성 요소 디자인 지침](component-design-guidelines.md)은 라이브러리와 같은 F# 구성 요소를 작성하기 위한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="226eb-139">The [F# component design guidelines](component-design-guidelines.md) provide guidance for authoring F# components, such as libraries.</span></span>
