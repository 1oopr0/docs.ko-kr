---
title: 전송 선택
ms.date: 03/30/2017
helpviewer_keywords:
- choosing transports [WCF]
ms.assetid: b169462b-f7b6-4cf4-9fca-d306909ee8bf
ms.openlocfilehash: 7e1f6b2e1905fb92ebfe78be351feeaebb374c11
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84587068"
---
# <a name="choosing-a-transport"></a><span data-ttu-id="3db4c-102">전송 선택</span><span class="sxs-lookup"><span data-stu-id="3db4c-102">Choosing a Transport</span></span>
<span data-ttu-id="3db4c-103">이 항목에서는 WCF (Windows Communication Foundation)에 포함 된 세 가지 기본 전송 인 HTTP, TCP 및 명명 된 파이프 중에서 선택 하기 위한 조건을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-103">This topic discusses criteria for choosing among the three main transports that are included in Windows Communication Foundation (WCF): HTTP, TCP, and named pipes.</span></span> <span data-ttu-id="3db4c-104">WCF에는 메시지 큐 (MSMQ 라고도 함) 전송도 포함 되지만이 문서에서는 메시지 큐에 대해 다루지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-104">WCF also includes a message queuing (also known as MSMQ) transport, but this document does not cover message queuing.</span></span>  
  
 <span data-ttu-id="3db4c-105">WCF 프로그래밍 모델은 두 끝점을 연결 하는 전송 메커니즘에서 끝점 작업 (서비스 계약에서 표현 됨)을 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-105">The WCF programming model separates endpoint operations (as expressed in a service contract) from the transport mechanism that connects two endpoints.</span></span> <span data-ttu-id="3db4c-106">그 결과 네트워크에 서비스를 노출시키는 방법을 결정할 수 있는 유연성이 보장됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-106">This gives you the flexibility to decide how to expose your services to the network.</span></span>  
  
 <span data-ttu-id="3db4c-107">WCF에서는 바인딩 *요소*시퀀스로 구성 된 *바인딩을*사용 하 여 네트워크를 통해 끝점 간에 데이터를 전송 하는 방법을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-107">In WCF, you specify how to transfer data across a network between endpoints by using a *binding*, which is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="3db4c-108">전송은 바인딩에 속한 전송 바인딩 요소로 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-108">A transport is represented by a transport binding element, which is part of the binding.</span></span> <span data-ttu-id="3db4c-109">바인딩에는 보안, 필수 메시지 인코더 바인딩 요소, 그리고 필수 전송 바인딩 요소와 같은 선택적인 프로토콜 바인딩 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-109">A binding includes optional protocol binding elements, such as security, a required message encoder binding element, and a required transport binding element.</span></span> <span data-ttu-id="3db4c-110">전송에서는 다른 애플리케이션과의 사이에서 serialize된 형식의 메시지를 주고 받습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-110">A transport sends or receives the serialized form of a message to or from another application.</span></span>  
  
 <span data-ttu-id="3db4c-111">기존 클라이언트 또는 서버에 연결해야 하는 경우에는 특정 전송을 선택할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-111">If you must connect to an existing client or server, you may not have a choice about using a particular transport.</span></span> <span data-ttu-id="3db4c-112">그러나 WCF 서비스는 서로 다른 전송을 사용 하 여 여러 끝점을 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-112">However, WCF services can be made accessible through multiple endpoints, each with a different transport.</span></span> <span data-ttu-id="3db4c-113">단일 전송이 서비스에서 의도하는 대상을 수용하지 못하는 경우 여러 엔드포인트를 통해 서비스를 공개해 보세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-113">When a single transport does not cover the intended audience for your service, consider exposing the service over multiple endpoints.</span></span> <span data-ttu-id="3db4c-114">그러면 클라이언트 애플리케이션에서 가장 적합한 엔드포인트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-114">Client applications can then use the endpoint that is best for them.</span></span>  
  
 <span data-ttu-id="3db4c-115">전송을 선택하고 나면 이를 사용하는 바인딩을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-115">After you choose a transport, you must select a binding that uses it.</span></span> <span data-ttu-id="3db4c-116">시스템 제공 바인딩 ( [시스템 제공](../system-provided-bindings.md)바인딩 참조)을 선택 하거나 사용자 지정 바인딩을 직접 빌드할 수 있습니다 ( [사용자 지정](../extending/custom-bindings.md)바인딩 참조).</span><span class="sxs-lookup"><span data-stu-id="3db4c-116">You can choose a system-provided binding (see [System-Provided Bindings](../system-provided-bindings.md)), or you can build your own custom binding (see [Custom Bindings](../extending/custom-bindings.md)).</span></span> <span data-ttu-id="3db4c-117">바인딩을 직접 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-117">You can also create your own binding.</span></span> <span data-ttu-id="3db4c-118">자세한 내용은 [사용자 정의 바인딩 만들기](../extending/creating-user-defined-bindings.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-118">For more information, see [Creating User-Defined Bindings](../extending/creating-user-defined-bindings.md).</span></span>  
  
## <a name="advantages-of-each-transport"></a><span data-ttu-id="3db4c-119">각 전송의 이점</span><span class="sxs-lookup"><span data-stu-id="3db4c-119">Advantages of Each Transport</span></span>  
 <span data-ttu-id="3db4c-120">이 단원에서는 3개의 주요 전송 중에서 하나를 선택하는 데 대한 주된 이유를 자세한 의사 결정 차트와 함께 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-120">This section describes the main reasons for choosing any one of the three main transports, including a detailed decision chart for choosing among them.</span></span>  
  
### <a name="when-to-use-http-transport"></a><span data-ttu-id="3db4c-121">HTTP 전송을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="3db4c-121">When to Use HTTP Transport</span></span>  
 <span data-ttu-id="3db4c-122">HTTP는 클라이언트와 서버 사이의 요청/응답 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-122">HTTP is a request/response protocol between clients and servers.</span></span> <span data-ttu-id="3db4c-123">가장 일반적인 애플리케이션은 웹 서버와 통신하는 웹 브라우저 클라이언트로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-123">The most common application consists of Web-browser clients that communicate with a Web server.</span></span> <span data-ttu-id="3db4c-124">클라이언트에서 서버로 요청을 보내면 서버에서 클라이언트 요청 메시지를 수신 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-124">The client sends a request to a server, which listens for client request messages.</span></span> <span data-ttu-id="3db4c-125">서버에서 요청을 받으면 요청 상태가 포함된 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-125">When the server receives a request, it returns a response, which contains the status of the request.</span></span> <span data-ttu-id="3db4c-126">성공적인 경우 웹 페이지, 오류 메시지 또는 기타 정보와 같은 선택적인 데이터가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-126">If successful, optional data, such as a Web page, an error message, or other information is returned.</span></span> <span data-ttu-id="3db4c-127">HTTP 프로토콜에 대 한 자세한 내용은 [http-하이퍼텍스트 전송 프로토콜](https://www.w3.org/Protocols/)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-127">For more information about the HTTP protocol, see [HTTP - Hypertext Transfer Protocol](https://www.w3.org/Protocols/).</span></span>  
  
 <span data-ttu-id="3db4c-128">HTTP 프로토콜은 연결 기반이 아닙니다. 응답을 보내고 나면 상태가 유지되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-128">The HTTP protocol is not connection-based—once the response is sent, no state is maintained.</span></span> <span data-ttu-id="3db4c-129">여러 페이지로 된 트랜잭션을 처리하려면 애플리케이션에서 모든 필요한 상태를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-129">To handle multiple-page transactions, the application must persist any necessary state.</span></span>  
  
 <span data-ttu-id="3db4c-130">WCF에서 HTTP 전송 바인딩은 레거시 비 WCF 시스템과의 상호 운용성을 위해 최적화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-130">In WCF, the HTTP transport binding is optimized for interoperability with legacy non-WCF systems.</span></span> <span data-ttu-id="3db4c-131">모든 통신 당사자가 WCF를 사용 하는 경우 TCP 기반 또는 명명 된 파이프 기반 바인딩이 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-131">If all communicating parties are using WCF, the TCP-based or named pipes-based bindings are faster.</span></span> <span data-ttu-id="3db4c-132">자세한 내용은 <xref:System.ServiceModel.NetTcpBinding> 및 <xref:System.ServiceModel.NetNamedPipeBinding>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-132">For more information, see <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding>.</span></span>  
  
### <a name="when-to-use-the-tcp-transport"></a><span data-ttu-id="3db4c-133">TCP 전송을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="3db4c-133">When to Use the TCP Transport</span></span>  
 <span data-ttu-id="3db4c-134">TCP는 스트리밍 지향의 연결 기반 서비스로, 엔드투엔드 오류 검색과 수정 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-134">TCP is a connection-based, stream-oriented delivery service with end-to-end error detection and correction.</span></span> <span data-ttu-id="3db4c-135">*연결 기반* 은 데이터를 교환 하기 전에 호스트 간의 통신 세션이 설정 됨을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-135">*Connection-based* means that a communication session between hosts is established before exchanging data.</span></span> <span data-ttu-id="3db4c-136">호스트는 TCP/IP 네트워크에서 논리 IP 주소로 식별되는 모든 디바이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-136">A host is any device on a TCP/IP network identified by a logical IP address.</span></span>  
  
 <span data-ttu-id="3db4c-137">TCP를 사용하면 데이터 배달이 안정적이고 사용이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-137">TCP provides reliable data delivery and ease of use.</span></span> <span data-ttu-id="3db4c-138">특히 TCP에서는 발신자에게 패킷 배달에 대해 알리고, 패킷이 보낸 순서와 같은 순서로 배달되도록 보장하며, 손실된 패킷을 다시 전송하고, 데이터 패킷이 중복되지 않았는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-138">Specifically, TCP notifies the sender of packet delivery, guarantees that packets are delivered in the same order in which they are sent, retransmits lost packets, and ensures that data packets are not duplicated.</span></span> <span data-ttu-id="3db4c-139">이러한 신뢰할 수 있는 배달은 두 TCP/IP 노드 사이에 적용 되며, *ws-i*와 동일한 것은 아닙니다. 여기에 포함 될 수 있는 중간 노드의 수에 관계 없이 끝점 사이에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-139">Note that this reliable delivery applies between two TCP/IP nodes, and is not the same thing as *WS-ReliableMessaging*, which applies between endpoints, no matter how many intermediate nodes they may include.</span></span>  
  
 <span data-ttu-id="3db4c-140">WCF TCP 전송은 통신의 양쪽 끝에서 WCF를 사용 하는 시나리오에 대해 최적화 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-140">The WCF TCP transport is optimized for the scenario where both ends of the communication are using WCF.</span></span> <span data-ttu-id="3db4c-141">이 바인딩은 서로 다른 컴퓨터 간의 통신을 포함 하는 시나리오에 대 한 가장 빠른 WCF 바인딩입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-141">This binding is the fastest WCF binding for scenarios that involve communicating between different machines.</span></span> <span data-ttu-id="3db4c-142">메시지 교환에서는 최적화된 메시지 전송을 위해 <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-142">The message exchanges use the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> for optimized message transfer.</span></span> <span data-ttu-id="3db4c-143">TCP는 이중 통신을 제공하기 때문에 클라이언트가 NAT(Network Address Translation) 뒤에 있더라도 이중 계약을 구현하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-143">TCP provides duplex communication and so can be used to implement duplex contracts, even if the client is behind network address translation (NAT).</span></span>  
  
### <a name="when-to-use-the-named-pipe-transport"></a><span data-ttu-id="3db4c-144">명명된 파이프 전송을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="3db4c-144">When to Use the Named Pipe Transport</span></span>  
 <span data-ttu-id="3db4c-145">명명된 파이프는 프로세스에서 통신에 사용할 수 있는 공유 메모리 섹션과 같이 Windows 운영 체제 커널에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-145">A named pipe is an object in the Windows operating system kernel, such as a section of shared memory that processes can use for communication.</span></span> <span data-ttu-id="3db4c-146">명명된 파이프는 이름이 있으며 한 시스템에서 프로세스 사이의 단방향 또는 이중 통신에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-146">A named pipe has a name, and can be used for one-way or duplex communication between processes on a single machine.</span></span>  
  
 <span data-ttu-id="3db4c-147">단일 컴퓨터의 서로 다른 WCF 응용 프로그램 간에 통신이 필요 하 고 다른 컴퓨터의 통신을 방지 하려면 명명 된 파이프 전송을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-147">When communication is required between different WCF applications on a single computer, and you want to prevent any communication from another machine, then use the named pipes transport.</span></span> <span data-ttu-id="3db4c-148">추가 제한으로는 따로 권한을 부여하지 않은 한 Windows 원격 데스크톱에서 실행하는 프로세스가 같은 Windows 원격 데스크톱으로 제한될 수 있다는 것이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-148">An additional restriction is that processes running from Windows Remote Desktop may be restricted to the same Windows Remote Desktop session unless they have elevated privileges.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="3db4c-149">IIS에서 호스팅된 여러 사이트에서 약한 와일드카드 URL 예약과 함께 명명된 파이프 전송을 사용하는 경우 다음과 같은 오류가 발생할 수 있습니다. '2' 사이트를 수신 대기하는 동안 프로토콜 'net.pipe'의 Activation Service 'NetPipeActivator'에서 오류가 발생했으므로 사이트에 대한 해당 프로토콜을 임시로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-149">When using the named pipe transport with a weak wildcard URL reservation on multiple sites hosted in IIS, the following error may occur: An error occurred in the Activation Service 'NetPipeActivator' of the protocol 'net.pipe' while trying to listen for the site '2', thus the protocol is disabled for the site temporarily.</span></span> <span data-ttu-id="3db4c-150">자세한 내용은 예외 메시지를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3db4c-150">See the exception message for more details.</span></span> <span data-ttu-id="3db4c-151">URL: WeakWildcard: net.pipe: \<machine name> //Status: ConflictingRegistration Exception: Process Name: Smsvchost.exe PROCESS ID: 1076 </span><span class="sxs-lookup"><span data-stu-id="3db4c-151">URL: WeakWildcard:net.pipe:/\<machine name>/ Status: ConflictingRegistration Exception:  Process Name: SMSvcHost Process ID: 1076</span></span>\  
  
## <a name="decision-points-for-choosing-a-transport"></a><span data-ttu-id="3db4c-152">전송을 선택할 때의 의사 결정 요점</span><span class="sxs-lookup"><span data-stu-id="3db4c-152">Decision Points for Choosing a Transport</span></span>  
 <span data-ttu-id="3db4c-153">다음 표에서는 전송을 선택할 때 흔히 사용되는 의사 결정 요점에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-153">The following table describes the common decision points used to choose a transport.</span></span> <span data-ttu-id="3db4c-154">애플리케이션에 적용되는 추가 특성과 전송을 모두 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-154">You should consider any additional attributes and transports that apply to your application.</span></span> <span data-ttu-id="3db4c-155">애플리케이션에서 중요한 특성을 확인하고 각 특성과 잘 연결되는 전송을 확인한 다음 특성 집합에 가장 적합한 전송을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-155">Identify the attributes that are important for your application, identify the transports that associate favorably with each of your attributes, and then select the transports that work best with your attribute set.</span></span>  
  
|<span data-ttu-id="3db4c-156">attribute</span><span class="sxs-lookup"><span data-stu-id="3db4c-156">Attribute</span></span>|<span data-ttu-id="3db4c-157">Description</span><span class="sxs-lookup"><span data-stu-id="3db4c-157">Description</span></span>|<span data-ttu-id="3db4c-158">선호 전송</span><span class="sxs-lookup"><span data-stu-id="3db4c-158">Favored transports</span></span>|  
|---------------|-----------------|------------------------|  
|<span data-ttu-id="3db4c-159">진단</span><span class="sxs-lookup"><span data-stu-id="3db4c-159">Diagnostics</span></span>|<span data-ttu-id="3db4c-160">진단을 사용하면 전송 연결 문제를 자동으로 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-160">Diagnostics allow you to automatically detect transport connectivity problems.</span></span> <span data-ttu-id="3db4c-161">모든 전송에서는 연결을 설명하는 오류 정보를 돌려보내는 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-161">All transports support the ability to send back fault information that describes connectivity.</span></span> <span data-ttu-id="3db4c-162">그러나 WCF에는 네트워크 문제를 조사 하기 위한 진단 도구가 포함 되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-162">However, WCF does not include diagnostic tools for investigating network issues.</span></span>|<span data-ttu-id="3db4c-163">None</span><span class="sxs-lookup"><span data-stu-id="3db4c-163">None</span></span>|  
|<span data-ttu-id="3db4c-164">Hosting</span><span class="sxs-lookup"><span data-stu-id="3db4c-164">Hosting</span></span>|<span data-ttu-id="3db4c-165">모든 WCF 끝점은 응용 프로그램 내에서 호스팅되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-165">All WCF endpoints must be hosted inside an application.</span></span> <span data-ttu-id="3db4c-166">IIS 6.0 이전 버전에서는 HTTP 전송을 사용 하는 호스팅 응용 프로그램만 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-166">IIS 6.0 and earlier versions support only hosting applications that use the HTTP transport.</span></span> <span data-ttu-id="3db4c-167">Windows Vista에서는 TCP 및 명명 된 파이프를 비롯 한 모든 WCF 전송 호스팅을 위한 지원이 추가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-167">On Windows Vista, support is added for hosting all WCF transports, including TCP and named pipes.</span></span> <span data-ttu-id="3db4c-168">자세한 내용은 [인터넷 정보 서비스에서 호스팅](hosting-in-internet-information-services.md) 및 [Windows Process Activation Service에서 호스팅](hosting-in-windows-process-activation-service.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-168">For more information, see [Hosting in Internet Information Services](hosting-in-internet-information-services.md) and [Hosting in Windows Process Activation Service](hosting-in-windows-process-activation-service.md).</span></span>|<span data-ttu-id="3db4c-169">HTTP</span><span class="sxs-lookup"><span data-stu-id="3db4c-169">HTTP</span></span>|  
|<span data-ttu-id="3db4c-170">검사</span><span class="sxs-lookup"><span data-stu-id="3db4c-170">Inspection</span></span>|<span data-ttu-id="3db4c-171">검사는 전송 중에 메시지에서 정보를 추출하고 처리하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-171">Inspection is the ability to extract and process information from messages during transmission.</span></span> <span data-ttu-id="3db4c-172">HTTP 프로토콜에서는 메시지를 검사 및 분석하는 도구를 더 쉽게 작성할 수 있도록 데이터에서 라우팅 및 제어 정보를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-172">The HTTP protocol separates routing and control information from data, making it easier to build tools that inspect and analyze messages.</span></span> <span data-ttu-id="3db4c-173">검사하기 쉬운 전송에는 네트워크 제품의 처리 능력도 덜 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-173">Transports that are easy to inspect may also require less processing power in network appliances.</span></span> <span data-ttu-id="3db4c-174">사용되는 보안 수준에 따라 메시지의 검사 가능 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-174">The level of security used impacts whether messages can be inspected.</span></span>|<span data-ttu-id="3db4c-175">HTTP</span><span class="sxs-lookup"><span data-stu-id="3db4c-175">HTTP</span></span>|  
|<span data-ttu-id="3db4c-176">대기 시간</span><span class="sxs-lookup"><span data-stu-id="3db4c-176">Latency</span></span>|<span data-ttu-id="3db4c-177">대기 시간은 메시지 교환을 완료하는 데 필요한 최소 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-177">Latency is the minimum amount of time required to complete an exchange of messages.</span></span> <span data-ttu-id="3db4c-178">모든 네트워크 작업에는 선택한 전송에 따라 어느 정도의 대기 시간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-178">All network operations have more or less latency depending on the choice of transport.</span></span> <span data-ttu-id="3db4c-179">HTTP와 같이 네이티브 메시지 교환 패턴이 요청 응답인 이중 또는 단방향 통신을 사용하면 메시지에 적용되는 상관 관계 때문에 대기 시간이 추가될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-179">Using duplex or one-way communication with a transport whose native message exchange pattern is request-reply, such as HTTP, can cause additional latency due to the forced correlation of messages.</span></span> <span data-ttu-id="3db4c-180">이런 경우에는 TCP와 같이 네이티브 메시지 교환 패턴이 이중인 전송을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-180">In this situation, consider using a transport whose native message exchange pattern is duplex, such as TCP.</span></span>|<span data-ttu-id="3db4c-181">TCP, 명명된</span><span class="sxs-lookup"><span data-stu-id="3db4c-181">TCP, Named</span></span><br /><br /> <span data-ttu-id="3db4c-182">파이프</span><span class="sxs-lookup"><span data-stu-id="3db4c-182">Pipe</span></span>|  
|<span data-ttu-id="3db4c-183">도달률</span><span class="sxs-lookup"><span data-stu-id="3db4c-183">Reach</span></span>|<span data-ttu-id="3db4c-184">전송의 도달 범위는 전송에서 다른 시스템과 연결하는 능력을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-184">The reach of a transport reflects how capable the transport is at connecting with other systems.</span></span> <span data-ttu-id="3db4c-185">명명된 파이프 전송은 도달 범위가 짧으며, 같은 시스템에서 실행되는 서비스에만 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-185">The named pipe transport has very little reach; it can only connect to services running on the same machine.</span></span> <span data-ttu-id="3db4c-186">TCP 및 HTTP 전송은 모두 도달 범위가 크며 일부 NAT 및 방화벽 구성도 통과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-186">The TCP and HTTP transports both have excellent reach and can penetrate some NAT and firewall configurations.</span></span> <span data-ttu-id="3db4c-187">자세한 내용은 [nat 및 방화벽 작업](working-with-nats-and-firewalls.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3db4c-187">For more information, see [Working with NATs and Firewalls](working-with-nats-and-firewalls.md).</span></span>|<span data-ttu-id="3db4c-188">HTTP, TCP</span><span class="sxs-lookup"><span data-stu-id="3db4c-188">HTTP, TCP</span></span>|  
|<span data-ttu-id="3db4c-189">보안</span><span class="sxs-lookup"><span data-stu-id="3db4c-189">Security</span></span>|<span data-ttu-id="3db4c-190">보안은 전송 중에 기밀성, 무결성 또는 인증을 제공하여 메시지를 보호하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-190">Security is the ability to protect messages during transfer by supplying confidentiality, integrity, or authentication.</span></span> <span data-ttu-id="3db4c-191">기밀성은 메시지를 검토로부터 보호하고, 무결성은 메시지를 수정으로부터 보호하고, 인증은 메시지의 발신자 또는 수신자에게 보증을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-191">Confidentiality protects a message from being examined, integrity protects a message from being modified, and authentication gives assurances about the sender or receiver of the message.</span></span><br /><br /> <span data-ttu-id="3db4c-192">WCF는 메시지 수준과 전송 수준 모두에서 전송 보안을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-192">WCF supports transfer security both at the message level and transport level.</span></span> <span data-ttu-id="3db4c-193">전송에서 버퍼링된 전송 모드를 지원하는 경우 메시지 보안은 전송과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-193">Message security composes with a transport if the transport supports a buffered transfer mode.</span></span> <span data-ttu-id="3db4c-194">전송 보안에 대한 지원은 선택한 전송에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-194">Support for transport security varies depending on the chosen transport.</span></span> <span data-ttu-id="3db4c-195">HTTP, TCP 및 명명된 파이프 전송의 전송 보안 지원에는 적정 수준의 패리티가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-195">The HTTP, TCP, and named pipe transports have reasonable parity in their support for transport security.</span></span>|<span data-ttu-id="3db4c-196">모두</span><span class="sxs-lookup"><span data-stu-id="3db4c-196">All</span></span>|  
|<span data-ttu-id="3db4c-197">처리량</span><span class="sxs-lookup"><span data-stu-id="3db4c-197">Throughput</span></span>|<span data-ttu-id="3db4c-198">처리량은 지정된 기간 내에 전송 및 처리할 수 있는 데이터의 양을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-198">Throughput measures the amount of data that can be transmitted and processed in a specified period of time.</span></span> <span data-ttu-id="3db4c-199">대기 시간과 마찬가지로 선택한 전송에 따라 서비스 작업의 처리량이 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-199">Like latency, the chosen transport can affect the throughput for service operations.</span></span> <span data-ttu-id="3db4c-200">전송의 처리량을 최대화하려면 전송 콘텐츠의 오버헤드를 최소화하고 메시지 교환이 완료될 때까지 기다리는 시간을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-200">Maximizing throughput for a transport requires minimizing both the overhead of transmitting content as well as minimizing the time spent waiting for message exchanges to complete.</span></span> <span data-ttu-id="3db4c-201">TCP 및 명명된 파이프 전송 모두에서 메시지 본문에 약간의 오버헤드를 추가하며 메시지 응답의 대기 시간을 줄여 주는 네이티브 이중 셰이프를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-201">Both the TCP and named pipe transports add little overhead to the message body and support a native duplex shape that reduces the wait for message replies.</span></span>|<span data-ttu-id="3db4c-202">TCP, 명명된 파이프</span><span class="sxs-lookup"><span data-stu-id="3db4c-202">TCP, named pipe</span></span>|  
|<span data-ttu-id="3db4c-203">도구</span><span class="sxs-lookup"><span data-stu-id="3db4c-203">Tooling</span></span>|<span data-ttu-id="3db4c-204">도구는 개발, 진단, 호스팅 및 기타 작업의 프로토콜에 대한 타사 애플리케이션 지원을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-204">Tooling represents third-party application support for a protocol for development, diagnosis, hosting, and other activities.</span></span> <span data-ttu-id="3db4c-205">HTTP 프로토콜에 사용되는 도구 및 소프트웨어를 개발하는 일에는 특히 큰 투자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3db4c-205">Developing tools and software to work with the HTTP protocol signifies a particularly large investment.</span></span>|<span data-ttu-id="3db4c-206">HTTP</span><span class="sxs-lookup"><span data-stu-id="3db4c-206">HTTP</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="3db4c-207">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3db4c-207">See also</span></span>

- <xref:System.ServiceModel.BasicHttpBinding>
- <xref:System.ServiceModel.WSHttpBinding>
- <xref:System.ServiceModel.WSDualHttpBinding>
- <xref:System.ServiceModel.WSFederationHttpBinding>
- <xref:System.ServiceModel.Channels.HttpTransportBindingElement>
- <xref:System.ServiceModel.NetTcpBinding>
- <xref:System.ServiceModel.Channels.TcpTransportBindingElement>
- <xref:System.ServiceModel.NetNamedPipeBinding>
- <xref:System.ServiceModel.Channels.NamedPipeTransportBindingElement>
- [<span data-ttu-id="3db4c-208">바인딩</span><span class="sxs-lookup"><span data-stu-id="3db4c-208">Bindings</span></span>](bindings.md)
- [<span data-ttu-id="3db4c-209">시스템 제공 바인딩</span><span class="sxs-lookup"><span data-stu-id="3db4c-209">System-Provided Bindings</span></span>](../system-provided-bindings.md)
- [<span data-ttu-id="3db4c-210">사용자 정의 바인딩 만들기</span><span class="sxs-lookup"><span data-stu-id="3db4c-210">Creating User-Defined Bindings</span></span>](../extending/creating-user-defined-bindings.md)
