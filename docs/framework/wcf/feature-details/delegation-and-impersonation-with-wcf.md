---
title: WCF를 통한 위임 및 가장
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- impersonation [WCF]
- delegation [WCF]
ms.assetid: 110e60f7-5b03-4b69-b667-31721b8e3152
ms.openlocfilehash: e491925fdbe8d44df8e0c64b563eb92569453e35
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84599258"
---
# <a name="delegation-and-impersonation-with-wcf"></a><span data-ttu-id="9a13f-102">WCF를 통한 위임 및 가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-102">Delegation and Impersonation with WCF</span></span>
<span data-ttu-id="9a13f-103">*가장* 은 서비스에서 서비스 도메인 리소스에 대한 클라이언트 액세스를 제한하는 데 사용하는 일반적인 기술 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-103">*Impersonation* is a common technique that services use to restrict client access to a service domain's resources.</span></span> <span data-ttu-id="9a13f-104">서비스 도메인 리소스는 로컬 파일(가장)과 같은 시스템 리소스이거나 파일 공유(위임)와 같은 다른 시스템의 리소스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-104">Service domain resources can either be machine resources, such as local files (impersonation), or a resource on another machine, such as a file share (delegation).</span></span> <span data-ttu-id="9a13f-105">샘플 애플리케이션을 보려면 [Impersonating the Client](../samples/impersonating-the-client.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9a13f-105">For a sample application, see [Impersonating the Client](../samples/impersonating-the-client.md).</span></span> <span data-ttu-id="9a13f-106">가장을 사용하는 방법에 대한 예제는 [How to: Impersonate a Client on a Service](../how-to-impersonate-a-client-on-a-service.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9a13f-106">For an example of how to use impersonation, see [How to: Impersonate a Client on a Service](../how-to-impersonate-a-client-on-a-service.md).</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="9a13f-107">서비스를 통해 클라이언트를 가장하는 경우 서버 프로세스보다 높은 권한의 클라이언트 자격 증명을 사용하여 서비스가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-107">Be aware that when impersonating a client on a service, the service runs with the client's credentials, which may have higher privileges than the server process.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="9a13f-108">개요</span><span class="sxs-lookup"><span data-stu-id="9a13f-108">Overview</span></span>  
 <span data-ttu-id="9a13f-109">일반적으로 클라이언트는 서비스에서 클라이언트 대신 일부 작업을 수행하도록 서비스를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-109">Typically, clients call a service to have the service perform some action on the client’s behalf.</span></span> <span data-ttu-id="9a13f-110">가장을 사용하면 서비스는 작업을 수행하는 동안 클라이언트 역할을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-110">Impersonation allows the service to act as the client while performing the action.</span></span> <span data-ttu-id="9a13f-111">위임을 사용하면 백 엔드 서비스가 클라이언트를 가장할 수 있는 방식으로 프론트 엔드 서비스가 클라이언트의 요청을 백 엔드 서비스에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-111">Delegation allows a front-end service to forward the client’s request to a back-end service in such a way that the back-end service can also impersonate the client.</span></span> <span data-ttu-id="9a13f-112">가장은 클라이언트에 특정 작업을 수행할 수 있는 권한을 부여할지 여부를 확인하는 데 사용되는 가장 일반적인 방법인 반면 위임은 클라이언트 ID와 함께 가장 기능을 백 엔드 서비스에 전달하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-112">Impersonation is most commonly used as a way of checking whether a client is authorized to perform a particular action, while delegation is a way of flowing impersonation capabilities, along with the client’s identity, to a back-end service.</span></span> <span data-ttu-id="9a13f-113">위임은 Kerberos 기반 인증을 수행할 때 사용할 수 있는 Windows 도메인 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-113">Delegation is a Windows domain feature that can be used when Kerberos-based authentication is performed.</span></span> <span data-ttu-id="9a13f-114">위임은 ID 전달과 구분되며, 클라이언트의 암호 없이 클라이언트를 가장하는 기능을 전송하기 때문에 ID 전달보다 훨씬 권한이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-114">Delegation is distinct from identity flow and, because delegation transfers the ability to impersonate the client without possession of the client’s password, it is a much higher privileged operation than identity flow.</span></span>  
  
 <span data-ttu-id="9a13f-115">가장과 위임 모두 클라이언트에 Windows ID가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-115">Both impersonation and delegation require that the client have a Windows identity.</span></span> <span data-ttu-id="9a13f-116">클라이언트에 Windows ID가 없는 경우 사용할 수 있는 유일한 옵션은 클라이언트 ID를 두 번째 서비스에 전달하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-116">If a client does not possess a Windows identity, then the only option available is to flow the client’s identity to the second service.</span></span>  
  
## <a name="impersonation-basics"></a><span data-ttu-id="9a13f-117">가장 기본 사항</span><span class="sxs-lookup"><span data-stu-id="9a13f-117">Impersonation Basics</span></span>  
 <span data-ttu-id="9a13f-118">WCF (Windows Communication Foundation)는 다양 한 클라이언트 자격 증명에 대 한 가장을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-118">Windows Communication Foundation (WCF) supports impersonation for a variety of client credentials.</span></span> <span data-ttu-id="9a13f-119">이 항목에서는 서비스 메서드를 구현하는 동안 호출자를 가장하기 위한 서비스 모델 지원에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-119">This topic describes service model support for impersonating the caller during the implementation of a service method.</span></span> <span data-ttu-id="9a13f-120">이러한 시나리오에서 가장 및 SOAP 보안과 WCF 옵션을 포함 하는 일반적인 배포 시나리오에 대해서도 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-120">Also discussed are common deployment scenarios involving impersonation and SOAP security and WCF options in these scenarios.</span></span>  
  
 <span data-ttu-id="9a13f-121">이 항목에서는 SOAP 보안을 사용 하는 경우 WCF의 가장 및 위임에 대해 중점적으로 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-121">This topic focuses on impersonation and delegation in WCF when using SOAP security.</span></span> <span data-ttu-id="9a13f-122">전송 보안을 사용 하 여 가장을 사용 [하는 방법](using-impersonation-with-transport-security.md)에 설명 된 대로 전송 보안을 사용 하는 경우 WCF에서 가장 및 위임을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-122">You can also use impersonation and delegation with WCF when using transport security, as described in [Using Impersonation with Transport Security](using-impersonation-with-transport-security.md).</span></span>  
  
## <a name="two-methods"></a><span data-ttu-id="9a13f-123">두 가지 방법</span><span class="sxs-lookup"><span data-stu-id="9a13f-123">Two Methods</span></span>  
 <span data-ttu-id="9a13f-124">WCF SOAP 보안에는 가장을 수행 하는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-124">WCF SOAP security has two distinct methods for performing impersonation.</span></span> <span data-ttu-id="9a13f-125">사용되는 방법은 바인딩에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-125">The method used depends on the binding.</span></span> <span data-ttu-id="9a13f-126">첫 번째 방법은 SSPI(보안 지원 공급자 인터페이스) 또는 Kerberos 인증에서 가져온 후 서비스에 캐시되는 Windows 토큰을 통한 가장이며,</span><span class="sxs-lookup"><span data-stu-id="9a13f-126">One is impersonation from a Windows token obtained from the Security Support Provider Interface (SSPI) or Kerberos authentication, which is then cached on the service.</span></span> <span data-ttu-id="9a13f-127">두 번째 방법은 통칭 *S4U* (Service-for-User)라고 알려진 Kerberos 확장에서 가져온 Windows 토큰을 통한 가장입니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-127">The second is impersonation from a Windows token obtained from the Kerberos extensions, collectively called *Service-for-User* (S4U).</span></span>  
  
### <a name="cached-token-impersonation"></a><span data-ttu-id="9a13f-128">캐시된 토큰 가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-128">Cached Token Impersonation</span></span>  
 <span data-ttu-id="9a13f-129">다음과 같은 바인딩을 통해 캐시된 토큰 가장을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-129">You can perform cached-token impersonation with the following:</span></span>  
  
- <span data-ttu-id="9a13f-130">Windows 클라이언트 자격 증명이 있는<xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>및 <xref:System.ServiceModel.NetTcpBinding></span><span class="sxs-lookup"><span data-stu-id="9a13f-130"><xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a Windows client credential.</span></span>  
  
- <span data-ttu-id="9a13f-131"><xref:System.ServiceModel.BasicHttpBinding> 가 <xref:System.ServiceModel.BasicHttpSecurityMode> 자격 증명으로 설정된 <xref:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential> 또는 서비스를 통해 올바른 Windows 계정으로 매핑할 수 있는 사용자 이름 자격 증명을 클라이언트에서 제공하는 기타 표준 바인딩</span><span class="sxs-lookup"><span data-stu-id="9a13f-131"><xref:System.ServiceModel.BasicHttpBinding> with a <xref:System.ServiceModel.BasicHttpSecurityMode> set to the <xref:System.ServiceModel.BasicHttpSecurityMode.TransportWithMessageCredential> credential, or any other standard binding where the client presents a user name credential that the service can map to a valid Windows account.</span></span>  
  
- <span data-ttu-id="9a13f-132"><xref:System.ServiceModel.Channels.CustomBinding> 속성이 `requireCancellation` 로 설정된 Windows 클라이언트 자격 증명을 사용하는 모든 `true`.</span><span class="sxs-lookup"><span data-stu-id="9a13f-132">Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` set to `true`.</span></span> <span data-ttu-id="9a13f-133">속성은, 및 클래스에서 사용할 수 있습니다 <xref:System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters> <xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters> <xref:System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters> . 바인딩에 보안 대화가 사용 되는 경우 `requireCancellation` 에도 속성이로 설정 되어야 합니다 `true` .</span><span class="sxs-lookup"><span data-stu-id="9a13f-133">(The property is available on the following classes: <xref:System.ServiceModel.Security.Tokens.SecureConversationSecurityTokenParameters>, <xref:System.ServiceModel.Security.Tokens.SslSecurityTokenParameters>, and <xref:System.ServiceModel.Security.Tokens.SspiSecurityTokenParameters>.) If a secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`.</span></span>  
  
- <span data-ttu-id="9a13f-134">클라이언트에서 사용자 이름 자격 증명을 제공하는 <xref:System.ServiceModel.Channels.CustomBinding> .</span><span class="sxs-lookup"><span data-stu-id="9a13f-134">Any <xref:System.ServiceModel.Channels.CustomBinding> where the client presents a user name credential.</span></span> <span data-ttu-id="9a13f-135">바인딩에 보안 대화가 사용되는 경우에도 `requireCancellation` 속성이 `true`로 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-135">If secure conversation is used on the binding, it must also have the `requireCancellation` property set to `true`.</span></span>  
  
### <a name="s4u-based-impersonation"></a><span data-ttu-id="9a13f-136">S4U 기반 가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-136">S4U-Based Impersonation</span></span>  
 <span data-ttu-id="9a13f-137">다음과 같은 바인딩을 통해 S4U 기반 가장을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-137">You can perform S4U-based impersonation with the following:</span></span>  
  
- <span data-ttu-id="9a13f-138">서비스를 통해 올바른Windows 계정으로 매핑될 수 있는 인증서 클라이언트 자격 증명을 가진<xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>및 <xref:System.ServiceModel.NetTcpBinding></span><span class="sxs-lookup"><span data-stu-id="9a13f-138"><xref:System.ServiceModel.WSHttpBinding>, <xref:System.ServiceModel.WSDualHttpBinding>, and <xref:System.ServiceModel.NetTcpBinding> with a certificate client credential that the service can map to a valid Windows account.</span></span>  
  
- <span data-ttu-id="9a13f-139"><xref:System.ServiceModel.Channels.CustomBinding> 속성이 `requireCancellation` 로 설정된 Windows 클라이언트 자격 증명을 사용하는 `false`</span><span class="sxs-lookup"><span data-stu-id="9a13f-139">Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a Windows client credential with the `requireCancellation` property set to `false`.</span></span>  
  
- <span data-ttu-id="9a13f-140"><xref:System.ServiceModel.Channels.CustomBinding> 속성이 `requireCancellation` 로 설정된 보안 대화 및 Windows 클라이언트 자격 증명 또는 사용자 이름을 사용하는 `false`</span><span class="sxs-lookup"><span data-stu-id="9a13f-140">Any <xref:System.ServiceModel.Channels.CustomBinding> that uses a user name or Windows client credential and secure conversation with the `requireCancellation` property set to `false`.</span></span>  
  
 <span data-ttu-id="9a13f-141">서비스를 통해 클라이언트를 가장할 수 있는 범위는 서비스를 통해 가장을 시도할 때의 서비스 계정 권한, 사용되는 가장 형식 및 클라이언트에서 허용하는 가장 범위에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-141">The extent to which the service can impersonate the client depends on the privileges the service account holds when it attempts impersonation, the type of impersonation used, and possibly the extent of impersonation the client permits.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-142">클라이언트 및 서비스가 동일한 컴퓨터에서 실행 중이고 클라이언트가 시스템 계정(예: `Local System` 또는 `Network Service`)으로 실행 중인 경우, 상태 저장 보안 컨텍스트 토큰을 사용하여 보안 세션을 설정할 때 클라이언트를 가장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-142">When the client and service are running on the same computer and the client is running under a system account (for example, `Local System` or `Network Service`), the client cannot be impersonated when a secure session is established with stateful Security Context tokens.</span></span> <span data-ttu-id="9a13f-143">일반적으로 Windows Form 또는 콘솔 애플리케이션은 현재 계정에 로그인된 상태에서 실행되기 때문에 기본적으로 계정을 가장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-143">A Windows Form or console application typically runs under the currently logged-in account, so that account can be impersonated by default.</span></span> <span data-ttu-id="9a13f-144">그러나 클라이언트가 ASP.NET 페이지이 고 해당 페이지가 IIS 6.0 또는 IIS 7.0에서 호스트 되는 경우 클라이언트는 `Network Service` 기본적으로 계정으로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-144">However, when the client is an ASP.NET page and that page is hosted in IIS 6.0 or IIS 7.0, then the client does run under the `Network Service` account by default.</span></span> <span data-ttu-id="9a13f-145">보안 세션을 지원하는 모든 시스템 제공 바인딩은 기본적으로 상태 비저장 SCT(보안 컨텍스트 토큰)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-145">All of the system-provided bindings that support secure sessions use a stateless security context token (SCT) by default.</span></span> <span data-ttu-id="9a13f-146">그러나 클라이언트가 ASP.NET 페이지이 고 상태 저장 Sct을 사용 하는 보안 세션을 사용 하는 경우 클라이언트를 가장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-146">However, if the client is an ASP.NET page, and secure sessions with stateful SCTs are used, the client cannot be impersonated.</span></span> <span data-ttu-id="9a13f-147">보안 세션에서 상태 저장 Sct를 사용 하는 방법에 대 한 자세한 내용은 [방법: 보안 세션에 대 한 보안 컨텍스트 토큰 만들기](how-to-create-a-security-context-token-for-a-secure-session.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9a13f-147">For more information about using stateful SCTs in a secure session, see [How to: Create a Security Context Token for a Secure Session](how-to-create-a-security-context-token-for-a-secure-session.md).</span></span>  
  
## <a name="impersonation-in-a-service-method-declarative-model"></a><span data-ttu-id="9a13f-148">서비스 메서드에서의 가장: 선언적 모델</span><span class="sxs-lookup"><span data-stu-id="9a13f-148">Impersonation in a Service Method: Declarative Model</span></span>  
 <span data-ttu-id="9a13f-149">대부분의 가장 시나리오의 경우 호출자 컨텍스트에서 서비스 메서드를 실행하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-149">Most impersonation scenarios involve executing the service method in the caller context.</span></span> <span data-ttu-id="9a13f-150">WCF는 사용자가 특성에 가장 요구 사항을 지정할 수 있도록 하 여이 작업을 쉽게 수행할 수 있게 해 주는 가장 기능을 제공 합니다 <xref:System.ServiceModel.OperationBehaviorAttribute> .</span><span class="sxs-lookup"><span data-stu-id="9a13f-150">WCF provides an impersonation feature that makes this easy to do by allowing the user to specify the impersonation requirement in the <xref:System.ServiceModel.OperationBehaviorAttribute> attribute.</span></span> <span data-ttu-id="9a13f-151">예를 들어 다음 코드에서 WCF 인프라는 메서드를 실행 하기 전에 호출자를 가장 합니다 `Hello` .</span><span class="sxs-lookup"><span data-stu-id="9a13f-151">For example, in the following code, the WCF infrastructure impersonates the caller before executing the `Hello` method.</span></span> <span data-ttu-id="9a13f-152">`Hello` 메서드 내의 네이티브 리소스에 대한 액세스 시도는 이 리소스의 ACL(액세스 제어 목록)에서 호출자 액세스 권한을 허용하는 경우에만 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-152">Any attempt to access native resources inside the `Hello` method succeed only if the access control list (ACL) of the resource allows the caller access privileges.</span></span> <span data-ttu-id="9a13f-153">가장을 가능하게 하려면, 다음 예제에서와 같이 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> 속성을 <xref:System.ServiceModel.ImpersonationOption> 열거형 값인 <xref:System.ServiceModel.ImpersonationOption.Required?displayProperty=nameWithType> 또는 <xref:System.ServiceModel.ImpersonationOption.Allowed?displayProperty=nameWithType>중 하나로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-153">To enable impersonation, set the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property to one of the <xref:System.ServiceModel.ImpersonationOption> enumeration values, either <xref:System.ServiceModel.ImpersonationOption.Required?displayProperty=nameWithType> or <xref:System.ServiceModel.ImpersonationOption.Allowed?displayProperty=nameWithType>, as shown in the following example.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-154">서비스의 자격 증명 권한이 원격 클라이언트의 자격 증명보다 더 높을 때 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> 속성이 <xref:System.ServiceModel.ImpersonationOption.Allowed>로 설정되어 있으면 서비스의 자격 증명이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-154">When a service has higher credentials than the remote client, the credentials of the service are used if the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.Allowed>.</span></span> <span data-ttu-id="9a13f-155">즉, 권한이 낮은 사용자가 자격 증명을 제공하면 권한이 더 높은 서비스에서 서비스의 자격 증명으로 메서드를 실행하여, 권한이 낮은 사용자가 일반적으로 사용할 수 없는 리소스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-155">That is, if a low-privileged user provides its credentials, a higher-privileged service executes the method with the credentials of the service, and can use resources that the low-privileged user would otherwise not be able to use.</span></span>  
  
 [!code-csharp[c_ImpersonationAndDelegation#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#1)]
 [!code-vb[c_ImpersonationAndDelegation#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#1)]  
  
 <span data-ttu-id="9a13f-156">WCF 인프라는 호출자가 Windows 사용자 계정에 매핑될 수 있는 자격 증명으로 인증 된 경우에만 호출자를 가장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-156">The WCF infrastructure can impersonate the caller only if the caller is authenticated with credentials that can be mapped to a Windows user account.</span></span> <span data-ttu-id="9a13f-157">Windows 계정에 매핑될 수 없는 자격 증명을 통해 인증하도록 서비스를 구성한 경우에는 서비스 메서드가 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-157">If the service is configured to authenticate using a credential that cannot be mapped to a Windows account, the service method is not executed.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-158">Windows XP의 경우 상태 저장 SCT가 만들어지면 가장이 실패 하 여이 발생 <xref:System.InvalidOperationException> 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-158">On Windows XP, impersonation fails if a stateful SCT is created, resulting in an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="9a13f-159">자세한 내용은 [지원 되지 않는 시나리오](unsupported-scenarios.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-159">For more information, see [Unsupported Scenarios](unsupported-scenarios.md).</span></span>  
  
## <a name="impersonation-in-a-service-method-imperative-model"></a><span data-ttu-id="9a13f-160">서비스 메서드에서의 가장: 명령적 모델</span><span class="sxs-lookup"><span data-stu-id="9a13f-160">Impersonation in a Service Method: Imperative Model</span></span>  
 <span data-ttu-id="9a13f-161">작동하는 전체 서비스 메서드가 아닌 그 중 일부만 호출자가 가장해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-161">Sometimes a caller does not need to impersonate the entire service method to function, but for only a portion of it.</span></span> <span data-ttu-id="9a13f-162">이 경우에는 서비스 메서드 내의 호출자 Windows ID를 가져와 명령적 방식으로 가장을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-162">In this case, obtain the Windows identity of the caller inside the service method and imperatively perform the impersonation.</span></span> <span data-ttu-id="9a13f-163">이 작업은 <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A> 클래스의 인스턴스를 반환하도록 <xref:System.ServiceModel.ServiceSecurityContext> 의 <xref:System.Security.Principal.WindowsIdentity> 속성을 사용하고 해당 인스턴스를 사용하기 전에 <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> 메서드를 호출하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-163">Do this by using the <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A> property of the <xref:System.ServiceModel.ServiceSecurityContext> to return an instance of the <xref:System.Security.Principal.WindowsIdentity> class and calling the <xref:System.Security.Principal.WindowsIdentity.Impersonate%2A> method before using the instance.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-164">`Using`가장 동작을 자동으로 되돌리려면 Visual Basic 문이나 c # `using` 문을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-164">Be sure to use the Visual Basic`Using` statement or the C# `using` statement to automatically revert the impersonation action.</span></span> <span data-ttu-id="9a13f-165">문을 사용 하지 않거나 Visual Basic 또는 c # 이외의 프로그래밍 언어를 사용 하는 경우 가장 수준을 되돌려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-165">If you do not use the statement, or if you use a programming language other than Visual Basic or C#, be sure to revert the impersonation level.</span></span> <span data-ttu-id="9a13f-166">이 작업에 실패하면 서비스 거부 및 권한 상승 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-166">Failure to do this can form the basis for denial of service and elevation of privilege attacks.</span></span>  
  
 [!code-csharp[c_ImpersonationAndDelegation#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#2)]
 [!code-vb[c_ImpersonationAndDelegation#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#2)]  
  
## <a name="impersonation-for-all-service-methods"></a><span data-ttu-id="9a13f-167">모든 서비스 메서드에 대한 가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-167">Impersonation for All Service Methods</span></span>  
 <span data-ttu-id="9a13f-168">서비스의 모든 메서드를 호출자의 컨텍스트에서 수행해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-168">In some cases, you must perform all the methods of a service in the caller’s context.</span></span> <span data-ttu-id="9a13f-169">이 경우 메서드별로 이 기능을 명시적으로 활성화하는 대신 <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-169">Instead of explicitly enabling this feature on a per-method basis, use the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>.</span></span> <span data-ttu-id="9a13f-170">다음 코드에서처럼 <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A> 속성을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-170">As shown in the following code, set the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A> property to `true`.</span></span> <span data-ttu-id="9a13f-171"><xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> 는 <xref:System.ServiceModel.ServiceHost> 클래스의 동작 컬렉션에서 검색됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-171">The <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> is retrieved from the collections of behaviors of the <xref:System.ServiceModel.ServiceHost> class.</span></span> <span data-ttu-id="9a13f-172">또한 각 메서드에 적용되는 `Impersonation` 의 <xref:System.ServiceModel.OperationBehaviorAttribute> 속성도 <xref:System.ServiceModel.ImpersonationOption.Allowed> 또는 <xref:System.ServiceModel.ImpersonationOption.Required>중 하나로 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-172">Also note that the `Impersonation` property of the <xref:System.ServiceModel.OperationBehaviorAttribute> applied to each method must also be set to either <xref:System.ServiceModel.ImpersonationOption.Allowed> or <xref:System.ServiceModel.ImpersonationOption.Required>.</span></span>  
  
 [!code-csharp[c_ImpersonationAndDelegation#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#3)]
 [!code-vb[c_ImpersonationAndDelegation#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#3)]  
  
 <span data-ttu-id="9a13f-173">다음 표에서는 및의 모든 가능한 조합에 대 한 WCF 동작을 설명 합니다 `ImpersonationOption` `ImpersonateCallerForAllServiceOperations` .</span><span class="sxs-lookup"><span data-stu-id="9a13f-173">The following table describes WCF behavior for all possible combinations of `ImpersonationOption` and `ImpersonateCallerForAllServiceOperations`.</span></span>  
  
|`ImpersonationOption`|`ImpersonateCallerForAllServiceOperations`|<span data-ttu-id="9a13f-174">동작</span><span class="sxs-lookup"><span data-stu-id="9a13f-174">Behavior</span></span>|  
|---------------------------|------------------------------------------------|--------------|  
|<span data-ttu-id="9a13f-175">필수</span><span class="sxs-lookup"><span data-stu-id="9a13f-175">Required</span></span>|<span data-ttu-id="9a13f-176">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-176">n/a</span></span>|<span data-ttu-id="9a13f-177">WCF는 호출자를 가장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-177">WCF impersonates the caller</span></span>|  
|<span data-ttu-id="9a13f-178">허용됨</span><span class="sxs-lookup"><span data-stu-id="9a13f-178">Allowed</span></span>|<span data-ttu-id="9a13f-179">false</span><span class="sxs-lookup"><span data-stu-id="9a13f-179">false</span></span>|<span data-ttu-id="9a13f-180">WCF는 호출자를 가장 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-180">WCF does not impersonate the caller</span></span>|  
|<span data-ttu-id="9a13f-181">허용됨</span><span class="sxs-lookup"><span data-stu-id="9a13f-181">Allowed</span></span>|<span data-ttu-id="9a13f-182">true</span><span class="sxs-lookup"><span data-stu-id="9a13f-182">true</span></span>|<span data-ttu-id="9a13f-183">WCF는 호출자를 가장 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-183">WCF impersonates the caller</span></span>|  
|<span data-ttu-id="9a13f-184">NotAllowed</span><span class="sxs-lookup"><span data-stu-id="9a13f-184">NotAllowed</span></span>|<span data-ttu-id="9a13f-185">false</span><span class="sxs-lookup"><span data-stu-id="9a13f-185">false</span></span>|<span data-ttu-id="9a13f-186">WCF는 호출자를 가장 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-186">WCF does not impersonate the caller</span></span>|  
|<span data-ttu-id="9a13f-187">NotAllowed</span><span class="sxs-lookup"><span data-stu-id="9a13f-187">NotAllowed</span></span>|<span data-ttu-id="9a13f-188">true</span><span class="sxs-lookup"><span data-stu-id="9a13f-188">true</span></span>|<span data-ttu-id="9a13f-189">허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-189">Disallowed.</span></span> <span data-ttu-id="9a13f-190"><xref:System.InvalidOperationException> 이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-190">(An <xref:System.InvalidOperationException> is thrown.)</span></span>|  
  
## <a name="impersonation-level-obtained-from-windows-credentials-and-cached-token-impersonation"></a><span data-ttu-id="9a13f-191">Windows 자격 증명 및 캐시된 토큰 가장에서 가져온 가장 수준</span><span class="sxs-lookup"><span data-stu-id="9a13f-191">Impersonation Level Obtained from Windows Credentials and Cached Token Impersonation</span></span>  
 <span data-ttu-id="9a13f-192">일부 시나리오에서는 Windows 클라이언트 자격 증명이 사용될 때 서비스에서 수행하는 가장 수준을 클라이언트에서 부분적으로 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-192">In some scenarios the client has partial control over the level of impersonation the service performs when a Windows client credential is used.</span></span> <span data-ttu-id="9a13f-193">클라이언트가 익명 가장 수준을 지정하는 경우 또는</span><span class="sxs-lookup"><span data-stu-id="9a13f-193">One scenario occurs when the client specifies an Anonymous impersonation level.</span></span> <span data-ttu-id="9a13f-194">캐시된 토큰으로 가장을 수행하는 경우가 해당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-194">The other occurs when performing impersonation with a cached token.</span></span> <span data-ttu-id="9a13f-195">이 작업은 제네릭 <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> 클래스의 속성으로 액세스되는 <xref:System.ServiceModel.Security.WindowsClientCredential> 클래스의 <xref:System.ServiceModel.ChannelFactory%601> 속성을 설정하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-195">This is done by setting the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property of the <xref:System.ServiceModel.Security.WindowsClientCredential> class, which is accessed as a property of the generic <xref:System.ServiceModel.ChannelFactory%601> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-196">가장 수준을 익명으로 지정하면 클라이언트가 익명으로 서비스에 로그온됩니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-196">Specifying an impersonation level of Anonymous causes the client to log on to the service anonymously.</span></span> <span data-ttu-id="9a13f-197">따라서 서비스에서는 가장 수행 여부와 상관없이 익명 로그온을 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-197">The service must therefore allow anonymous logons, regardless of whether impersonation is performed.</span></span>  
  
 <span data-ttu-id="9a13f-198">클라이언트에서는 가장 수준을 <xref:System.Security.Principal.TokenImpersonationLevel.Anonymous>, <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>또는 <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-198">The client can specify the impersonation level as <xref:System.Security.Principal.TokenImpersonationLevel.Anonymous>, <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, or <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>.</span></span> <span data-ttu-id="9a13f-199">다음 코드에서처럼 지정된 수준의 토큰만이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-199">Only a token at the specified level is produced, as shown in the following code.</span></span>  
  
 [!code-csharp[c_ImpersonationAndDelegation#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_impersonationanddelegation/cs/source.cs#4)]
 [!code-vb[c_ImpersonationAndDelegation#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_impersonationanddelegation/vb/source.vb#4)]  
  
 <span data-ttu-id="9a13f-200">다음 표에는 캐시된 토큰을 통해 가장할 때 서비스를 통해 가져오는 가장 수준이 지정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-200">The following table specifies the impersonation level the service obtains when impersonating from a cached token.</span></span>  
  
|<span data-ttu-id="9a13f-201">`AllowedImpersonationLevel` 값</span><span class="sxs-lookup"><span data-stu-id="9a13f-201">`AllowedImpersonationLevel` value</span></span>|<span data-ttu-id="9a13f-202">서비스의 `SeImpersonatePrivilege`포함 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-202">Service has `SeImpersonatePrivilege`</span></span>|<span data-ttu-id="9a13f-203">서비스와 클라이언트의 위임 가능 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-203">Service and client are capable of delegation</span></span>|<span data-ttu-id="9a13f-204">캐시된 토큰 `ImpersonationLevel`</span><span class="sxs-lookup"><span data-stu-id="9a13f-204">Cached token `ImpersonationLevel`</span></span>|  
|---------------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  
|<span data-ttu-id="9a13f-205">익명</span><span class="sxs-lookup"><span data-stu-id="9a13f-205">Anonymous</span></span>|<span data-ttu-id="9a13f-206">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-206">Yes</span></span>|<span data-ttu-id="9a13f-207">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-207">n/a</span></span>|<span data-ttu-id="9a13f-208">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-208">Impersonation</span></span>|  
|<span data-ttu-id="9a13f-209">익명</span><span class="sxs-lookup"><span data-stu-id="9a13f-209">Anonymous</span></span>|<span data-ttu-id="9a13f-210">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-210">No</span></span>|<span data-ttu-id="9a13f-211">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-211">n/a</span></span>|<span data-ttu-id="9a13f-212">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-212">Identification</span></span>|  
|<span data-ttu-id="9a13f-213">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-213">Identification</span></span>|<span data-ttu-id="9a13f-214">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-214">n/a</span></span>|<span data-ttu-id="9a13f-215">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-215">n/a</span></span>|<span data-ttu-id="9a13f-216">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-216">Identification</span></span>|  
|<span data-ttu-id="9a13f-217">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-217">Impersonation</span></span>|<span data-ttu-id="9a13f-218">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-218">Yes</span></span>|<span data-ttu-id="9a13f-219">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-219">n/a</span></span>|<span data-ttu-id="9a13f-220">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-220">Impersonation</span></span>|  
|<span data-ttu-id="9a13f-221">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-221">Impersonation</span></span>|<span data-ttu-id="9a13f-222">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-222">No</span></span>|<span data-ttu-id="9a13f-223">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-223">n/a</span></span>|<span data-ttu-id="9a13f-224">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-224">Identification</span></span>|  
|<span data-ttu-id="9a13f-225">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-225">Delegation</span></span>|<span data-ttu-id="9a13f-226">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-226">Yes</span></span>|<span data-ttu-id="9a13f-227">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-227">Yes</span></span>|<span data-ttu-id="9a13f-228">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-228">Delegation</span></span>|  
|<span data-ttu-id="9a13f-229">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-229">Delegation</span></span>|<span data-ttu-id="9a13f-230">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-230">Yes</span></span>|<span data-ttu-id="9a13f-231">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-231">No</span></span>|<span data-ttu-id="9a13f-232">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-232">Impersonation</span></span>|  
|<span data-ttu-id="9a13f-233">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-233">Delegation</span></span>|<span data-ttu-id="9a13f-234">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-234">No</span></span>|<span data-ttu-id="9a13f-235">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-235">n/a</span></span>|<span data-ttu-id="9a13f-236">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-236">Identification</span></span>|  
  
## <a name="impersonation-level-obtained-from-user-name-credentials-and-cached-token-impersonation"></a><span data-ttu-id="9a13f-237">사용자 이름 자격 증명 및 캐시된 토큰 가장에서 가져온 가장 수준</span><span class="sxs-lookup"><span data-stu-id="9a13f-237">Impersonation Level Obtained from User Name Credentials and Cached Token Impersonation</span></span>  
 <span data-ttu-id="9a13f-238">클라이언트는 서비스의 사용자 이름 및 암호를 전달 하 여 WCF에서 해당 사용자로 로그온 할 수 있게 합니다. 즉, 속성을로 설정 하는 것과 같습니다 `AllowedImpersonationLevel` <xref:System.Security.Principal.TokenImpersonationLevel.Delegation> .</span><span class="sxs-lookup"><span data-stu-id="9a13f-238">By passing the service its user name and password, a client enables WCF to log on as that user, which is equivalent to setting the `AllowedImpersonationLevel` property to <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>.</span></span> <span data-ttu-id="9a13f-239">는 `AllowedImpersonationLevel` 및 클래스에서 사용할 수 <xref:System.ServiceModel.Security.WindowsClientCredential> <xref:System.ServiceModel.Security.HttpDigestClientCredential> 있습니다. 다음 표에는 서비스에서 사용자 이름 자격 증명을 받을 때 획득 한 가장 수준이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-239">(The `AllowedImpersonationLevel` is available on the <xref:System.ServiceModel.Security.WindowsClientCredential> and <xref:System.ServiceModel.Security.HttpDigestClientCredential> classes.) The following table provides the impersonation level obtained when the service receives user name credentials.</span></span>  
  
|`AllowedImpersonationLevel`|<span data-ttu-id="9a13f-240">서비스의 `SeImpersonatePrivilege`포함 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-240">Service has `SeImpersonatePrivilege`</span></span>|<span data-ttu-id="9a13f-241">서비스와 클라이언트의 위임 가능 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-241">Service and client are capable of delegation</span></span>|<span data-ttu-id="9a13f-242">캐시된 토큰 `ImpersonationLevel`</span><span class="sxs-lookup"><span data-stu-id="9a13f-242">Cached token `ImpersonationLevel`</span></span>|  
|---------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  
|<span data-ttu-id="9a13f-243">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-243">n/a</span></span>|<span data-ttu-id="9a13f-244">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-244">Yes</span></span>|<span data-ttu-id="9a13f-245">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-245">Yes</span></span>|<span data-ttu-id="9a13f-246">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-246">Delegation</span></span>|  
|<span data-ttu-id="9a13f-247">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-247">n/a</span></span>|<span data-ttu-id="9a13f-248">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-248">Yes</span></span>|<span data-ttu-id="9a13f-249">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-249">No</span></span>|<span data-ttu-id="9a13f-250">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-250">Impersonation</span></span>|  
|<span data-ttu-id="9a13f-251">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-251">n/a</span></span>|<span data-ttu-id="9a13f-252">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-252">No</span></span>|<span data-ttu-id="9a13f-253">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-253">n/a</span></span>|<span data-ttu-id="9a13f-254">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-254">Identification</span></span>|  
  
## <a name="impersonation-level-obtained-from-s4u-based-impersonation"></a><span data-ttu-id="9a13f-255">S4U 기반 가장에서 가져온 가장 수준</span><span class="sxs-lookup"><span data-stu-id="9a13f-255">Impersonation Level Obtained from S4U-Based Impersonation</span></span>  
  
|<span data-ttu-id="9a13f-256">서비스의 `SeTcbPrivilege`포함 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-256">Service has `SeTcbPrivilege`</span></span>|<span data-ttu-id="9a13f-257">서비스의 `SeImpersonatePrivilege`포함 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-257">Service has `SeImpersonatePrivilege`</span></span>|<span data-ttu-id="9a13f-258">서비스와 클라이언트의 위임 가능 여부</span><span class="sxs-lookup"><span data-stu-id="9a13f-258">Service and client are capable of delegation</span></span>|<span data-ttu-id="9a13f-259">캐시된 토큰 `ImpersonationLevel`</span><span class="sxs-lookup"><span data-stu-id="9a13f-259">Cached token `ImpersonationLevel`</span></span>|  
|----------------------------------|------------------------------------------|--------------------------------------------------|---------------------------------------|  
|<span data-ttu-id="9a13f-260">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-260">Yes</span></span>|<span data-ttu-id="9a13f-261">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-261">Yes</span></span>|<span data-ttu-id="9a13f-262">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-262">n/a</span></span>|<span data-ttu-id="9a13f-263">가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-263">Impersonation</span></span>|  
|<span data-ttu-id="9a13f-264">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-264">Yes</span></span>|<span data-ttu-id="9a13f-265">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-265">No</span></span>|<span data-ttu-id="9a13f-266">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-266">n/a</span></span>|<span data-ttu-id="9a13f-267">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-267">Identification</span></span>|  
|<span data-ttu-id="9a13f-268">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-268">No</span></span>|<span data-ttu-id="9a13f-269">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-269">n/a</span></span>|<span data-ttu-id="9a13f-270">해당 없음</span><span class="sxs-lookup"><span data-stu-id="9a13f-270">n/a</span></span>|<span data-ttu-id="9a13f-271">Identification(식별)</span><span class="sxs-lookup"><span data-stu-id="9a13f-271">Identification</span></span>|  
  
## <a name="mapping-a-client-certificate-to-a-windows-account"></a><span data-ttu-id="9a13f-272">Windows 계정에 클라이언트 인증서 매핑</span><span class="sxs-lookup"><span data-stu-id="9a13f-272">Mapping a Client Certificate to a Windows Account</span></span>  
 <span data-ttu-id="9a13f-273">클라이언트가 인증서를 사용하여 자신을 서비스에 인증하고 서비스에서 Active Directory를 통해 클라이언트를 기존 계정에 매핑하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-273">It is possible for a client to authenticate itself to a service using a certificate, and to have the service map the client to an existing account through Active Directory.</span></span> <span data-ttu-id="9a13f-274">다음 XML에서는 인증서를 매핑하도록 서비스를 구성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-274">The following XML shows how to configure the service to map the certificate.</span></span>  
  
```xml  
<behaviors>  
  <serviceBehaviors>  
    <behavior name="MapToWindowsAccount">  
      <serviceCredentials>  
        <clientCertificate>  
          <authentication mapClientCertificateToWindowsAccount="true" />  
        </clientCertificate>  
      </serviceCredentials>  
    </behavior>  
  </serviceBehaviors>  
</behaviors>  
```  
  
 <span data-ttu-id="9a13f-275">다음 코드에서는 서비스를 구성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-275">The following code shows how to configure the service.</span></span>  
  
```csharp
// Create a binding that sets a certificate as the client credential type.  
WSHttpBinding b = new WSHttpBinding();  
b.Security.Message.ClientCredentialType = MessageCredentialType.Certificate;  
  
// Create a service host that maps the certificate to a Windows account.  
Uri httpUri = new Uri("http://localhost/Calculator");  
ServiceHost sh = new ServiceHost(typeof(HelloService), httpUri);  
sh.Credentials.ClientCertificate.Authentication.MapClientCertificateToWindowsAccount = true;  
```  
  
## <a name="delegation"></a><span data-ttu-id="9a13f-276">위임</span><span class="sxs-lookup"><span data-stu-id="9a13f-276">Delegation</span></span>  
 <span data-ttu-id="9a13f-277">백 엔드 서비스에 위임하려면 서비스에서는 클라이언트 Windows ID를 사용하여 백 엔드 서비스에 대해 Kerberos multi-leg(NTLM 대체(fallback) 없는 SSPI) 인증 또는 Kerberos 직접 인증을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-277">To delegate to a back-end service, a service must perform Kerberos multi-leg (SSPI without NTLM fallback) or Kerberos direct authentication to the back-end service using the client’s Windows identity.</span></span> <span data-ttu-id="9a13f-278">백 엔드 서비스에 위임하기 위해 <xref:System.ServiceModel.ChannelFactory%601> 및 채널을 만든 다음 클라이언트를 가장하는 동안 채널을 통해 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-278">To delegate to a back-end service, create a <xref:System.ServiceModel.ChannelFactory%601> and a channel, and then communicate through the channel while impersonating the client.</span></span> <span data-ttu-id="9a13f-279">이 형식의 위임을 사용하는 경우 프런트 엔드 서비스에서 백 엔드 서비스가 위치할 수 있는 범위는 프런트 엔드 서비스에서 수행한 가장 수준에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-279">With this form of delegation, the distance at which the back-end service can be located from the front-end service depends on the impersonation level achieved by the front-end service.</span></span> <span data-ttu-id="9a13f-280">가장 수준이 <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>인 경우 프런트 엔드 및 백 엔드 서비스는 동일한 시스템에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-280">When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>, the front-end and back-end services must be running on the same machine.</span></span> <span data-ttu-id="9a13f-281">가장 수준이 <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>인 경우 프런트 엔드 및 백 엔드 서비스는 개별 시스템 또는 동일한 시스템에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-281">When the impersonation level is <xref:System.Security.Principal.TokenImpersonationLevel.Delegation>, the front-end and back-end services can be on separate machines or on the same machine.</span></span> <span data-ttu-id="9a13f-282">위임 수준 가장을 사용하려면 위임을 허용하도록 Windows 도메인 정책을 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-282">Enabling delegation-level impersonation requires that Windows domain policy be configured to permit delegation.</span></span> <span data-ttu-id="9a13f-283">위임 지원을 위한 Active Directory 구성에 대한 자세한 내용은 [Enabling Delegated Authentication](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc780217(v=ws.10))을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9a13f-283">For more information about configuring Active Directory for delegation support, see [Enabling Delegated Authentication](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc780217(v=ws.10)).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9a13f-284">클라이언트가 백 엔드 서비스의 Windows 계정에 해당하는 사용자 이름 및 암호를 사용하여 프런트 엔드 서비스를 인증하는 경우 프런트 엔드 서비스는 해당 클라이언트의 사용자 이름과 암호를 다시 사용하여 백 엔드 서비스를 인증할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-284">When a client authenticates to the front-end service using a user name and password that correspond to a Windows account on the back-end service, the front-end service can authenticate to the back-end service by reusing the client’s user name and password.</span></span> <span data-ttu-id="9a13f-285">사용자 이름과 암호를 백 엔드 서비스에 전달하면 백 엔드 서비스가 가장을 수행할 수 있으므로 이 방식은 매우 유용한 ID 전달 방식이지만 Kerberos를 사용하지 않기 때문에 위임을 구성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-285">This is a particularly powerful form of identity flow, because passing user name and password to the back-end service enables the back-end service to perform impersonation, but it does not constitute delegation because Kerberos is not used.</span></span> <span data-ttu-id="9a13f-286">위임에 대한 Active Directory 제어는 사용자 이름 및 암호 인증에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-286">Active Directory controls on delegation do not apply to user name and password authentication.</span></span>  
  
### <a name="delegation-ability-as-a-function-of-impersonation-level"></a><span data-ttu-id="9a13f-287">가장 수준에 따른 위임 기능</span><span class="sxs-lookup"><span data-stu-id="9a13f-287">Delegation Ability as a Function of Impersonation Level</span></span>  
  
|<span data-ttu-id="9a13f-288">가장 수준</span><span class="sxs-lookup"><span data-stu-id="9a13f-288">Impersonation level</span></span>|<span data-ttu-id="9a13f-289">서비스에서 프로세스 간 위임을 수행할 수 있음</span><span class="sxs-lookup"><span data-stu-id="9a13f-289">Service can perform cross-process delegation</span></span>|<span data-ttu-id="9a13f-290">서비스에서 시스템 간 위임을 수행할 수 있음</span><span class="sxs-lookup"><span data-stu-id="9a13f-290">Service can perform cross-machine delegation</span></span>|  
|-------------------------|---------------------------------------------------|---------------------------------------------------|  
|<xref:System.Security.Principal.TokenImpersonationLevel.Identification>|<span data-ttu-id="9a13f-291">아니요</span><span class="sxs-lookup"><span data-stu-id="9a13f-291">No</span></span>|<span data-ttu-id="9a13f-292">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-292">No</span></span>|  
|<xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>|<span data-ttu-id="9a13f-293">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-293">Yes</span></span>|<span data-ttu-id="9a13f-294">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-294">No</span></span>|  
|<xref:System.Security.Principal.TokenImpersonationLevel.Delegation>|<span data-ttu-id="9a13f-295">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-295">Yes</span></span>|<span data-ttu-id="9a13f-296">예</span><span class="sxs-lookup"><span data-stu-id="9a13f-296">Yes</span></span>|  
  
 <span data-ttu-id="9a13f-297">다음 코드 예제에서는 위임을 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-297">The following code example demonstrates how to use delegation.</span></span>  
  
 [!code-csharp[c_delegation#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_delegation/cs/source.cs#1)]
 [!code-vb[c_delegation#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_delegation/vb/source.vb#1)]  
  
### <a name="how-to-configure-an-application-to-use-constrained-delegation"></a><span data-ttu-id="9a13f-298">한정된 위임을 사용하도록 애플리케이션을 구성하는 방법</span><span class="sxs-lookup"><span data-stu-id="9a13f-298">How to Configure an Application to Use Constrained Delegation</span></span>  
 <span data-ttu-id="9a13f-299">한정된 위임을 사용하기 전에 발신자, 수신자 및 도메인 컨트롤러는 한정된 위임을 사용하도록 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-299">Before you can use constrained delegation, the sender, receiver, and the domain controller must be configured to do so.</span></span> <span data-ttu-id="9a13f-300">다음 절차에서는 한정된 위임을 사용하는 단계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-300">The following procedure lists the steps that enable constrained delegation.</span></span> <span data-ttu-id="9a13f-301">위임과 한정된 위임의 차이에 대한 자세한 내용은 간략하게 설명된 [Windows Server 2003 Kerberos Extensions](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc738207(v=ws.10)) 부분을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="9a13f-301">For details about the differences between delegation and constrained delegation, see the portion of [Windows Server 2003 Kerberos Extensions](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc738207(v=ws.10)) that discusses constrained discussion.</span></span>  
  
1. <span data-ttu-id="9a13f-302">도메인 컨트롤러에서 클라이언트 애플리케이션이 실행 중인 계정에 대해 **계정이 민감하여 위임할 수 없음** 확인란의 선택을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-302">On the domain controller, clear the **Account is sensitive and cannot be delegated** check box for the account under which the client application is running.</span></span>  
  
2. <span data-ttu-id="9a13f-303">도메인 컨트롤러에서 클라이언트 애플리케이션이 실행 중인 계정에 대해 **위임에 대해 계정을 신뢰할 수 있음** 확인란을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-303">On the domain controller, select the **Account is trusted for delegation** check box for the account under which the client application is running.</span></span>  
  
3. <span data-ttu-id="9a13f-304">도메인 컨트롤러에서 **위임용으로 이 컴퓨터 트러스트** 옵션을 클릭하여 위임을 위해 신뢰할 수 있도록 중간 계층의 컴퓨터를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-304">On the domain controller, configure the middle tier computer so that it is trusted for delegation, by clicking the **Trust computer for delegation** option.</span></span>  
  
4. <span data-ttu-id="9a13f-305">도메인 컨트롤러에서 **지정한 서비스에 대한 위임용으로만 이 컴퓨터 트러스트** 옵션을 클릭하여 한정된 위임을 사용하도록 중간 계층의 컴퓨터를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="9a13f-305">On the domain controller, configure the middle tier computer to use constrained delegation, by clicking the **Trust this computer for delegation to specified services only** option.</span></span>  
  
 <span data-ttu-id="9a13f-306">제한 된 위임 구성에 대 한 자세한 지침은 [Kerberos 프로토콜 전환 및 제한 위임](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc739587(v=ws.10))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="9a13f-306">For more detailed instructions about configuring constrained delegation, see [Kerberos Protocol Transition and Constrained Delegation](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc739587(v=ws.10)).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="9a13f-307">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9a13f-307">See also</span></span>

- <xref:System.ServiceModel.OperationBehaviorAttribute>
- <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A>
- <xref:System.ServiceModel.ImpersonationOption>
- <xref:System.ServiceModel.ServiceSecurityContext.WindowsIdentity%2A>
- <xref:System.ServiceModel.ServiceSecurityContext>
- <xref:System.Security.Principal.WindowsIdentity>
- <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior>
- <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior.ImpersonateCallerForAllOperations%2A>
- <xref:System.ServiceModel.ServiceHost>
- <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A>
- <xref:System.ServiceModel.Security.WindowsClientCredential>
- <xref:System.ServiceModel.ChannelFactory%601>
- <xref:System.Security.Principal.TokenImpersonationLevel.Identification>
- [<span data-ttu-id="9a13f-308">전송 보안을 통해 가장 사용</span><span class="sxs-lookup"><span data-stu-id="9a13f-308">Using Impersonation with Transport Security</span></span>](using-impersonation-with-transport-security.md)
- [<span data-ttu-id="9a13f-309">Impersonating the Client</span><span class="sxs-lookup"><span data-stu-id="9a13f-309">Impersonating the Client</span></span>](../samples/impersonating-the-client.md)
- [<span data-ttu-id="9a13f-310">방법: 서비스에서 클라이언트 가장</span><span class="sxs-lookup"><span data-stu-id="9a13f-310">How to: Impersonate a Client on a Service</span></span>](../how-to-impersonate-a-client-on-a-service.md)
- [<span data-ttu-id="9a13f-311">ServiceModel Metadata 유틸리티 도구(Svcutil.exe)</span><span class="sxs-lookup"><span data-stu-id="9a13f-311">ServiceModel Metadata Utility Tool (Svcutil.exe)</span></span>](../servicemodel-metadata-utility-tool-svcutil-exe.md)
