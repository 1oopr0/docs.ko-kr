---
title: 메시지 분포 제한
ms.date: 03/30/2017
ms.assetid: 8b5ec4b8-1ce9-45ef-bb90-2c840456bcc1
ms.openlocfilehash: 188d7bd365caad7d4cd438744c78ae8e7cd95e7e
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84586314"
---
# <a name="limiting-message-distribution"></a><span data-ttu-id="0dabe-102">메시지 분포 제한</span><span class="sxs-lookup"><span data-stu-id="0dabe-102">Limiting Message Distribution</span></span>

<span data-ttu-id="0dabe-103">피어 채널은 디자인상 브로드캐스트 메시입니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-103">Peer Channel is by design a broadcast mesh.</span></span> <span data-ttu-id="0dabe-104">피어 채널의 기본 플러딩 모델에는 메시의 임의 멤버가 보낸 각 메시지를 해당 메시의 다른 모든 멤버에 배포하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-104">Its basic flooding model involves distributing each message sent by any member of a mesh to all other members of that mesh.</span></span> <span data-ttu-id="0dabe-105">이는 멤버가 생성한 모든 메시지가 관련성을 지니며 다른 모든 멤버에 유용한 경우(예: 채트 방) 이상적입니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-105">This is ideal in situations where every message generated by a member is relevant and useful to all other members (for example, a chat room).</span></span> <span data-ttu-id="0dabe-106">그러나 많은 애플리케이션에서 메시지 배포를 제한해야 하는 경우가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-106">However, many applications have an occasional need for limiting message distribution.</span></span> <span data-ttu-id="0dabe-107">예를 들어 새 멤버가 메시에 참가하여 메시를 통해 전송된 마지막 메시지를 검색하려고 할 경우 이 요청을 메시의 모든 멤버에 플러딩하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-107">For example, if a new member joins a mesh and wants to retrieve the last message sent through the mesh, this request does not need to be flooded to every member of the mesh.</span></span> <span data-ttu-id="0dabe-108">요청은 거의 인접 한 환경으로 제한 될 수 있거나 로컬로 생성 된 메시지를 필터링 할 수 있습니다. 메시지를 메시의 개별 노드로 보낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-108">The request could be limited to near neighbors, or locally generated messages can be filtered out. Messages can also be sent to an individual node on the mesh.</span></span> <span data-ttu-id="0dabe-109">이 항목에서는 홉 수, 메시지 전파 필터, 로컬 필터 또는 직접 연결을 사용하여 전체 메시에서 메시지가 전달되는 방법에 대해 설명하고 접근 방식을 선택하기 위한 일반적인 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-109">This topic discusses using Hop Count, a Message Propagation Filter, a local filter, or a direct connection to control how messages are forwarded throughout the mesh, and provides general guidelines for choosing an approach.</span></span>

## <a name="hop-counts"></a><span data-ttu-id="0dabe-110">홉 수</span><span class="sxs-lookup"><span data-stu-id="0dabe-110">Hop Counts</span></span>

<span data-ttu-id="0dabe-111">`PeerHopCount`의 개념은 IP 프로토콜에 사용되는 TTL(Time-To-Live)과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-111">The concept of `PeerHopCount` is similar to TTL (Time-To-Live) used in IP protocol.</span></span> <span data-ttu-id="0dabe-112">`PeerHopCount`의 값은 메시지 인스턴스에 연결되며 메시지가 삭제되기 전에 전달되어야 하는 횟수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-112">The value of `PeerHopCount` is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped.</span></span> <span data-ttu-id="0dabe-113">피어 채널 클라이언트에 메시지가 수신될 때마다 이 클라이언트에서는 `PeerHopCount`가 지정되어 있는지 여부를 확인하기 위해 해당 메시지를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-113">Each time a message is received by a Peer Channel client, the client examines the message to see if `PeerHopCount` is specified.</span></span> <span data-ttu-id="0dabe-114">해당 값이 지정되어 있으면 메시지를 인접한 노드로 전달하기 전에 클라이언트에서 홉 수 값을 1만큼 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-114">If it is specified, then the client decrements the hop count value by one before forwarding the message to neighboring nodes.</span></span> <span data-ttu-id="0dabe-115">클라이언트에 홉 수 값이 0인 메시지가 수신되면 클라이언트에서 해당 메시지를 처리하지만 인접한 환경으로 전달하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-115">When a client receives a message with a hop count value of zero, the client processes the message, but does not forward the message to neighbors.</span></span>

<span data-ttu-id="0dabe-116">메시지 클래스 구현 시 적용 가능한 속성이나 필드에 `PeerHopCount`를 특성으로 추가하여 메시지에 홉 수를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-116">Hop count may be added to a message by adding `PeerHopCount` as an attribute to the applicable property or field in the implementation of the message class.</span></span> <span data-ttu-id="0dabe-117">메시지를 메시에 보내기 전에 이 홉 수를 특정 값으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-117">You can set this to a specific value before sending the message to the mesh.</span></span> <span data-ttu-id="0dabe-118">이런 방식으로 홉 수를 사용하여 필요한 경우 전체 메시에서 메시지 배포를 제한하면 불필요한 메시지 복제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-118">In this manner, you can use hop count to limit distribution of messages throughout the mesh when necessary, potentially avoiding unnecessary message duplication.</span></span> <span data-ttu-id="0dabe-119">이 방법은 메시에 중복 데이터가 아주 많은 경우 또는 바로 인접한 환경이나 홉 수가 많이 차이 나지 않는 환경으로 메시지를 보내는 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-119">This is useful in cases where the mesh contains a high amount of redundant data, or for sending a message to immediate neighbors, or neighbors within a few hops.</span></span>

- <span data-ttu-id="0dabe-120">코드 조각 및 관련 정보는 피어 채널 블로그에서 [PeerHopCount 특성: 메시지 배포 제어](https://docs.microsoft.com/archive/blogs/peerchan/the-peerhopcount-attribute-controlling-message-distribution) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="0dabe-120">For code snippets and related information, see the [The PeerHopCount Attribute: Controlling Message Distribution](https://docs.microsoft.com/archive/blogs/peerchan/the-peerhopcount-attribute-controlling-message-distribution) post on the Peer Channel blog.</span></span>

## <a name="message-propagation-filter"></a><span data-ttu-id="0dabe-121">메시지 전파 필터</span><span class="sxs-lookup"><span data-stu-id="0dabe-121">Message Propagation Filter</span></span>

<span data-ttu-id="0dabe-122">`MessagePropagationFilter`는 특히 메시지 내용 또는 다른 특정 시나리오에 따라 전파 여부가 결정되는 경우 메시지 플러딩을 사용자 지정 방식으로 제어하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-122">`MessagePropagationFilter` can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation.</span></span> <span data-ttu-id="0dabe-123">이 필터를 사용하면 노드를 통해 전달되는 모든 메시지에 대해 전파 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-123">The filter makes propagation decisions for every message that passes through the node.</span></span> <span data-ttu-id="0dabe-124">이는 메시의 기타 위치에서 발생하여 노드에 수신된 메시지뿐만 아니라 애플리케이션에서 생성된 메시지에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-124">This is true for messages that originated elsewhere in the mesh that your node has received as well as messages created by your application.</span></span> <span data-ttu-id="0dabe-125">이 필터는 메시지와 해당 메시지의 발생 위치에 모두 액세스할 수 있으므로 사용 가능한 전체 정보에 따라 메시지 전달 또는 삭제 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-125">The filter has access to both the message and its origination, so decisions about forwarding or dropping the message can be based on the full information available.</span></span>

<span data-ttu-id="0dabe-126"><xref:System.ServiceModel.PeerMessagePropagationFilter>는 단일 함수 <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>가 있는 기본 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-126"><xref:System.ServiceModel.PeerMessagePropagationFilter> is a base abstract class with a single function, <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>.</span></span> <span data-ttu-id="0dabe-127">메서드 호출의 첫 번째 인수는 메시지의 전체 복사본을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-127">The first argument of the method call passes in a full copy of the message.</span></span> <span data-ttu-id="0dabe-128">메시지를 변경해도 실제 메시지는 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-128">Any changes made to the message do not affect the actual message.</span></span> <span data-ttu-id="0dabe-129">메서드 호출의 마지막 인수는 메시지의 발생 위치(`PeerMessageOrigination.Local` 또는 `PeerMessageOrigination.Remote`)를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-129">The last argument of the method call identifies the origin of the message (`PeerMessageOrigination.Local` or `PeerMessageOrigination.Remote`).</span></span> <span data-ttu-id="0dabe-130">이 메서드를 구체적으로 구현하면 메시지를 로컬 애플리케이션으로 전달하거나(<xref:System.ServiceModel.PeerMessagePropagation>), 원격 클라이언트로 전달하거나(`Local`), 두 위치 모두로 전달하거나(`Remote`), 두 위치 모두로 전달하지 않음(`LocalAndRemote`)을 나타내는 상수를 `None` 열거형에서 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-130">Concrete implementations of this method must return a constant from the <xref:System.ServiceModel.PeerMessagePropagation> enumeration indicating that the message is to be forwarded to the local application (`Local`), forwarded to remote clients (`Remote`), both (`LocalAndRemote`), or neither (`None`).</span></span> <span data-ttu-id="0dabe-131">해당 `PeerNode` 개체에 액세스하고 `PeerNode.MessagePropagationFilter` 속성에 파생된 전파 필터 클래스의 인스턴스를 지정하여 이 필터를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-131">This filter can be applied by accessing the corresponding `PeerNode` object and specifying an instance of the derived propagation filter class in the `PeerNode.MessagePropagationFilter` property.</span></span> <span data-ttu-id="0dabe-132">피어 채널을 열기 전에 전파 필터가 연결되어 있는지 확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="0dabe-132">Ensure that the propagation filter is attached before opening the Peer Channel.</span></span>

- <span data-ttu-id="0dabe-133">코드 조각 및 관련 정보는 피어 채널 블로그의 [피어 채널 및 MessagePropagationFilter](https://docs.microsoft.com/archive/blogs/peerchan/peer-channel-and-messagepropagationfilter) 게시물을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="0dabe-133">For code snippets and related information, see the [Peer Channel and MessagePropagationFilter](https://docs.microsoft.com/archive/blogs/peerchan/peer-channel-and-messagepropagationfilter) post on the Peer Channel blog.</span></span>

## <a name="contacting-an-individual-node-in-the-mesh"></a><span data-ttu-id="0dabe-134">메시의 개별 노드에 연결</span><span class="sxs-lookup"><span data-stu-id="0dabe-134">Contacting an Individual Node in the Mesh</span></span>

<span data-ttu-id="0dabe-135">로컬 필터를 설정하거나 직접 연결을 설정하여 메시의 개별 노드에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-135">An individual node in a mesh can be contacted by setting up a local filter, or by setting up a direct connection.</span></span>

<span data-ttu-id="0dabe-136">메시의 각 노드에 개별 ID가 있는 경우 메시지 구현 시 대상 ID를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-136">If the nodes in a mesh each have an individual ID, a destination ID can be specified in the implementation of your message.</span></span> <span data-ttu-id="0dabe-137">메시지 계약에 함수를 작성하여 로컬 필터를 설정할 수 있습니다. 이 필터는 노드 ID가 사용자 지정 대상 ID와 일치하는 경우에만 현재 노드에 메시지를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-137">A local filter can be set up by writing a function in your message contract that will only display the message to the current node if its ID matches the destination ID you specified.</span></span> <span data-ttu-id="0dabe-138">메시가 메시지를 전송하므로 새 연결을 설정할 때 발생하는 오버헤드를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-138">The mesh transports the message, so the overhead of setting up a new connection does not have to be incurred.</span></span> <span data-ttu-id="0dabe-139">그러나 메시지가 전체 메시에서 여러 번 전송되므로 효율성은 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-139">However, there is a loss of efficiency since the message is sent many times throughout the mesh.</span></span> <span data-ttu-id="0dabe-140">이 방법은 메시지가 너무 크거나 너무 자주 전송되지 않는 한 메시의 개별 멤버에 메시지를 보내는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-140">This works well for sending messages to individual members of a mesh as long as the messages are neither too big nor too frequent.</span></span>

<span data-ttu-id="0dabe-141">오래 지속되는 고대역폭 연결의 경우 직접 연결을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-141">For long-lasting, high-bandwidth connections, direct connections are preferable.</span></span> <span data-ttu-id="0dabe-142">메시를 통해 연결 정보를 보낸 다음 원하는 직접 연결을 설정하여 메시지를 주고 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-142">You can send connection information over the mesh, and then set up a direct connection of your choosing to send/receive messages.</span></span>

## <a name="choosing-an-approach-for-limiting-message-distribution"></a><span data-ttu-id="0dabe-143">메시지 배포 제한 방식 선택</span><span class="sxs-lookup"><span data-stu-id="0dabe-143">Choosing an Approach for Limiting Message Distribution</span></span>

<span data-ttu-id="0dabe-144">메시지 배포를 제한해야 하는 시나리오가 발생할 경우 다음 사항을 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="0dabe-144">When you discover a scenario in which you need to limit message distribution, ask yourself the following questions:</span></span>

- <span data-ttu-id="0dabe-145">**누가** 메시지를 받아야 하나요?</span><span class="sxs-lookup"><span data-stu-id="0dabe-145">**Who** needs to receive the message?</span></span> <span data-ttu-id="0dabe-146">하나의 노드,</span><span class="sxs-lookup"><span data-stu-id="0dabe-146">Just one neighbor node?</span></span> <span data-ttu-id="0dabe-147">메시의 기타 위치에 있는 노드,</span><span class="sxs-lookup"><span data-stu-id="0dabe-147">A node somewhere else in the mesh?</span></span> <span data-ttu-id="0dabe-148">메시 절반)</span><span class="sxs-lookup"><span data-stu-id="0dabe-148">Half the mesh?</span></span>

- <span data-ttu-id="0dabe-149">이 메시지는 **얼마나 자주** 전송 되나요?</span><span class="sxs-lookup"><span data-stu-id="0dabe-149">**How often** will this message be sent?</span></span>

- <span data-ttu-id="0dabe-150">이 메시지에 사용 되는 **대역폭** 의 종류는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="0dabe-150">What kind of **bandwidth** will this message use?</span></span>

<span data-ttu-id="0dabe-151">이러한 사항에 대해 생각해 보면 홉 수, 메시지 전파 필터, 로컬 필터, 직접 연결 중 어느 것을 사용할지 결정하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-151">The answers to these questions can help you determine whether to use Hop Count, a Message Propagation Filter, a local filter, or a direct connection.</span></span> <span data-ttu-id="0dabe-152">다음과 같은 일반적인 지침을 고려해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="0dabe-152">Consider the following general guidelines:</span></span>

- <span data-ttu-id="0dabe-153">**대상을**</span><span class="sxs-lookup"><span data-stu-id="0dabe-153">**Who**</span></span>

  - <span data-ttu-id="0dabe-154">*개별 노드*: 로컬 필터 또는 직접 연결</span><span class="sxs-lookup"><span data-stu-id="0dabe-154">*Individual node*:  Local filter or direct connection.</span></span>

  - <span data-ttu-id="0dabe-155">*특정 주변의 이웃*: PeerHopCount.</span><span class="sxs-lookup"><span data-stu-id="0dabe-155">*Neighbors within a certain vicinity*:  PeerHopCount.</span></span>

  - <span data-ttu-id="0dabe-156">*메시의 복합 하위 집합*: MessagePropagationFilter.</span><span class="sxs-lookup"><span data-stu-id="0dabe-156">*Complex subset of the mesh*:  MessagePropagationFilter.</span></span>

- <span data-ttu-id="0dabe-157">**빈도**</span><span class="sxs-lookup"><span data-stu-id="0dabe-157">**How often**</span></span>

  - <span data-ttu-id="0dabe-158">*매우 잦은*: 직접 연결, PeerHopCount, MessagePropagationFilter.</span><span class="sxs-lookup"><span data-stu-id="0dabe-158">*Very frequent*:  Direct connection, PeerHopCount, MessagePropagationFilter.</span></span>

  - <span data-ttu-id="0dabe-159">*가끔*: 로컬 필터입니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-159">*Occasional*:  Local filter.</span></span>

- <span data-ttu-id="0dabe-160">**대역폭 사용**</span><span class="sxs-lookup"><span data-stu-id="0dabe-160">**Bandwidth use**</span></span>

  - <span data-ttu-id="0dabe-161">*High*: 직접 연결, MessagePropagationFilter 또는 로컬 필터를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-161">*High*:  Direct connection, less advisable to use MessagePropagationFilter or local filter.</span></span>

  - <span data-ttu-id="0dabe-162">*낮음*: 직접 연결 하는 것은 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0dabe-162">*Low*:  Any, direct connection probably not needed.</span></span>

## <a name="see-also"></a><span data-ttu-id="0dabe-163">참고 항목</span><span class="sxs-lookup"><span data-stu-id="0dabe-163">See also</span></span>

- [<span data-ttu-id="0dabe-164">피어 채널 애플리케이션 빌드</span><span class="sxs-lookup"><span data-stu-id="0dabe-164">Building a Peer Channel Application</span></span>](building-a-peer-channel-application.md)
