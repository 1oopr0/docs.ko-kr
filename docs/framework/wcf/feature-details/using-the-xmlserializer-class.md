---
title: XmlSerializer 클래스 사용
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 2ef2d0eefb571f64040fabd16fd65fdfde7a626d
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600207"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="8319e-102">XmlSerializer 클래스 사용</span><span class="sxs-lookup"><span data-stu-id="8319e-102">Using the XmlSerializer Class</span></span>

<span data-ttu-id="8319e-103">WCF (Windows Communication Foundation)에서는 두 가지 serialization 기술을 사용 하 여 응용 프로그램의 데이터를 클라이언트와 서비스 간에 전송 되는 XML로 변환할 수 있습니다 .이 프로세스를 serialization 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="8319e-104">기본값인 DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="8319e-104">DataContractSerializer as the Default</span></span>

<span data-ttu-id="8319e-105">기본적으로 WCF는 클래스를 사용 하 여 <xref:System.Runtime.Serialization.DataContractSerializer> 데이터 형식을 serialize 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="8319e-106">이 serializer는 다음 형식을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-106">This serializer supports the following types:</span></span>

- <span data-ttu-id="8319e-107">기본 형식(예: 정수, 문자열 및 바이트 배열) 및 기본 형식으로 처리되는 <xref:System.Xml.XmlElement> 및 <xref:System.DateTime> 같은 일부 특수 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="8319e-108">데이터 계약 형식(<xref:System.Runtime.Serialization.DataContractAttribute> 특성으로 표시된 형식)</span><span class="sxs-lookup"><span data-stu-id="8319e-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="8319e-109"><xref:System.SerializableAttribute> 인터페이스를 구현하는 형식을 포함하여 <xref:System.Runtime.Serialization.ISerializable> 특성으로 표시된 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="8319e-110"><xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="8319e-111">많은 제네릭 컬렉션 형식을 비롯한 많은 일반 컬렉션 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-111">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="8319e-112">많은 .NET Framework 형식이 후자의 두 범주에 해당 하므로 serialize 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="8319e-113">serialize할 수 있는 형식의 배열도 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="8319e-114">전체 목록은 [서비스 계약에서 데이터 전송 지정](specifying-data-transfer-in-service-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-114">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="8319e-115"><xref:System.Runtime.Serialization.DataContractSerializer>데이터 계약 형식과 함께 사용 되는는 새 WCF 서비스를 작성 하는 데 권장 되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="8319e-116">자세한 내용은 [데이터 계약 사용](using-data-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-116">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="8319e-117">XmlSerializer 클래스 사용 시기</span><span class="sxs-lookup"><span data-stu-id="8319e-117">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="8319e-118">WCF는 클래스도 지원 <xref:System.Xml.Serialization.XmlSerializer> 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="8319e-119"><xref:System.Xml.Serialization.XmlSerializer>클래스는 WCF에 고유 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="8319e-120">ASP.NET 웹 서비스에서 사용 하는 것과 동일한 serialization 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="8319e-121"><xref:System.Xml.Serialization.XmlSerializer> 클래스는 <xref:System.Runtime.Serialization.DataContractSerializer> 클래스보다 훨씬 더 제한된 형식 집합을 지원하지만 결과 XML을 보다 강력하게 제어할 수 있으며 XSD(XML 스키마 정의 언어) 표준의 더 많은 부분을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="8319e-122">또한 이 클래스에는 serialize할 수 있는 형식의 선언적 특성이 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="8319e-123">자세한 내용은 .NET Framework 설명서의 XML Serialization 항목을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="8319e-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="8319e-124"><xref:System.Xml.Serialization.XmlSerializer> 클래스는 데이터 계약 형식을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="8319e-125">Visual Studio에서 Svcutil.exe 또는 **서비스 참조 추가** 기능을 사용 하 여 타사 서비스에 대 한 클라이언트 코드를 생성 하거나 타사 스키마에 액세스 하는 경우 적절 한 serializer가 자동으로 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="8319e-126">스키마가 <xref:System.Runtime.Serialization.DataContractSerializer>와 호환되지 않으면 <xref:System.Xml.Serialization.XmlSerializer>가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="8319e-127">XmlSerializer로 수동 전환</span><span class="sxs-lookup"><span data-stu-id="8319e-127">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="8319e-128">경우에 따라 수동으로 <xref:System.Xml.Serialization.XmlSerializer>로 전환해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="8319e-129">예를 들어 다음과 같은 경우 수동 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-129">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="8319e-130">ASP.NET 웹 서비스에서 WCF로 응용 프로그램을 마이그레이션할 때 <xref:System.Xml.Serialization.XmlSerializer> 새 데이터 계약 형식을 생성 하는 대신 기존의 호환 형식을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="8319e-131">메시지에 표시되는 XML에 대한 정확한 제어가 중요하지만 WSDL(웹 서비스 기술 언어) 문서를 사용할 수 없는 경우(예: DataContractSerializer와 호환되지 않는 특정 표준화 및 게시된 스키마를 준수해야 하는 형식의 서비스를 만드는 경우)</span><span class="sxs-lookup"><span data-stu-id="8319e-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="8319e-132">레거시 SOAP 인코딩 표준을 따르는 서비스를 만드는 경우</span><span class="sxs-lookup"><span data-stu-id="8319e-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="8319e-133">위의 경우를 비롯한 여러 경우에서 다음 코드와 같이 <xref:System.Xml.Serialization.XmlSerializer> 특성을 서비스에 적용하여 `XmlSerializerFormatAttribute` 클래스로 수동 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="8319e-134">보안 고려사항</span><span class="sxs-lookup"><span data-stu-id="8319e-134">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="8319e-135">serialization 엔진을 전환할 때는 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="8319e-136">사용하는 serializer에 따라 같은 형식이 XML로 다르게 serialize될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="8319e-137">실수로 잘못된 serializer를 사용하면 공개하려 하지 않았던 형식의 정보를 공개하게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="8319e-138">예를 들어 <xref:System.Runtime.Serialization.DataContractSerializer> 클래스는 데이터 계약 형식을 serialize할 때 <xref:System.Runtime.Serialization.DataMemberAttribute> 특성으로 표시된 멤버만 serialize하고,</span><span class="sxs-lookup"><span data-stu-id="8319e-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="8319e-139"><xref:System.Xml.Serialization.XmlSerializer> 클래스는 모든 public 멤버를 serialize합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="8319e-140">다음 코드의 형식을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-140">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="8319e-141"><xref:System.Xml.Serialization.XmlSerializer> 클래스가 선택된 서비스 계약에 실수로 이러한 형식을 사용하면 의도하지 않게 `creditCardNumber` 멤버가 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="8319e-142"><xref:System.Runtime.Serialization.DataContractSerializer> 클래스는 기본값이지만 <xref:System.ServiceModel.DataContractFormatAttribute> 특성을 서비스 계약 형식에 적용하여 서비스에 대해 명시적으로 이 클래스를 선택할 수 있습니다. 그러나 실제로 이렇게 해야 하는 경우는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="8319e-143">서비스에 사용되는 serializer는 계약에서 없어서는 안 될 부분이며 다른 바인딩을 선택하거나 기타 구성 설정을 바꿔서 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="8319e-144"><xref:System.Xml.Serialization.XmlSerializer> 클래스에 적용되는 다른 중요한 보안 고려 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="8319e-145">먼저 클래스를 사용 하는 모든 WCF 응용 프로그램 <xref:System.Xml.Serialization.XmlSerializer> 은 공개에서 보호 키로 서명 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="8319e-146">이 권장 사항은 <xref:System.Xml.Serialization.XmlSerializer>로 수동 전환을 수행할 때와 Svcutil.exe, 서비스 참조 추가 또는 유사한 도구를 사용하여 자동 전환을 수행할 때 모두 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="8319e-147">이는 <xref:System.Xml.Serialization.XmlSerializer> serialization 엔진이 응용 프로그램과 동일한 키로 서명 된 경우 *미리 생성 된 serialization 어셈블리* 를 로드 하는 것을 지원 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="8319e-148">애플리케이션에 서명이 없으면 미리 생성된 serialization 어셈블리의 예상 이름과 일치하는 악성 어셈블리가 애플리케이션 폴더나 전역 어셈블리 캐시에 배치될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="8319e-149">물론 공격자가 악성 어셈블리를 이용하려면 먼저 두 위치 중 하나에 대한 쓰기 권한을 얻어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="8319e-150"><xref:System.Xml.Serialization.XmlSerializer>를 사용할 때마다 나타나는 또 다른 위협은 시스템 임시 폴더에 대한 쓰기 권한과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="8319e-151"><xref:System.Xml.Serialization.XmlSerializer>Serialization 엔진은이 폴더에 임시 *serialization 어셈블리* 를 만들고 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="8319e-152">시스템 임시 폴더에 대한 쓰기 권한이 있는 모든 프로세스에서 이러한 serialization 어셈블리를 악성 코드로 덮어쓸 수 있음에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="8319e-153">XmlSerializer 지원에 대한 규칙</span><span class="sxs-lookup"><span data-stu-id="8319e-153">Rules for XmlSerializer support</span></span>

<span data-ttu-id="8319e-154"><xref:System.Xml.Serialization.XmlSerializer> 호환 특성을 계약 작업 매개 변수나 반환 값에 직접 적용할 수 없지만,</span><span class="sxs-lookup"><span data-stu-id="8319e-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="8319e-155">다음 코드와 같이 형식화된 메시지(메시지 계약 본문 부분)에 적용할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="8319e-156">이러한 특성을 형식화된 메시지 멤버에 적용하면 메시지 특성에서 충돌하는 속성이 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="8319e-157">예를 들어 다음 코드에서 `ElementName`은 `Name`을 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="8319e-158"><xref:System.ServiceModel.MessageHeaderArrayAttribute> 특성은 <xref:System.Xml.Serialization.XmlSerializer>를 사용할 때 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="8319e-159">이 경우는 <xref:System.Xml.Serialization.XmlSerializer> WCF 이전에 릴리스된 다음 예외를 throw 합니다. "스키마의 최상위 수준에서 선언 된 요소는 > 1을 가질 수 없습니다 `maxOccurs` .</span><span class="sxs-lookup"><span data-stu-id="8319e-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="8319e-160">`XmlArray` 대신 `XmlArrayItem` 또는 `XmlElementAttribute`을 사용하거나 Wrapper 매개 변수 스타일을 사용하여 ‘more’에 래퍼 요소를 제공하세요." 오류를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="8319e-161">이러한 예외가 표시되면 이 경우에 해당하는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-161">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="8319e-162">WCF는 <xref:System.Xml.Serialization.SoapIncludeAttribute> <xref:System.Xml.Serialization.XmlIncludeAttribute> 메시지 계약 및 작업 계약에서 및 특성을 지원 하지 않습니다. <xref:System.Runtime.Serialization.KnownTypeAttribute> 대신 특성을 사용 하십시오.</span><span class="sxs-lookup"><span data-stu-id="8319e-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="8319e-163">IXmlSerializable 인터페이스를 구현하는 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-163">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="8319e-164">`IXmlSerializable` 인터페이스를 구현하는 형식은 `DataContractSerializer`에서 완전히 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="8319e-165">이러한 형식의 스키마를 제어하려면 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 특성을 항상 이러한 형식에 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="8319e-166">다형 형식을 serialize하는 경우에는 올바른 형식이 serialize되도록 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>를 형식에 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="8319e-167">`IXmlSerializable`을 구현하는 형식에는 임의의 콘텐츠를 나타내는 형식, 단일 요소를 나타내는 형식 및 레거시 <xref:System.Data.DataSet> 형식 등 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="8319e-168">콘텐츠 형식은 `XmlSchemaProviderAttribute` 특성에 지정된 스키마 공급자 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="8319e-169">이 메서드는 `null`을 반환하지 않으며 특성의 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 속성은 기본값인 `false`로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="8319e-170">이는 `IXmlSerializable` 형식의 가장 일반적인 사용입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-170">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="8319e-171">요소 형식은 `IXmlSerializable` 형식이 루트 요소 이름을 제어해야 하는 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="8319e-172">형식을 요소 형식으로 표시하려면 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 특성의 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 속성을 `true`로 설정하거나 스키마 공급자 메서드에서 `null`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="8319e-173">스키마 공급자 메서드 사용은 요소 형식의 옵션이며 `null`에 메서드 이름 대신 `XmlSchemaProviderAttribute`을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="8319e-174">그러나 `IsAny`가 `true`이고 스키마 공급자 메서드가 지정된 경우 메서드는 `null`을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="8319e-175">레거시 <xref:System.Data.DataSet> 형식은 `IXmlSerializable` 특성으로 표시되지 않은 `XmlSchemaProviderAttribute` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="8319e-176">대신 이러한 형식은 스키마 생성 시 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="8319e-177">이 패턴은 `DataSet` 형식에 사용되고 해당 형식화된 데이터 세트은 이전 버전의 .NET Framework에서는 클래스를 파생하지만 현재는 더 이상 사용되지 않으며 레거시 용도로만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="8319e-178">이 패턴을 사용하는 대신 `XmlSchemaProviderAttribute`를 항상 `IXmlSerializable` 형식에 적용하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="8319e-179">IXmlSerializable 콘텐츠 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-179">IXmlSerializable Content Types</span></span>

<span data-ttu-id="8319e-180">이전에 정의한 콘텐츠 형식이며 `IXmlSerializable`을 구현하는 형식의 데이터 멤버를 serialize할 때 serializer는 데이터 멤버의 래퍼 요소를 쓰고 제어를 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="8319e-181"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 구현은 특성을 래퍼 요소에 추가하는 것을 포함하여 모든 XML을 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="8319e-182">`WriteXml`이 완료되면 serializer는 요소를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-182">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="8319e-183">이전에 정의한 콘텐츠 형식이며 `IXmlSerializable`을 구현하는 형식의 데이터 멤버를 역직렬화할 때 역직렬 변환기는 데이터 멤버의 래퍼 요소에 XML 판독기를 배치하고 제어를 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="8319e-184">메서드는 시작 및 끝 태그를 비롯하여 전체 요소를 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="8319e-185">`ReadXml` 코드는 요소가 비어 있는 경우를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="8319e-186">또한 `ReadXml` 구현은 래퍼 요소의 이름이 특정한 방식으로 지정되는 데 의존해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="8319e-187">serializer에서 선택되는 이름은 다양할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-187">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="8319e-188">`IXmlSerializable` 형식의 데이터 멤버 등에 다형적으로 <xref:System.Object> 콘텐츠 형식을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="8319e-189">또한 형식 인스턴스는 null일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="8319e-190">마지막으로 개체 그래프 유지가 활성화된 상태 및 `IXmlSerializable`로 <xref:System.Runtime.Serialization.NetDataContractSerializer>을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="8319e-191">이러한 모든 기능을 통해 WCF serializer는 특정 특성을 래퍼 요소 ("nil" 및 "type"의 XML 스키마 인스턴스 네임 스페이스 및 "Id", "Ref", "Type" 및 "Assembly")에 연결 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="8319e-192">ReadXml을 구현할 때 무시할 특성</span><span class="sxs-lookup"><span data-stu-id="8319e-192">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="8319e-193">제어를 `ReadXml` 코드에 전달하기 전에 역직렬 변환기는 XML 요소를 검사하고 이러한 특수 XML 특성을 검색하여 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="8319e-194">예를 들어 "nil"이 `true`이면 null 값이 역직렬화되고 `ReadXml`은 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="8319e-195">다형성이 검색되면 요소의 콘텐츠가 다른 형식인 것처럼 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="8319e-196">다형적으로 할당된 형식의 `ReadXml` 구현이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="8319e-197">어떤 경우에든 이러한 특수 특성은 역직렬 변환기에 의해 처리되므로 `ReadXml` 구현에서는 해당 특수 특성을 무시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="8319e-198">IXmlSerializable 콘텐츠 형식의 스키마 고려 사항</span><span class="sxs-lookup"><span data-stu-id="8319e-198">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="8319e-199">스키마와 `IXmlSerializable` 콘텐츠 형식을 내보내면 스키마 공급자 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="8319e-200"><xref:System.Xml.Schema.XmlSchemaSet>가 스키마 공급자 메서드로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="8319e-201">메서드는 유효한 스키마를 모두 스키마 집합에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="8319e-202">스키마 집합에는 스키마를 내보낼 때 이미 알려진 스키마가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="8319e-203">스키마 공급자 메서드는 스키마 집합에 항목을 추가해야 하는 경우 해당 네임스페이스를 가진 <xref:System.Xml.Schema.XmlSchema>가 집합에 이미 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="8319e-204">이미 있으면 스키마 공급자 메서드는 기존 `XmlSchema`에 새 항목을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="8319e-205">없는 경우에는 새 `XmlSchema` 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="8319e-206">이 기능은 `IXmlSerializable` 형식의 배열을 사용하는 경우에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="8319e-207">예를 들어 "B" 네임스페이스에 "A" 형식으로 내보내지는 `IXmlSerializable` 형식이 있는 경우 스키마 공급자 메서드가 호출될 때까지 스키마 집합에 "ArrayOfA" 형식을 보유할 "B"의 스키마가 이미 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="8319e-208"><xref:System.Xml.Schema.XmlSchemaSet>에 형식을 추가하는 것 외에 콘텐츠 형식의 스키마 공급자 메서드는 null이 아닌 값을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="8319e-209">이 메서드는 지정된 <xref:System.Xml.XmlQualifiedName> 형식에 사용할 스키마 형식의 이름을 지정하는 `IXmlSerializable`을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="8319e-210">이 정규화된 이름은 형식의 데이터 계약 이름과 네임스페이스로도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="8319e-211">스키마 공급자 메서드가 반환될 때 즉시 스키마 집합에 없는 형식을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="8319e-212">그러나 관련된 모든 형식을 내보낼 때까지, 즉 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A>의 모든 관련 형식에 대해 <xref:System.Runtime.Serialization.XsdDataContractExporter> 메서드가 호출되고 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 속성에 액세스할 때까지 형식은 스키마 집합에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="8319e-213">관련된 `Schemas` 호출을 수행하기 전에 `Export` 속성에 액세스하면 <xref:System.Xml.Schema.XmlSchemaException>이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="8319e-214">내보내기 프로세스에 대 한 자세한 내용은 [클래스에서 스키마 내보내기](exporting-schemas-from-classes.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-214">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="8319e-215">스키마 공급자 메서드는 또한 사용할 <xref:System.Xml.Schema.XmlSchemaType>을 반환할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="8319e-216">형식은 익명이거나 익명이 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="8319e-217">익명인 경우 `IXmlSerializable` 형식을 데이터 멤버로 사용할 때마다 `IXmlSerializable` 형식의 스키마가 익명 형식으로 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="8319e-218">`IXmlSerializable` 형식에 여전히 데이터 계약 이름과 네임스페이스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="8319e-219">이는 특성을 사용 하 여 이름을 사용자 지정할 수 없는 경우를 제외 하 고는 [데이터 계약 이름](data-contract-names.md) 에 설명 된 대로 결정 됩니다 <xref:System.Runtime.Serialization.DataContractAttribute> . 익명이 아닌 경우의 형식 중 하나 여야 합니다 `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="8319e-219">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="8319e-220">이 경우는 형식의 `XmlQualifiedName`을 반환하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="8319e-221">또한 전역 요소 선언이 형식에 대해 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="8319e-222">형식에 <xref:System.Xml.Serialization.XmlRootAttribute> 특성이 적용되지 않은 경우 요소가 데이터 계약과 동일한 이름 및 네임스페이스를 갖게 되며 "nillable" 속성이 `true`가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="8319e-223">이에 대 한 유일한 예외는 스키마 네임 스페이스 ( `http://www.w3.org/2001/XMLSchema` )입니다. 형식의 데이터 계약이이 네임 스페이스에 있으면 스키마 네임 스페이스에 새 요소를 추가할 수 없으므로 해당 전역 요소가 빈 네임 스페이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="8319e-224">형식에 `XmlRootAttribute` 특성이 적용되어 있으면 전역 요소 선언이 <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 및 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> 속성을 사용하여 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="8319e-225">`XmlRootAttribute`가 적용된 경우의 기본값은 데이터 계약 이름, 빈 네임스페이스 및 `true`인 "nillable"입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="8319e-226">레거시 데이터 세트 형식에도 동일한 전역 요소 선언 규칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="8319e-227">`XmlRootAttribute`는 사용자 지정 코드를 통해 추가된, 즉 스키마 공급자 메서드를 사용하거나 레거시 데이터 세트 형식의 경우 `XmlSchemaSet`를 통해 `GetSchema`에 추가된 전역 요소 선언을 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="8319e-228">IXmlSerializable 요소 형식</span><span class="sxs-lookup"><span data-stu-id="8319e-228">IXmlSerializable Element Types</span></span>

<span data-ttu-id="8319e-229">`IXmlSerializable` 요소 형식은 `IsAny` 속성이 `true`로 설정되어 있거나 스키마 공급자 메서드가 `null`을 반환하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="8319e-230">요소 형식의 직렬화 및 역직렬화는 콘텐츠 형식의 직렬화 및 역직렬화와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="8319e-231">그러나 다음과 같은 중요한 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-231">However, there are some important differences:</span></span>

- <span data-ttu-id="8319e-232">`WriteXml` 구현은 정확히 하나의 요소를 씁니다. 물론 이 요소는 여러 개의 자식 요소를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="8319e-233">이 단일 요소, 여러 개의 형제 요소 또는 혼합 콘텐츠 외부의 특성을 쓰면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="8319e-234">요소는 비어 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-234">The element may be empty.</span></span>

- <span data-ttu-id="8319e-235">`ReadXml` 구현은 래퍼 요소를 읽어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="8319e-236">`WriteXml`에서 생성하는 하나의 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-236">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="8319e-237">예를 들어 데이터 계약의 데이터 멤버로 정기적으로 요소 형식을 serialize하는 경우 serializer는 콘텐츠 형식과 마찬가지로 `WriteXml`을 호출하기 전에 래퍼 요소를 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="8319e-238">그러나 최상위 수준에서 요소 형식을 serialize할 때 serializer는 일반적으로 `WriteXml` 또는 `DataContractSerializer` 생성자에서 serializer를 생성할 때 루트 이름과 네임스페이스를 명시적으로 지정하지 않은 경우 `NetDataContractSerializer`에서 쓰는 요소를 둘러싼 래퍼 요소를 출력하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="8319e-239">자세한 내용은 [Serialization 및 Deserialization](serialization-and-deserialization.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-239">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="8319e-240">생성 시 루트 이름과 네임스페이스를 지정하지 않고 최상위 수준에서 요소 형식을 serialize하는 경우 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 및 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A>에서 아무 작업도 수행하지 않으며 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>는 `WriteXml`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="8319e-241">이 모드에서 serialize되는 개체는 `null`일 수 없으며 다형적으로 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="8319e-242">또한 개체 그래프 유지를 활성화할 수 없고 `NetDataContractSerializer`를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="8319e-243">생성 시 루트 이름과 네임스페이스를 지정하지 않고 최상위 수준에서 요소 형식을 역직렬화하는 경우 <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A>가 임의 요소의 시작 부분을 찾으면 `true`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="8319e-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 매개 변수를 `verifyObjectName`로 설정한 `true`는 실제로 개체를 읽기 전에 `IsStartObject`와 같은 방식으로 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="8319e-245">그런 다음 `ReadObject`는 컨트롤을 `ReadXml` 메서드로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-245">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="8319e-246">요소 형식과 관련해서 내보낸 스키마는 스키마 공급자 메서드가 `XmlElement`에 다른 스키마를 추가할 수 있다는 점을 제외하고 이전 단원에서 설명한 대로 <xref:System.Xml.Schema.XmlSchemaSet> 형식에 대해 콘텐츠 형식과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="8319e-247">요소 형식에 `XmlRootAttribute` 특성을 사용할 수 없으며 이러한 형식에 대해 전역 요소 선언을 내보내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="8319e-248">XmlSerializer와의 차이점</span><span class="sxs-lookup"><span data-stu-id="8319e-248">Differences from the XmlSerializer</span></span>

<span data-ttu-id="8319e-249">`IXmlSerializable` 인터페이스와 `XmlSchemaProviderAttribute` 및 `XmlRootAttribute` 특성도 <xref:System.Xml.Serialization.XmlSerializer>에서 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="8319e-250">그러나 데이터 계약 모델에서 처리되는 방법에 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="8319e-251">아래 목록에 중요한 차이가 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-251">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="8319e-252">`XmlSerializer`에서 사용할 수 있으려면 스키마 공급자 메서드가 public이어야 하지만 public이 아니어도 데이터 계약 모델에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="8319e-253">데이터 계약 모델에서 `IsAny`가 `true`일 때는 스키마 공급자 메서드가 호출되지만 `XmlSerializer`를 사용할 때는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="8319e-254">콘텐츠 또는 레거시 데이터 세트 형식에 `XmlRootAttribute` 특성이 없으면 `XmlSerializer`는 빈 네임스페이스에 전역 요소 선언을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="8319e-255">데이터 계약 모델에서 사용되는 네임스페이스는 일반적으로 앞에서 설명한 데이터 계약 네임스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="8319e-256">두 가지 serialization 기술에서 모두 사용할 형식을 만드는 경우 이러한 차이에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="8319e-257">IXmlSerializable 스키마 가져오기</span><span class="sxs-lookup"><span data-stu-id="8319e-257">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="8319e-258">`IXmlSerializable` 형식에서 생성된 스키마를 가져오는 경우 다음과 같은 몇 가지 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="8319e-259">생성 된 스키마는 [데이터 계약 스키마 참조](data-contract-schema-reference.md)에 설명 된 대로 유효한 데이터 계약 스키마 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="8319e-260">이 경우 스키마를 일반적인 방법으로 가져올 수 있으며 일반 데이터 계약 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="8319e-261">생성된 스키마가 올바른 데이터 계약 스키마가 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="8319e-262">예를 들어 스키마 공급자 메서드가 데이터 계약 모델에서 지원되지 않는 XML 특성과 관련된 스키마를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="8319e-263">이 경우 스키마를 `IXmlSerializable` 형식으로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="8319e-264">이 가져오기 모드는 기본적으로 설정 되지 않지만 예를 들어 `/importXmlTypes` [ServiceModel Metadata 유틸리티 도구 (svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)로 명령줄 스위치를 사용 하 여 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="8319e-265">이에 대해서는 [클래스를 생성 하기 위해 스키마 가져오기](importing-schema-to-generate-classes.md)에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-265">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="8319e-266">형식 인스턴스에 대한 XML로 직접 작업해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="8319e-267">보다 넓은 범위의 스키마를 지원하는 다른 serialization 기술을 사용할 수도 있습니다. `XmlSerializer` 사용에 대한 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8319e-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="8319e-268">새 형식을 생성하는 대신 프록시의 기존 `IXmlSerializable` 형식을 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="8319e-269">이 경우 스키마를 가져와서 형식 생성 항목에서 설명하는 참조된 형식 기능을 사용하여 다시 사용할 형식을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="8319e-270">이는 다시 사용할 형식이 포함된 어셈블리를 지정하는 svcutil.exe에 `/reference` 스위치를 사용하는 것에 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="8319e-271">XmlSerializer 레거시 동작</span><span class="sxs-lookup"><span data-stu-id="8319e-271">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="8319e-272">.NET Framework 4.0 및 이전 버전에서는 XmlSerializer가 파일에 C# 코드를 작성해서 임시 serialization 어셈블리를 생성했습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="8319e-273">그런 다음 파일이 어셈블리로 컴파일됩니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="8319e-274">이 동작은 serializer가 느리게 시작하는 등의 좋지 않은 결과가 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="8319e-275">.NET Framework 4.5에서는 이 동작이 컴파일러를 사용하지 않고도 어셈블리를 생성할 수 있도록 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="8319e-276">일부 개발자는 생성된 C# 코드를 보고 싶어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="8319e-277">다음과 같이 구성하면 이 레거시 동작을 사용하도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-277">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="8319e-278">Public이 아닌 새 재정의를 사용 하 여 파생 클래스를 직렬화 하지 못하는 경우와 같이 호환성 문제가 발생 하는 경우 `XmlSerializer` `XMLSerializer` 다음 구성을 사용 하 여 레거시 동작으로 다시 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="8319e-279">위의 구성 대신 .NET Framework 4.5 이상 버전을 실행 하는 컴퓨터에서 다음 구성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="8319e-280">`<xmlSerializer useLegacySerializerGeneration="true"/>`스위치는 .NET Framework 4.5 이상 버전을 실행 하는 컴퓨터 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="8319e-281">위의 `appSettings` 방법은 모든 .NET Framework 버전에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="8319e-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="8319e-282">참고 항목</span><span class="sxs-lookup"><span data-stu-id="8319e-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="8319e-283">서비스 계약에서 데이터 전송 지정</span><span class="sxs-lookup"><span data-stu-id="8319e-283">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="8319e-284">데이터 계약 사용</span><span class="sxs-lookup"><span data-stu-id="8319e-284">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="8319e-285">방법: XmlSerializer를 사용하여 WCF 클라이언트 애플리케이션의 시작 시간 향상</span><span class="sxs-lookup"><span data-stu-id="8319e-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
