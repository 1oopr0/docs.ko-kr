---
title: 데이터 계약의 컬렉션 형식
description: 데이터 계약 모델에서 .NET Framework의 컬렉션을 처리 하는 방법 및 WCF가 컬렉션 형식에 대 한 데이터 serialization을 지 원하는 방법에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 83acf1f74bf3cb117f3f94743eda32d3f2cc4b82
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85245182"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="ed356-103">데이터 계약의 컬렉션 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-103">Collection Types in Data Contracts</span></span>

<span data-ttu-id="ed356-104">*컬렉션* 은 특정 형식의 항목으로 구성된 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-104">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="ed356-105">.NET Framework에서 이러한 목록은 배열이 나 다양 한 형식 (제네릭 목록, 제네릭 <xref:System.ComponentModel.BindingList%601> , 또는)을 사용 하 여 나타낼 수 있습니다 <xref:System.Collections.Specialized.StringCollection> <xref:System.Collections.ArrayList> .</span><span class="sxs-lookup"><span data-stu-id="ed356-105">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="ed356-106">예를 들어, 컬렉션은 지정된 고객에 대한 주소 목록을 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-106">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="ed356-107">실제 형식에 관계없이 이러한 컬렉션을 *목록 컬렉션*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-107">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="ed356-108">하나의 항목("키")과 다른 항목("값") 간의 연결을 나타내는 특별한 형태의 컬렉션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-108">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="ed356-109">.NET Framework에서는 및 제네릭 사전과 같은 형식으로 표시 됩니다 <xref:System.Collections.Hashtable> .</span><span class="sxs-lookup"><span data-stu-id="ed356-109">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="ed356-110">예를 들어, 연결 컬렉션은 도시("키")를 해당 도시의 인구("값")에 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-110">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="ed356-111">실제 형식에 관계없이 이러한 컬렉션을 *사전 컬렉션*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-111">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="ed356-112">데이터 계약 모델에서 컬렉션은 별도로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-112">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="ed356-113">배열 및 제네릭 컬렉션을 비롯하여 <xref:System.Collections.IEnumerable> 인터페이스를 구현하는 형식은 컬렉션으로 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-113">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="ed356-114">이 중에서 <xref:System.Collections.IDictionary> 또는 제네릭 <xref:System.Collections.Generic.IDictionary%602> 인터페이스를 구현하는 형식은 사전 컬렉션이며, 다른 모든 형식은 목록 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-114">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="ed356-115">메서드를 호출 하 고 매개 변수 없는 생성자를 포함 하는 등 컬렉션 형식에 대 한 추가 요구 사항은 `Add` 다음 단원에서 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-115">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="ed356-116">이렇게 하면 컬렉션 형식이 직렬화되고 역직렬화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-116">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="ed356-117">즉, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 매개 변수가 없는 생성자가 없기 때문에 제네릭과 같은 일부 컬렉션은 직접 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-117">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="ed356-118">이러한 제한을 해결하는 방법에 대한 자세한 내용은 이 항목의 뒷부분에 있는 "컬렉션 인터페이스 형식 및 읽기 전용 컬렉션 사용" 단원을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-118">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="ed356-119">컬렉션에 포함된 형식은 데이터 계약 형식이거나 serialize할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-119">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="ed356-120">자세한 내용은 [데이터 계약 Serializer에서 지 원하는 형식](types-supported-by-the-data-contract-serializer.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ed356-120">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="ed356-121">유효한 컬렉션 및 컬렉션을 serialize 하는 방법에 대 한 자세한 내용은이 항목의 "고급 컬렉션 규칙" 섹션에서 컬렉션을 serialize 하는 방법에 대 한 정보를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ed356-121">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="ed356-122">교환 가능 컬렉션</span><span class="sxs-lookup"><span data-stu-id="ed356-122">Interchangeable Collections</span></span>

<span data-ttu-id="ed356-123">동일한 형식의 모든 목록 컬렉션은 이 항목 뒷부분에서 설명하는 것처럼 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 사용자 지정되지 않는 한 동일한 데이터 계약을 가지는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-123">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="ed356-124">예를 들어, 다음 데이터 계약은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-124">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="ed356-125">두 데이터 계약 모두 다음 코드와 유사한 XML이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-125">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="ed356-126">예를 들어, 컬렉션 교환 가능성을 통해 서버의 성능에 맞게 최적화된 컬렉션 형식 및 클라이언트의 사용자 인터페이스 구성 요소에 바인딩되도록 디자인된 컬렉션 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-126">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="ed356-127">목록 컬렉션과 마찬가지로 동일한 키 및 값 형식이 있는 모든 사전 컬렉션은 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 사용자 지정되지 않는 한 동일한 데이터 계약을 가지는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-127">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="ed356-128">컬렉션 일치에 있어서는 .NET 형식이 아닌 데이터 계약 형식만 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-128">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="ed356-129">즉, Type1 및 Type2에 동일한 데이터 계약이 있는 경우 Type1의 컬렉션과 Type2의 컬렉션이 동일하다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-129">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="ed356-130">제네릭이 아닌 컬렉션에는 `Object`형식의 제네릭 컬렉션과 동일한 데이터 계약이 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-130">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="ed356-131">예를 들어, <xref:System.Collections.ArrayList> 의 데이터 계약 및 <xref:System.Collections.Generic.List%601> 의 제네릭 `Object` 은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-131">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="ed356-132">컬렉션 인터페이스 형식 및 읽기 전용 컬렉션 사용</span><span class="sxs-lookup"><span data-stu-id="ed356-132">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="ed356-133">또한 컬렉션 인터페이스 형식(<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, 제네릭 <xref:System.Collections.Generic.IDictionary%602>또는 이러한 인터페이스에서 파생된 인터페이스)에는 실제 컬렉션 형식의 컬렉션 데이터 계약과 동일한 컬렉션 데이터 계약이 있는 것으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-133">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="ed356-134">따라서 serialize되는 형식을 컬렉션 인터페이스 형식으로 선언할 수 있으며, 결과는 실제 컬렉션 형식을 사용한 것과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-134">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="ed356-135">예를 들어, 다음 데이터 계약은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-135">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="ed356-136">serialization을 수행하는 동안 선언된 형식이 인터페이스인 경우 사용된 실제 인스턴스 형식은 해당 인터페이스를 구현하는 모든 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-136">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="ed356-137">앞에서 설명한 제한 사항 (매개 변수가 없는 생성자와 `Add` 메서드 포함)은 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-137">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="ed356-138">예를 들어, 제네릭 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 형식의 데이터 멤버를 직접 선언할 수 없는 경우에도 Customer2의 주소를 제네릭 주소 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>의 인스턴스로 설정할 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="ed356-138">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="ed356-139">deserialization을 수행하는 동안 선언된 형식이 인터페이스인 경우 serialization 엔진은 선언된 인터페이스를 구현하는 형식을 선택하고, 해당 형식은 인스턴스화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-139">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="ed356-140">알려진 형식 메커니즘 ( [데이터 계약 알려진 형식](data-contract-known-types.md)에 설명 됨)은 여기에 영향을 주지 않습니다. 선택할 수 있는 형식은 WCF에 기본 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-140">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="ed356-141">컬렉션 형식 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="ed356-141">Customizing Collection Types</span></span>

<span data-ttu-id="ed356-142">여러 용도로 사용되는 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 컬렉션 형식을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-142">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="ed356-143">컬렉션 형식을 사용자 지정하면 컬렉션 교환 가능성이 낮아지므로 가능하면 이 특성을 적용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-143">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="ed356-144">이 문제에 대 한 자세한 내용은이 항목의 뒷부분에 나오는 "고급 컬렉션 규칙" 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-144">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="ed356-145">컬렉션 데이터 계약 명명</span><span class="sxs-lookup"><span data-stu-id="ed356-145">Collection Data Contract Naming</span></span>

<span data-ttu-id="ed356-146">컬렉션 형식의 명명 규칙은 [Data Contract Names](data-contract-names.md)에서 설명한 대로 일반 데이터 계약 형식의 명명 규칙과 유사하지만, 다음과 같은 중요한 차이점이 몇 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-146">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="ed356-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성은 <xref:System.Runtime.Serialization.DataContractAttribute> 특성 대신 이름을 사용자 지정하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="ed356-148">또한 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성에는 `Name` 및 `Namespace` 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-148">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="ed356-149"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용되지 않는 경우 컬렉션 형식의 기본 이름 및 네임스페이스는 컬렉션에 포함된 형식의 이름 및 네임스페이스에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-149">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="ed356-150">컬렉션 형식의 이름 및 네임스페이스 자체는 컬렉션에 포함된 형식의 이름 및 네임스페이스에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-150">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="ed356-151">예제를 보려면 다음 형식을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-151">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="ed356-152">두 형식의 데이터 계약 이름이 모두 "ArrayOfstring"이고 "CustomerList1" 또는 "StringList1"이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-152">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="ed356-153">즉, 루트 수준의 이러한 형식 중 하나를 serialize하면 다음 코드와 유사한 XML이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-153">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="ed356-154">문자열의 목록을 나타내는 사용자 지정되지 않은 형식에 동일한 데이터 계약 및 XML 표현이 있도록 이 명명 규칙을 선택했습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-154">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="ed356-155">이렇게 하면 컬렉션 교환이 가능하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-155">This makes collection interchangeability possible.</span></span> <span data-ttu-id="ed356-156">이 예제에서 CustomerList1과 StringList1은 완벽하게 교환 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-156">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="ed356-157">그러나 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용된 경우 속성을 특성에 설정하지 않아도 컬렉션은 사용자 지정된 컬렉션 데이터 계약이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-157">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="ed356-158">따라서 컬렉션 데이터 계약의 이름 및 네임스페이스는 컬렉션 형식 자체에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-158">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="ed356-159">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-159">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="ed356-160">serialize된 결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-160">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="ed356-161">결과 XML은 사용자 지정되지 않은 형식의 XML 표현과 더 이상 동일하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-161">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="ed356-162">`Name` 및 `Namespace` 속성을 사용하여 명명을 추가로 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-162">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="ed356-163">다음 클래스를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-163">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="ed356-164">결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-164">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="ed356-165">자세한 내용은이 항목의 뒷부분에 나오는 "고급 컬렉션 규칙" 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-165">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="ed356-166">목록 컬렉션의 반복되는 요소 이름 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="ed356-166">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="ed356-167">목록 컬렉션에는 반복되는 항목이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-167">List collections contain repeating entries.</span></span> <span data-ttu-id="ed356-168">일반적으로 반복되는 각 항목은 컬렉션에 포함된 형식의 데이터 계약 이름에 따라 명명된 요소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-168">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="ed356-169">`CustomerList` 예제에서 컬렉션에는 문자열이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-169">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="ed356-170">문자열 기본 형식에 대 한 데이터 계약 이름은 "string" 이므로 반복 되는 요소는 " \<string> "입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-170">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="ed356-171">그러나 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 특성의 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 속성을 사용하여 이 반복되는 요소 이름을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-171">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="ed356-172">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-172">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="ed356-173">결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-173">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="ed356-174">반복되는 요소의 네임스페이스는 앞에서 설명한 대로 `Namespace` 속성을 사용하여 사용자 지정할 수 있는 컬렉션 데이터 계약의 네임스페이스와 항상 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-174">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="ed356-175">사전 컬렉션 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="ed356-175">Customizing Dictionary Collections</span></span>

<span data-ttu-id="ed356-176">사전 컬렉션은 기본적으로 항목의 목록이며 각 항목에는 키 다음에 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-176">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="ed356-177">일반 목록과 마찬가지로 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 속성을 사용하여 반복되는 요소에 해당하는 요소 이름을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-177">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="ed356-178">또한 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 및 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 속성을 사용하여 키 및 값을 나타내는 요소 이름을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-178">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="ed356-179">이러한 요소의 네임스페이스는 컬렉션 데이터 계약의 네임스페이스와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-179">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="ed356-180">예를 보려면 다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-180">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="ed356-181">serialize된 결과 XML은 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-181">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="ed356-182">사전 컬렉션에 대 한 자세한 내용은이 항목의 뒷부분에 나오는 "고급 컬렉션 규칙" 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-182">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="ed356-183">컬렉션 및 알려진 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-183">Collections and Known Types</span></span>

<span data-ttu-id="ed356-184">컬렉션 형식을 다른 컬렉션이나 컬렉션 인터페이스 대신 다형적으로 사용하는 경우 알려진 형식에 추가할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-184">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="ed356-185">예를 들어, <xref:System.Collections.IEnumerable> 형식의 데이터 멤버를 선언하고 이를 사용하여 <xref:System.Collections.ArrayList>의 인스턴스를 보내는 경우 <xref:System.Collections.ArrayList> 를 알려진 형식에 추가할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-185">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="ed356-186">비컬렉션 형식 대신 다형적으로 컬렉션을 사용하는 경우에는 알려진 형식에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-186">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="ed356-187">예를 들어, `Object` 형식의 데이터 멤버를 선언하고 이를 사용하여 <xref:System.Collections.ArrayList>의 인스턴스를 보내는 경우 알려진 형식에 <xref:System.Collections.ArrayList> 를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-187">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="ed356-188">그러나 동일한 컬렉션을 다형적으로 serialize할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-188">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="ed356-189">예를 들어, <xref:System.Collections.ArrayList> 를 위 예제의 알려진 형식의 목록에 추가하는 경우 해당 목록에 동일한 데이터 계약이 있더라도 `Array of Object` 클래스를 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-189">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="ed356-190">따라서 비컬렉션 형식에 대한 serialization에서 알려진 형식의 일반 동작과 차이는 없지만, 컬렉션이 동일한 경우가 매우 일반적이기 때문에 컬렉션의 경우 이 동작을 이해하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-190">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="ed356-191">serialization을 수행하는 동안 지정된 데이터 계약의 지정된 범위에서 하나의 형식만을 알 수 있으며 모든 동일한 컬렉션에는 같은 데이터 계약이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-191">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="ed356-192">따라서 위 예제에서 <xref:System.Collections.ArrayList> 및 `Array of Object` 모두를 같은 범위의 알려진 형식에 추가할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-192">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="ed356-193">이 동작은 비컬렉션 형식에 대한 알려진 형식 동작과 동일하지만, 컬렉션의 경우 이를 이해하는 것이 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-193">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="ed356-194">알려진 형식은 또한 컬렉션의 내용에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-194">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="ed356-195">예를 들어, <xref:System.Collections.ArrayList> 에 `Type1` 및 `Type2`의 인스턴스가 실제로 있는 경우 이 두 가지 형식 모두 알려진 형식에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-195">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="ed356-196">다음 예제에서는 컬렉션 및 알려진 형식을 사용하여 올바르게 생성된 개체 그래프를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-196">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="ed356-197">일반적으로 실제 애플리케이션에서는 다음 데이터 멤버를 `Object`로 정의하지 않고 알려진 형식/다형성 문제가 없기 때문에 이 예제는 실제와 다소 거리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-197">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="ed356-198">deserialization에서 선언된 형식이 컬렉션 형식이면 실제로 보낸 형식과 관계없이 선언된 형식이 인스턴스화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-198">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="ed356-199">선언된 형식이 컬렉션 인터페이스이면 역직렬 변환기에서는 알려진 형식과 관계없이 인스턴스화할 형식을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-199">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="ed356-200">또한 deserialization에서 선언된 형식이 컬렉션 형식은 아니지만 컬렉션 형식을 보내는 경우 일치하는 컬렉션 형식이 알려진 형식 목록에서 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-200">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="ed356-201">deserialization에서 컬렉션 인터페이스 형식을 알려진 형식 목록에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-201">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="ed356-202">이 경우 deserialization 엔진은 인스턴스화할 형식을 다시 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-202">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="ed356-203">컬렉션 및 NetDataContractSerializer 클래스</span><span class="sxs-lookup"><span data-stu-id="ed356-203">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="ed356-204"><xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스가 사용 중인 경우 배열이 아닌 사용자 지정되지 않은 컬렉션 형식( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 없는 컬렉션)은 원래의 특수한 의미를 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-204">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="ed356-205"><xref:System.SerializableAttribute> 특성으로 표시된 사용자 지정되지 않은 컬렉션 형식은 <xref:System.Runtime.Serialization.NetDataContractSerializer> 특성이나 <xref:System.SerializableAttribute> 인터페이스 규칙에 따라 <xref:System.Runtime.Serialization.ISerializable> 클래스로 여전히 serialize할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-205">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="ed356-206">사용자 지정된 컬렉션 형식, 컬렉션 인터페이스 및 배열은 <xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스가 사용 중인 경우에도 컬렉션으로서 계속 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-206">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="ed356-207">컬렉션 및 스키마</span><span class="sxs-lookup"><span data-stu-id="ed356-207">Collections and Schema</span></span>

<span data-ttu-id="ed356-208">모든 동일한 컬렉션에는 동일한 표현의 XSD(XML 스키마 정의 언어) 스키마가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-208">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="ed356-209">이 때문에 일반적으로 서버의 컬렉션 형식과 동일한 컬렉션 형식을 생성된 클라이언트 코드에서 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-209">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="ed356-210">예를 들어, 서버에서 정수 데이터 멤버의 제네릭 <xref:System.Collections.Generic.List%601> 와 함께 데이터 계약을 사용할 수 있지만, 생성된 클라이언트 코드에서 동일한 데이터 멤버가 정수 배열이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-210">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="ed356-211">사전 컬렉션은 사전 임을 나타내는 WCF 관련 스키마 주석으로 표시 됩니다. 그렇지 않은 경우에는 키와 값이 포함 된 항목을 포함 하는 단순 목록에서 구별할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-211">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="ed356-212">데이터 계약 스키마에서 컬렉션이 표시되는 방법에 대한 정확한 설명은 [Data Contract Schema Reference](data-contract-schema-reference.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-212">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="ed356-213">기본적으로 가져온 코드의 사용자 지정되지 않은 컬렉션에 대해서는 형식이 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-213">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="ed356-214">목록 컬렉션 형식의 데이터 멤버는 배열로 가져오며, 사전 컬렉션 형식의 데이터 멤버는 제네릭 사전으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-214">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="ed356-215">그러나 사용자 지정된 컬렉션의 경우 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성으로 표시되는 별도의 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-215">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="ed356-216">스키마의 사용자 지정 된 컬렉션 형식은 기본 네임 스페이스, 이름, 반복 요소 이름 또는 키/값 요소 이름을 사용 하지 않는 형식입니다. 이러한 형식은 <xref:System.Collections.Generic.List%601> 목록 형식 및 사전 형식에 대 한 제네릭 사전에 대해 제네릭에서 파생 되는 빈 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-216">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="ed356-217">예를 들어, 서버에 다음 형식이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-217">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="ed356-218">스키마를 내보내고 다시 가져온 경우 생성되는 클라이언트 코드는 다음과 유사합니다. 읽기 용이하도록 속성 대신 필드가 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-218">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="ed356-219">생성된 코드에서 기본 형식 대신 다른 형식을 사용해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-219">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="ed356-220">예를 들어, 사용자 인터페이스 구성 요소에 쉽게 바인딩할 수 있도록 데이터 멤버의 일반 배열 대신 제네릭 <xref:System.ComponentModel.BindingList%601> 를 사용해야 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-220">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="ed356-221">생성할 컬렉션 형식을 선택하려면 스키마를 가져올 때 사용할 컬렉션 형식의 목록을 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 개체의 <xref:System.Runtime.Serialization.ImportOptions> 속성에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-221">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="ed356-222">이러한 형식을 *참조된 컬렉션 형식*이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-222">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="ed356-223">제네릭 형식을 참조할 때 해당 제네릭 형식은 완전 개방형 제네릭 형식 또는 완전 폐쇄형 제네릭 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-223">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="ed356-224">Svcutil.exe 도구를 사용하는 경우 **/collectionType** 명령줄 스위치(약식: **/ct**)를 사용하여 이 참조를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-224">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="ed356-225">또한 **/reference** 스위치(약식: **/r**)를 사용하여 참조된 컬렉션 형식에 대한 어셈블리를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-225">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="ed356-226">형식이 제네릭이면 뒤에는 역따옴표 및 제네릭 매개 변수의 수가 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-226">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="ed356-227">큰따옴표 ()는 작은따옴표 \` (') 문자와 혼동 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-227">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="ed356-228">**/collectionType** 스위치를 두 번 이상 사용하여 여러 개의 참조된 컬렉션 형식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-228">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="ed356-229">예를 들어, 모든 목록을 제네릭 <xref:System.Collections.Generic.List%601>로 가져오려면 다음을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-229">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="ed356-230">컬렉션을 가져올 때 이 참조된 컬렉션 형식 목록을 검색한 다음 사용자 지정되지 않은 컬렉션의 경우 데이터 멤버 형식으로 컬렉션을 찾거나, 사용자 지정된 컬렉션의 경우 파생될 기본 형식으로 컬렉션을 찾아 가장 일치하는 컬렉션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-230">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="ed356-231">사전은 사전에 대해서만 일치하며 목록은 목록에 대해서만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-231">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="ed356-232">예를 들어, 제네릭 <xref:System.ComponentModel.BindingList%601> 및 <xref:System.Collections.Hashtable> 을 참조된 형식 목록에 추가하면 앞의 예제에서 생성된 클라이언트 코드는 다음과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-232">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="ed356-233">컬렉션 인터페이스 형식을 참조된 컬렉션 형식의 일부로 지정할 수 있지만 `Add` 메서드 또는 public 생성자가 없는 컬렉션 형식과 같은 잘못된 컬렉션 형식을 지정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-233">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="ed356-234">폐쇄형 제네릭이 가장 일치하는 항목으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-234">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="ed356-235">제네릭이 아닌 형식은 `Object`의 폐쇄형 제네릭과 동일한 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-235">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="ed356-236">예를 들어, <xref:System.Collections.Generic.List%601> 의 제네릭 <xref:System.DateTime>, 제네릭 <xref:System.ComponentModel.BindingList%601> (개방형 제네릭) 및 <xref:System.Collections.ArrayList> 형식이 참조된 컬렉션 형식이면 다음이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-236">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="ed356-237">목록 컬렉션에서는 다음 표에 있는 것과 같은 경우만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-237">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="ed356-238">참조된 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-238">Referenced type</span></span>|<span data-ttu-id="ed356-239">참조된 형식으로 구현된 인터페이스</span><span class="sxs-lookup"><span data-stu-id="ed356-239">Interface implemented by referenced type</span></span>|<span data-ttu-id="ed356-240">예제</span><span class="sxs-lookup"><span data-stu-id="ed356-240">Example</span></span>|<span data-ttu-id="ed356-241">처리되는 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-241">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="ed356-242">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(매개 변수 수에는 제한 없음)</span><span class="sxs-lookup"><span data-stu-id="ed356-242">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="ed356-243">제네릭이 아닌 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-243">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="ed356-244">또는</span><span class="sxs-lookup"><span data-stu-id="ed356-244">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="ed356-245">여기서 T= `int`</span><span class="sxs-lookup"><span data-stu-id="ed356-245">where T= `int`</span></span>|<span data-ttu-id="ed356-246">`Object` 의 폐쇄형 제네릭 형식(예: `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-246">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="ed356-247">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(컬렉션 형식과 일치하지 않아도 되는 임의의 수의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="ed356-247">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="ed356-248">폐쇄형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-248">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="ed356-249">또는</span><span class="sxs-lookup"><span data-stu-id="ed356-249">or</span></span><br /><br /> <span data-ttu-id="ed356-250">`MyType<T> : IList<string>` 여기서 T=`int`</span><span class="sxs-lookup"><span data-stu-id="ed356-250">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="ed356-251">폐쇄형 제네릭 형식(예: `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-251">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="ed356-252">여러 개의 매개 변수가 있는 폐쇄형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-252">Closed generic with any number of parameters</span></span>|<span data-ttu-id="ed356-253">형식의 매개 변수 중 하나를 사용하는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-253">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="ed356-254">여기서 T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="ed356-254">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="ed356-255">폐쇄형 제네릭 형식(예: `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-255">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="ed356-256">하나의 매개 변수가 있는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-256">Open generic with one parameter</span></span>|<span data-ttu-id="ed356-257">형식의 매개 변수를 사용하는 개방형 제네릭 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-257">Open generic using the type’s parameter</span></span>|<span data-ttu-id="ed356-258">`MyType<T> : IList<T>`, T는 개방형</span><span class="sxs-lookup"><span data-stu-id="ed356-258">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="ed356-259">개방형 제네릭 형식(예: `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-259">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="ed356-260">형식에서 두 개 이상의 목록 컬렉션 인터페이스를 구현하는 경우 다음 제한 사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-260">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="ed356-261">형식에서 제네릭 <xref:System.Collections.Generic.IEnumerable%601> 또는 파생된 인터페이스를 다른 형식으로 여러 번 구현하는 경우 해당 형식은 유효한 참조된 컬렉션 형식으로 간주되지 않고 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-261">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="ed356-262">일부 구현이 잘못된 경우 또는 개방형 제네릭을 사용하는 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-262">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="ed356-263">예를 들어, <xref:System.Collections.Generic.IEnumerable%601> 의 제네릭 `int` 및 T의 제네릭 <xref:System.Collections.Generic.IEnumerable%601> 을 구현하는 형식은 `int` 를 허용하는 `Add` 메서드, T 형식의 매개 변수를 허용하는 `int` 메서드 또는 두 메서드 모두가 해당 형식에 있는지 여부와 관계없이 `Add` 또는 다른 형식의 참조된 컬렉션으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-263">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="ed356-264">형식에서 <xref:System.Collections.IList>및 제네릭 컬렉션 인터페이스를 구현하는 경우 제네릭 컬렉션 인터페이스가 <xref:System.Object>형식의 폐쇄형 제네릭이 아니면 해당 형식은 참조된 컬렉션 형식으로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-264">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="ed356-265">사전 컬렉션에서는 다음 표에 있는 것과 같은 경우만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-265">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="ed356-266">참조된 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-266">Referenced type</span></span>|<span data-ttu-id="ed356-267">참조된 형식으로 구현된 인터페이스</span><span class="sxs-lookup"><span data-stu-id="ed356-267">Interface implemented by referenced type</span></span>|<span data-ttu-id="ed356-268">예제</span><span class="sxs-lookup"><span data-stu-id="ed356-268">Example</span></span>|<span data-ttu-id="ed356-269">처리되는 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-269">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="ed356-270">제네릭이 아닌 형식 또는 폐쇄형 제네릭 형식(매개 변수 수에는 제한 없음)</span><span class="sxs-lookup"><span data-stu-id="ed356-270">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="ed356-271">또는</span><span class="sxs-lookup"><span data-stu-id="ed356-271">or</span></span><br /><br /> <span data-ttu-id="ed356-272">`MyType<T> : IDictionary` 여기서 T=`int`</span><span class="sxs-lookup"><span data-stu-id="ed356-272">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="ed356-273">폐쇄형 제네릭 형식(예: `IDictionary<object,object>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-273">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="ed356-274">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="ed356-274">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ed356-275"><xref:System.Collections.Generic.IDictionary%602>, 폐쇄형</span><span class="sxs-lookup"><span data-stu-id="ed356-275"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="ed356-276">`MyType<T> : IDictionary<string, bool>` 여기서 T=`int`</span><span class="sxs-lookup"><span data-stu-id="ed356-276">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="ed356-277">폐쇄형 제네릭 형식(예: `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-277">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="ed356-278">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="ed356-278">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ed356-279">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 값 또는 키 중 하나가 폐쇄형이며, 나머지 하나는 개방형이고 형식의 매개 변수 중 하나를 사용</span><span class="sxs-lookup"><span data-stu-id="ed356-279">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="ed356-280">`MyType<T,U,V> : IDictionary<string,V>` 여기서 T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="ed356-280">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="ed356-281">또는</span><span class="sxs-lookup"><span data-stu-id="ed356-281">or</span></span><br /><br /> <span data-ttu-id="ed356-282">`MyType<Z> : IDictionary<Z,bool>` 여기서 Z=`string`</span><span class="sxs-lookup"><span data-stu-id="ed356-282">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="ed356-283">폐쇄형 제네릭 형식(예: `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-283">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="ed356-284">폐쇄형 제네릭 형식(여러 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="ed356-284">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ed356-285">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 키와 값 모두 개방형이고 각각은 형식의 매개 변수 중 하나를 사용</span><span class="sxs-lookup"><span data-stu-id="ed356-285">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="ed356-286">`MyType<T,U,V> : IDictionary<V,U>` 여기서 T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="ed356-286">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="ed356-287">폐쇄형 제네릭 형식(예: `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-287">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="ed356-288">개방형 제네릭 형식(두 개의 매개 변수)</span><span class="sxs-lookup"><span data-stu-id="ed356-288">Open generic (two parameters)</span></span>|<span data-ttu-id="ed356-289">제네릭 <xref:System.Collections.Generic.IDictionary%602>, 개방형, 형식의 제네릭 매개 변수가 나타나는 순서대로 두 개의 매개 변수 모두 사용</span><span class="sxs-lookup"><span data-stu-id="ed356-289">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="ed356-290">`MyType<K,V> : IDictionary<K,V>`, K와 V 모두 개방형</span><span class="sxs-lookup"><span data-stu-id="ed356-290">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="ed356-291">개방형 제네릭 형식(예: `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="ed356-291">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="ed356-292">형식에서 <xref:System.Collections.IDictionary> 및 제네릭 <xref:System.Collections.Generic.IDictionary%602>를 모두 구현하는 경우 제네릭 <xref:System.Collections.Generic.IDictionary%602> 만 고려됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-292">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="ed356-293">부분 제네릭 형식의 참조는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-293">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="ed356-294">예를 들어, 중복은 허용되지 않으므로 <xref:System.Collections.Generic.List%601> 의 제네릭 `Integer` 및 `Integer` 의 제네릭 컬렉션을 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>에 모두 추가할 수는 없습니다. 이는 정수 목록이 스키마에 있는 경우 사용할 대상을 결정할 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-294">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="ed356-295">중복 문제를 노출하는 형식이 스키마에 있는 경우에만 중복이 감지됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-295">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="ed356-296">예를 들어, 가져오는 스키마에 정수 목록이 없는 경우 <xref:System.Collections.Generic.List%601> 의 제네릭 `Integer` 및 `Integer` 에 있는 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>의 제네릭 컬렉션을 모두 포함할 수 있지만 둘 다 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-296">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="ed356-297">고급 컬렉션 규칙</span><span class="sxs-lookup"><span data-stu-id="ed356-297">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="ed356-298">컬렉션 serialize</span><span class="sxs-lookup"><span data-stu-id="ed356-298">Serializing Collections</span></span>

<span data-ttu-id="ed356-299">컬렉션 serialization 규칙 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-299">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="ed356-300">컬렉션의 컬렉션이 있는 컬렉션 형식의 결합이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-300">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="ed356-301">가변 배열은 컬렉션의 컬렉션으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-301">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="ed356-302">다차원 배열은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-302">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="ed356-303">바이트의 배열 및 <xref:System.Xml.XmlNode> 의 배열은 컬렉션이 아닌 기본 형식으로 처리되는 특수 배열 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-303">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="ed356-304">바이트의 배열을 serialize하면 각 바이트에 대한 별도의 요소 대신 Base64 인코딩된 데이터의 청크가 포함된 하나의 XML 요소가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-304">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="ed356-305">의 배열을 처리 하는 방법에 대 한 자세한 내용은 <xref:System.Xml.XmlNode> [데이터 계약의 XML 및 ADO.NET 형식](xml-and-ado-net-types-in-data-contracts.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ed356-305">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="ed356-306">물론 이러한 특수 형식은 컬렉션에 참여할 수 있습니다. 바이트 배열의 배열은 여러 XML 요소가 되며 각 요소는 Base64 인코딩된 데이터의 청크를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-306">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="ed356-307"><xref:System.Runtime.Serialization.DataContractAttribute> 특성이 컬렉션 형식에 적용되는 경우 해당 형식은 컬렉션이 아닌 일반 데이터 계약 형식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-307">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="ed356-308">컬렉션 형식이 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 경우 `myType:IList<string>, IXmlSerializable`형식이 지정된 다음 규칙이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-308">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="ed356-309">선언된 형식이 `IList<string>`인 경우 형식이 목록으로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-309">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="ed356-310">선언된 형식이 `myType`인 경우 형식이 `IXmlSerializable`로 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-310">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="ed356-311">선언된 형식이 `IXmlSerializable`인 경우 `IXmlSerializable`로 serialize되지만 `myType` 을 알려진 형식 목록에 추가하는 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-311">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="ed356-312">컬렉션은 다음 표에 나와 있는 메서드를 사용하여 직렬화되고 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-312">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="ed356-313">컬렉션 형식에서 구현하는 인터페이스</span><span class="sxs-lookup"><span data-stu-id="ed356-313">Collection type implements</span></span>|<span data-ttu-id="ed356-314">serialization에서 호출된 메서드</span><span class="sxs-lookup"><span data-stu-id="ed356-314">Method(s) called on serialization</span></span>|<span data-ttu-id="ed356-315">deserialization에서 호출된 메서드</span><span class="sxs-lookup"><span data-stu-id="ed356-315">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="ed356-316">제네릭 <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="ed356-316">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="ed356-317">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="ed356-317">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="ed356-318">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="ed356-318">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="ed356-319">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="ed356-319">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="ed356-320">제네릭 <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="ed356-320">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="ed356-321">제네릭 <xref:System.Collections.Generic.IList%601> 인덱서</span><span class="sxs-lookup"><span data-stu-id="ed356-321">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="ed356-322">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="ed356-322">Generic Add</span></span>|
|<span data-ttu-id="ed356-323">제네릭 <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="ed356-323">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="ed356-324">Enumerator</span><span class="sxs-lookup"><span data-stu-id="ed356-324">Enumerator</span></span>|<span data-ttu-id="ed356-325">제네릭 Add</span><span class="sxs-lookup"><span data-stu-id="ed356-325">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="ed356-326"><xref:System.Collections.IList> 인덱서</span><span class="sxs-lookup"><span data-stu-id="ed356-326"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="ed356-327">제네릭 <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="ed356-327">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="ed356-328">적절한 형식(제네릭 매개 변수의 형식 또는 기본 형식 중 하나)의 매개 변수 하나를 사용하는 `Add` 라는 비정적 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-328">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="ed356-329">해당 메서드는 serialization 및 deserialization을 수행하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리하도록 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-329">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="ed356-330"><xref:System.Collections.IEnumerable> 및 여기서 파생된 <xref:System.Collections.ICollection></span><span class="sxs-lookup"><span data-stu-id="ed356-330"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="ed356-331">`Add` 형식의 매개 변수 하나를 사용하는 `Object`라는 비정적 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-331">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="ed356-332">해당 메서드는 serialization 및 deserialization을 수행하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리하도록 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-332">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="ed356-333">위 표에는 컬렉션 인터페이스의 우선 순위가 내림차순으로 나열되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-333">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="ed356-334">예를 들어, 형식에서 <xref:System.Collections.IList> 및 제네릭 <xref:System.Collections.Generic.IEnumerable%601>을 모두 구현하는 경우 컬렉션은 다음과 같은 <xref:System.Collections.IList> 규칙에 따라 직렬화되고 역직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-334">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="ed356-335">Deserialization에서 모든 컬렉션은 먼저 매개 변수가 없는 생성자를 호출 하 여 형식의 인스턴스를 만듭니다 .이 생성자는 serialization 및 deserialization을 수행 하는 동안 serializer에서 컬렉션 형식을 컬렉션으로 처리 하는 데 존재 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-335">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="ed356-336">동일한 제네릭 컬렉션 인터페이스가 두 번 이상 구현되고(예를 들어, 형식이 <xref:System.Collections.Generic.ICollection%601> 의 제네릭 `Integer` 및 <xref:System.Collections.Generic.ICollection%601> 의 제네릭 <xref:System.String>을 모두 구현하는 경우), 우선 순위가 더 높은 인터페이스가 없는 경우 컬렉션은 유효한 컬렉션으로 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-336">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="ed356-337">컬렉션 형식은 이 컬렉션 형식에 적용된 <xref:System.SerializableAttribute> 특성을 가질 수 있으며, <xref:System.Runtime.Serialization.ISerializable> 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-337">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="ed356-338">이 특성 및 인터페이스가 모두 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-338">Both of these are ignored.</span></span> <span data-ttu-id="ed356-339">그러나 `Add` 메서드가 없는 경우와 같이 형식에서 컬렉션 형식 요구 사항을 충분히 충족하지 않는 경우 형식은 컬렉션 형식으로 간주되지 않으므로 <xref:System.SerializableAttribute> 특성 및 <xref:System.Runtime.Serialization.ISerializable> 인터페이스에 의해 형식이 serialize될 수 있는지 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-339">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="ed356-340">컬렉션을 사용자 지정하기 위해 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 컬렉션에 적용하면 위의 <xref:System.SerializableAttribute> 대체 메커니즘이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-340">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="ed356-341">대신 사용자 지정된 컬렉션에서 컬렉션 형식 요구 사항을 충족하지 않는 경우 <xref:System.Runtime.Serialization.InvalidDataContractException> 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-341">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="ed356-342">예외 문자열에는 지정 된 형식이 유효한 컬렉션으로 간주 되지 않는 이유를 설명 하는 정보가 포함 되어 있습니다 ( `Add` 메서드 없음, 매개 변수가 없는 생성자 등). 따라서 디버깅 목적으로 특성을 적용 하는 것이 유용한 경우가 많습니다 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="ed356-342">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="ed356-343">컬렉션 명명</span><span class="sxs-lookup"><span data-stu-id="ed356-343">Collection Naming</span></span>

<span data-ttu-id="ed356-344">컬렉션 명명 규칙 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-344">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="ed356-345">모든 사전 컬렉션 데이터 계약의 기본 네임 스페이스와 기본 형식이 포함 된 목록 컬렉션 데이터 계약의 기본 네임 스페이스는 `http://schemas.microsoft.com/2003/10/Serialization/Arrays` 네임 스페이스를 사용 하 여 재정의 되지 않는 한입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-345">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="ed356-346">`char`, `Timespan`및 `Guid` 형식과 함께 기본 제공 XSD 형식에 매핑되는 형식은 이러한 목적으로 기본 형식으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-346">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="ed356-347">기본 형식이 아닌 형식이 포함된 컬렉션 형식의 기본 네임스페이스는 Namespace를 사용하여 재정의되지 않는 한 컬렉션에 포함된 형식의 데이터 계약 네임스페이스와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-347">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="ed356-348">목록 컬렉션 데이터 계약의 기본 이름은 Name을 사용하여 재정의되지 않는 한 컬렉션에 포함된 형식의 데이터 계약 이름과 결합된 문자열인 "ArrayOf"입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-348">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="ed356-349">예를 들어, 정수의 제네릭 목록에 대한 데이터 계약 이름은 "ArrayOfint"입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-349">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="ed356-350">`Object` 의 데이터 계약 이름은 "anyType"이므로 <xref:System.Collections.ArrayList> 와 같은 제네릭이 아닌 목록의 데이터 계약 이름은 "ArrayOfanyType"입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-350">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="ed356-351">사전 컬렉션 데이터 계약의 기본 이름은 `Name`을 사용하여 재정의되지 않는 한 값 형식의 데이터 계약 이름 앞에 나오는 키 형식의 데이터 계약 이름과 결합된 문자열 "ArrayOfKeyValueOf"입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-351">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="ed356-352">예를 들어, 문자열 및 정수의 제네릭 사전에 대한 데이터 계약 이름은 "ArrayOfKeyValueOfstringint"입니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-352">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="ed356-353">또한 키 또는 값 형식 중 하나가 기본 형식이 아닌 경우 키 및 값 형식의 데이터 계약 네임스페이스의 네임스페이스 해시가 이름에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-353">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="ed356-354">네임 스페이스 해시에 대 한 자세한 내용은 [데이터 계약 이름](data-contract-names.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ed356-354">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="ed356-355">각 사전 컬렉션 데이터 계약에는 사전에 있는 하나의 항목을 나타내는 도우미 데이터 계약이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-355">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="ed356-356">이 계약의 이름은 "ArrayOf" 접두사를 제외하고 사전 데이터 계약과 동일하며 네임스페이스는 사전 데이터 계약과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-356">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="ed356-357">예를 들어, "ArrayOfKeyValueOfstringint" 사전 데이터 계약의 경우 "KeyValueofstringint" 데이터 계약은 사전에 있는 하나의 항목을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-357">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="ed356-358">다음 단원에서 설명한 대로 `ItemName` 속성을 사용하여 이 데이터 계약의 이름을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-358">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="ed356-359">제네릭 형식 명명 규칙은 [Data Contract Names](data-contract-names.md)에서 설명한 대로 컬렉션 형식에 완전히 적용됩니다. 즉, 이름 내에 중괄호를 사용하여 제네릭 형식 매개 변수를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-359">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="ed356-360">그러나 괄호 내의 수는 컬렉션 내에 포함된 형식이 아닌 제네릭 매개 변수를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-360">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="ed356-361">컬렉션 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="ed356-361">Collection Customization</span></span>

<span data-ttu-id="ed356-362"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성은 다음과 같이 사용할 수 없으며, 다음과 같이 사용된 경우 <xref:System.Runtime.Serialization.InvalidDataContractException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-362">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="ed356-363"><xref:System.Runtime.Serialization.DataContractAttribute> 특성을 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성이 적용된 형식이나 파생 형식 중 하나에 적용</span><span class="sxs-lookup"><span data-stu-id="ed356-363">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="ed356-364"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스를 구현하는 형식에 적용</span><span class="sxs-lookup"><span data-stu-id="ed356-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="ed356-365"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 비컬렉션 형식에 적용</span><span class="sxs-lookup"><span data-stu-id="ed356-365">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="ed356-366">사전이 아닌 형식에 적용된 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 특성에 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 또는 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 을 설정하려는 경우</span><span class="sxs-lookup"><span data-stu-id="ed356-366">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="ed356-367">다형성 규칙</span><span class="sxs-lookup"><span data-stu-id="ed356-367">Polymorphism Rules</span></span>

<span data-ttu-id="ed356-368">이미 설명한 바와 같이 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 특성을 사용하여 컬렉션을 사용자 지정하면 컬렉션 교환 가능성에 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-368">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="ed356-369">사전 컬렉션에서 키 및 값 이름뿐만 아니라 사전 컬렉션의 이름, 네임스페이스, 항목 이름이 일치하는 경우에만 사용자 지정된 두 개의 컬렉션 형식을 동일한 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-369">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="ed356-370">사용자 지정으로 인해 두 개 중 한 컬렉션 데이터 계약이 필요한 곳에 다른 나머지 컬렉션 데이터 계약을 잘못 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-370">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="ed356-371">이러한 경우가 발생해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-371">This should be avoided.</span></span> <span data-ttu-id="ed356-372">다음 형식을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ed356-372">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="ed356-373">이 경우 `Marks1` 의 인스턴스는 `testMarks`에 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-373">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="ed356-374">그러나 데이터 계약이 `Marks2` 데이터 계약과 동일하지 않으므로 `IList<int>` 를 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-374">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="ed356-375">데이터 계약 이름은 "ArrayOfint"가 아니라 "Marks2"이 고 반복 되는 요소 이름은 ""이 아니라 ""입니다 \<mark> \<int> .</span><span class="sxs-lookup"><span data-stu-id="ed356-375">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="ed356-376">다음 표의 규칙은 컬렉션의 다형적 할당에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-376">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="ed356-377">선언된 형식</span><span class="sxs-lookup"><span data-stu-id="ed356-377">Declared type</span></span>|<span data-ttu-id="ed356-378">사용자 지정되지 않은 컬렉션 할당</span><span class="sxs-lookup"><span data-stu-id="ed356-378">Assigning a non-customized collection</span></span>|<span data-ttu-id="ed356-379">사용자 지정된 컬렉션 할당</span><span class="sxs-lookup"><span data-stu-id="ed356-379">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="ed356-380">Object</span><span class="sxs-lookup"><span data-stu-id="ed356-380">Object</span></span>|<span data-ttu-id="ed356-381">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-381">Contract name is serialized.</span></span>|<span data-ttu-id="ed356-382">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-382">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ed356-383">사용자 지정이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-383">Customization is used.</span></span>|
|<span data-ttu-id="ed356-384">컬렉션 인터페이스</span><span class="sxs-lookup"><span data-stu-id="ed356-384">Collection interface</span></span>|<span data-ttu-id="ed356-385">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-385">Contract name is not serialized.</span></span>|<span data-ttu-id="ed356-386">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-386">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="ed356-387">사용자 지정은 사용 되지 않습니다.\*</span><span class="sxs-lookup"><span data-stu-id="ed356-387">Customization is not used.\*</span></span>|
|<span data-ttu-id="ed356-388">사용자 지정되지 않은 컬렉션</span><span class="sxs-lookup"><span data-stu-id="ed356-388">Non-customized collection</span></span>|<span data-ttu-id="ed356-389">계약 이름이 serialize되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-389">Contract name is not serialized.</span></span>|<span data-ttu-id="ed356-390">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-390">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ed356-391">사용자 지정이 사용됩니다.\*\*</span><span class="sxs-lookup"><span data-stu-id="ed356-391">Customization is used.\*\*</span></span>|
|<span data-ttu-id="ed356-392">사용자 지정된 컬렉션</span><span class="sxs-lookup"><span data-stu-id="ed356-392">Customized collection</span></span>|<span data-ttu-id="ed356-393">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-393">Contract name is serialized.</span></span> <span data-ttu-id="ed356-394">사용자 지정은 사용 되지 않습니다.\*\*</span><span class="sxs-lookup"><span data-stu-id="ed356-394">Customization is not used.\*\*</span></span>|<span data-ttu-id="ed356-395">계약 이름이 serialize되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-395">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ed356-396">할당 된 형식의 사용자 지정이 사용 됩니다.\*\*</span><span class="sxs-lookup"><span data-stu-id="ed356-396">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="ed356-397">\*이 경우 클래스를 사용 하 여 <xref:System.Runtime.Serialization.NetDataContractSerializer> 사용자 지정을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-397">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="ed356-398">또한 <xref:System.Runtime.Serialization.NetDataContractSerializer> 클래스는 이 경우의 실제 형식 이름을 serialize하므로 deserialization이 예상대로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-398">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="ed356-399">\*\*이러한 경우 스키마에 맞지 않는 인스턴스가 발생 하므로이를 피해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-399">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="ed356-400">계약 이름이 serialize된 경우에는 할당된 컬렉션 형식이 알려진 형식 목록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-400">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="ed356-401">반대의 경우도 마찬가지입니다. 이름이 serialize되지 않은 경우에는 형식을 알려진 형식 목록에 추가할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-401">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="ed356-402">파생 형식의 배열은 기본 형식의 배열에 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-402">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="ed356-403">이 경우 파생 형식의 계약 이름이 반복되는 각 요소에 serialize됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-403">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="ed356-404">예를 들어, `Book` 형식이 `LibraryItem`형식에서 파생되는 경우 `Book` 의 배열을 `LibraryItem`의 배열에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-404">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="ed356-405">이는 다른 컬렉션 형식에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-405">This does not apply to other collection types.</span></span> <span data-ttu-id="ed356-406">예를 들어, `Generic List of Book` 을 `Generic List of LibraryItem`에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-406">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="ed356-407">그러나 `Generic List of LibraryItem` 인스턴스를 포함하는 `Book` 을 할당할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-407">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="ed356-408">배열인 경우든 배열이 아닌 경우든 `Book` 은 알려진 형식 목록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-408">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="ed356-409">컬렉션 및 개체 참조 유지</span><span class="sxs-lookup"><span data-stu-id="ed356-409">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="ed356-410">serializer가 개체 참조를 유지하는 모드에서 작동하는 경우 개체 참조 유지도 컬렉션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-410">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="ed356-411">특히 개체 ID는 전체 컬렉션 및 컬렉션에 포함된 개별 항목 모두에 대해 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-411">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="ed356-412">사전의 경우 개체 ID는 키/값 쌍 개체, 개별 키 개체 및 값 개체 모두에 대해 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed356-412">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="ed356-413">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ed356-413">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
