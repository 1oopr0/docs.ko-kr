---
title: 오류 보내기 및 받기
description: 오류 조건이 발생할 때 서비스 또는 이중 클라이언트에서 SOAP 오류를 보내는 방법과 클라이언트 또는 서비스 응용 프로그램이 이러한 오류를 처리 하는 방법을 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling faults [WCF], sending
ms.assetid: 7be6fb96-ce2a-450b-aebe-f932c6a4bc5d
ms.openlocfilehash: 23f63fde2755a29cd545d3aefe699cad8dbecb3b
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244324"
---
# <a name="sending-and-receiving-faults"></a><span data-ttu-id="3dfd2-103">오류 보내기 및 받기</span><span class="sxs-lookup"><span data-stu-id="3dfd2-103">Sending and Receiving Faults</span></span>

<span data-ttu-id="3dfd2-104">SOAP 오류는 오류 조건 정보를 서비스에서 클라이언트로 전달하고 이중 클라이언트의 경우에는 상호 운용 가능한 방식으로 클라이언트에서 서비스로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-104">SOAP faults convey error condition information from a service to a client and in the duplex case from a client to a service in an interoperable way.</span></span> <span data-ttu-id="3dfd2-105">일반적으로 서비스는 사용자 지정 오류 내용을 정의하고 이들을 반환할 수 있는 작업을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-105">Typically a service defines custom fault content and specifies which operations can return them.</span></span> <span data-ttu-id="3dfd2-106">자세한 내용은 [오류 정의 및 지정](defining-and-specifying-faults.md)을 참조 하세요. 이 항목에서는 해당 오류 조건이 발생 했을 때 서비스 또는 이중 클라이언트에서 이러한 오류를 보내는 방법과 클라이언트 또는 서비스 응용 프로그램이 이러한 오류를 처리 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-106">(For more information, see [Defining and Specifying Faults](defining-and-specifying-faults.md).) This topic discusses how a service or duplex client can send those faults when the corresponding error condition has occurred and how a client or service application handles these faults.</span></span> <span data-ttu-id="3dfd2-107">WCF (Windows Communication Foundation) 응용 프로그램의 오류 처리에 대 한 개요는 [계약 및 서비스에서 오류 지정 및 처리](specifying-and-handling-faults-in-contracts-and-services.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-107">For an overview of error handling in Windows Communication Foundation (WCF) applications, see [Specifying and Handling Faults in Contracts and Services](specifying-and-handling-faults-in-contracts-and-services.md).</span></span>

## <a name="sending-soap-faults"></a><span data-ttu-id="3dfd2-108">SOAP 오류 보내기</span><span class="sxs-lookup"><span data-stu-id="3dfd2-108">Sending SOAP Faults</span></span>

<span data-ttu-id="3dfd2-109">선언된 SOAP 오류는 작업에 사용자 지정 SOAP 오류 유형을 지정하는 <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType>가 있는 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-109">Declared SOAP faults are those in which an operation has a <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType> that specifies a custom SOAP fault type.</span></span> <span data-ttu-id="3dfd2-110">선언되지 않은 SOAP 오류는 작업 계약에 지정되지 않은 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-110">Undeclared SOAP faults are those that are not specified in the contract for an operation.</span></span>

### <a name="sending-declared-faults"></a><span data-ttu-id="3dfd2-111">선언된 오류 보내기</span><span class="sxs-lookup"><span data-stu-id="3dfd2-111">Sending Declared Faults</span></span>

<span data-ttu-id="3dfd2-112">선언된 SOAP 오류를 보내려면 SOAP 오류가 적합한 오류 조건을 검색하고 새 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType>을 throw합니다. 여기서, 형식 매개 변수는 해당 작업의 <xref:System.ServiceModel.FaultContractAttribute>에 지정된 형식의 새 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-112">To send a declared SOAP fault, detect the error condition for which the SOAP fault is appropriate and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> where the type parameter is a new object of the type specified in the <xref:System.ServiceModel.FaultContractAttribute> for that operation.</span></span> <span data-ttu-id="3dfd2-113">다음 코드 예제에서는를 사용 하 여 <xref:System.ServiceModel.FaultContractAttribute> `SampleMethod` 작업에서의 세부 형식으로 SOAP 오류를 반환할 수 있도록 지정 하는 방법을 보여 줍니다 `GreetingFault` .</span><span class="sxs-lookup"><span data-stu-id="3dfd2-113">The following code example shows the use of <xref:System.ServiceModel.FaultContractAttribute> to specify that the `SampleMethod` operation can return a SOAP fault with the detail type of `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#4](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#4)]
[!code-vb[FaultContractAttribute#4](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#4)]

<span data-ttu-id="3dfd2-114">`GreetingFault` 오류 정보를 클라이언트에게 전달하려면 적합한 오류 조건을 catch하고 다음 코드 예제처럼 새 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> 개체가 인수인 `GreetingFault` 유형의 새 `GreetingFault`을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-114">To convey the `GreetingFault` error information to the client, catch the appropriate error condition and throw a new <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault` with a new `GreetingFault` object as the argument, as in the following code example.</span></span> <span data-ttu-id="3dfd2-115">클라이언트가 WCF 클라이언트 응용 프로그램 인 경우 형식이 형식의 인 관리 되는 예외입니다 <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> `GreetingFault` .</span><span class="sxs-lookup"><span data-stu-id="3dfd2-115">If the client is an WCF client application, it experiences this as a managed exception where the type is <xref:System.ServiceModel.FaultException%601?displayProperty=nameWithType> of type `GreetingFault`.</span></span>

[!code-csharp[FaultContractAttribute#5](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/services.cs#5)]
[!code-vb[FaultContractAttribute#5](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/services.vb#5)]

### <a name="sending-undeclared-faults"></a><span data-ttu-id="3dfd2-116">선언되지 않은 오류 보내기</span><span class="sxs-lookup"><span data-stu-id="3dfd2-116">Sending Undeclared Faults</span></span>

<span data-ttu-id="3dfd2-117">선언 되지 않은 오류는 WCF 응용 프로그램의 문제를 신속 하 게 진단 하 고 디버깅 하는 데 매우 유용할 수 있지만 디버깅 도구로 서의 유용성은 제한 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-117">Sending undeclared faults can be very useful to quickly diagnose and debug problems in WCF applications, but its usefulness as a debugging tool is limited.</span></span> <span data-ttu-id="3dfd2-118">일반적으로 디버깅할 때 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 속성을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-118">More generally, when debugging it is recommended that you use the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3dfd2-119">이 값을 true로 설정하면 클라이언트에 <xref:System.ServiceModel.FaultException%601> 형식의 <xref:System.ServiceModel.ExceptionDetail> 예외와 같은 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-119">When you set this value to true, clients experience such faults as <xref:System.ServiceModel.FaultException%601> exceptions of type <xref:System.ServiceModel.ExceptionDetail>.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3dfd2-120">관리 되는 예외는 내부 애플리케이션 정보를 노출할 수, 있으므로 설정 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 나 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 에 `true` WCF 클라이언트에서는 개인적으로 포함 하 여 내부 서비스 작업 예외에 대 한 정보를 허용 하려면 식별할 수 있는 정보나 기타 중요 한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-120">Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.</span></span>
>
> <span data-ttu-id="3dfd2-121">그러므로 임시로 서비스 애플리케이션을 디버깅하려는 경우 권장되는 유일한 방법은 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 또는 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType>를 `true`로 설정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-121">Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is only recommended as a way of temporarily debugging a service application.</span></span> <span data-ttu-id="3dfd2-122">또한 이 방법으로 처리되지 않은 관리되는 예외를 반환하는 메서드의 WSDL에는 <xref:System.ServiceModel.FaultException%601> 형식의 <xref:System.ServiceModel.ExceptionDetail>에 대한 계약이 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-122">In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="3dfd2-123">클라이언트에서는 알 수 없는 SOAP 오류 (WCF 클라이언트에 개체로 반환 됨)가 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 디버깅 정보를 제대로 가져올 가능성을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-123">Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly.</span></span>

<span data-ttu-id="3dfd2-124">선언되지 않은 SOAP 오류를 보내려면 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 개체(즉, 제네릭 형식 <xref:System.ServiceModel.FaultException%601>이 아님)를 throw하고 문자열을 생성자에게 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-124">To send an undeclared SOAP fault, throw a <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> object (that is, not the generic type <xref:System.ServiceModel.FaultException%601>) and pass the string to the constructor.</span></span> <span data-ttu-id="3dfd2-125">이는 <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> 메서드를 호출 하 여 문자열을 사용할 수 있는 throw 된 예외로 WCF 클라이언트 응용 프로그램에 노출 됩니다 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="3dfd2-125">This is exposed to the WCF client applications as a thrown <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> exception where the string is available by calling the <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType> method.</span></span>

> [!NOTE]
> <span data-ttu-id="3dfd2-126">문자열 형식의 SOAP 오류를 선언한 다음 서비스에서 형식 매개 변수가 <xref:System.ServiceModel.FaultException%601>인 <xref:System.String?displayProperty=nameWithType>로 throw하면 문자열 값이 <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> 속성에 지정되며 <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType>에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-126">If you declare a SOAP fault of type string, and then throw this in your service as a <xref:System.ServiceModel.FaultException%601> where the type parameter is a <xref:System.String?displayProperty=nameWithType> the string value is assigned to the <xref:System.ServiceModel.FaultException%601.Detail%2A?displayProperty=nameWithType> property, and is not available from <xref:System.ServiceModel.FaultException%601.ToString%2A?displayProperty=nameWithType>.</span></span>

## <a name="handling-faults"></a><span data-ttu-id="3dfd2-127">오류 처리</span><span class="sxs-lookup"><span data-stu-id="3dfd2-127">Handling Faults</span></span>

<span data-ttu-id="3dfd2-128">WCF 클라이언트에서 클라이언트 응용 프로그램에 관심이 있는 통신 중에 발생 하는 SOAP 오류는 관리 되는 예외로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-128">In WCF clients, SOAP faults that occur during communication that are of interest to client applications are raised as managed exceptions.</span></span> <span data-ttu-id="3dfd2-129">모든 프로그램을 실행 하는 동안 발생할 수 있는 많은 예외가 있지만 WCF 클라이언트 프로그래밍 모델을 사용 하는 응용 프로그램은 통신의 결과로 다음과 같은 두 형식의 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-129">While there are many exceptions that can occur during the execution of any program, applications using the WCF client programming model can expect to handle exceptions of the following two types as a result of communication.</span></span>

- <xref:System.TimeoutException>

- <xref:System.ServiceModel.CommunicationException>

<span data-ttu-id="3dfd2-130">작업이 지정된 제한 시간을 초과하면 <xref:System.TimeoutException> 개체가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-130"><xref:System.TimeoutException> objects are thrown when an operation exceeds the specified timeout period.</span></span>

<span data-ttu-id="3dfd2-131">서비스나 클라이언트에 복구할 수 있는 통신 오류 조건이 있는 경우 <xref:System.ServiceModel.CommunicationException> 개체가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-131"><xref:System.ServiceModel.CommunicationException> objects are thrown when there is some recoverable communication error condition on either the service or the client.</span></span>

<span data-ttu-id="3dfd2-132"><xref:System.ServiceModel.CommunicationException> 클래스에는 두 가지 중요한 파생 형식인 <xref:System.ServiceModel.FaultException>과 제네릭 <xref:System.ServiceModel.FaultException%601> 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-132">The <xref:System.ServiceModel.CommunicationException> class has two important derived types, <xref:System.ServiceModel.FaultException> and the generic <xref:System.ServiceModel.FaultException%601> type.</span></span>

<span data-ttu-id="3dfd2-133">수신자가 작업 계약에 예상되지 않거나 지정되지 않은 오류를 받으면 <xref:System.ServiceModel.FaultException> 예외가 throw됩니다. 일반적으로 이러한 예외는 애플리케이션이 디버깅 중이고 서비스의 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 속성이 `true`로 설정된 경우 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-133"><xref:System.ServiceModel.FaultException> exceptions are thrown when a listener receives a fault that is not expected or specified in the operation contract; usually this occurs when the application is being debugged and the service has the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true`.</span></span>

<span data-ttu-id="3dfd2-134">양방향 작업(즉, <xref:System.ServiceModel.FaultException%601>가 <xref:System.ServiceModel.OperationContractAttribute>로 설정된 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> 특성이 있는 메서드)에 대한 응답으로 작업 계약에 지정된 오류를 받은 경우 클라이언트에서 `false` 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-134"><xref:System.ServiceModel.FaultException%601> exceptions are thrown on the client when a fault that is specified in the operation contract is received in response to a two-way operation (that is, a method with an <xref:System.ServiceModel.OperationContractAttribute> attribute with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> set to `false`).</span></span>

> [!NOTE]
> <span data-ttu-id="3dfd2-135">WCF 서비스에 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> 또는 속성이로 설정 된 경우 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> `true` 클라이언트는이를 형식의 선언 되지 않은로 설정 <xref:System.ServiceModel.FaultException%601> <xref:System.ServiceModel.ExceptionDetail> 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-135">When an WCF service has the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property set to `true` the client experiences this as an undeclared <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>.</span></span> <span data-ttu-id="3dfd2-136">클라이언트는 이러한 특정 오류를 catch하거나 <xref:System.ServiceModel.FaultException>에 대한 catch 블록의 오류를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-136">Clients can either catch this specific fault or handle the fault in a catch block for <xref:System.ServiceModel.FaultException>.</span></span>

<span data-ttu-id="3dfd2-137">일반적으로 <xref:System.ServiceModel.FaultException%601>, <xref:System.TimeoutException> 및 <xref:System.ServiceModel.CommunicationException> 예외만 클라이언트와 서비스에 관련된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-137">Typically, only <xref:System.ServiceModel.FaultException%601>, <xref:System.TimeoutException>, and <xref:System.ServiceModel.CommunicationException> exceptions are of interest to clients and services.</span></span>

> [!NOTE]
> <span data-ttu-id="3dfd2-138">물론 다른 예외도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-138">Other exceptions, of course, do occur.</span></span> <span data-ttu-id="3dfd2-139">예기치 않은 예외가 <xref:System.OutOfMemoryException?displayProperty=nameWithType>과 같은 오류를 포함합니다. 일반적으로 애플리케이션은 그러한 메서드를 catch하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-139">Unexpected exceptions include catastrophic failures like <xref:System.OutOfMemoryException?displayProperty=nameWithType>; typically applications should not catch such methods.</span></span>

### <a name="catch-fault-exceptions-in-the-correct-order"></a><span data-ttu-id="3dfd2-140">올바른 순서로 오류 예외 catch</span><span class="sxs-lookup"><span data-stu-id="3dfd2-140">Catch Fault Exceptions in the Correct Order</span></span>

<span data-ttu-id="3dfd2-141"><xref:System.ServiceModel.FaultException%601>은 <xref:System.ServiceModel.FaultException>에서 파생되고 <xref:System.ServiceModel.FaultException>은 <xref:System.ServiceModel.CommunicationException>에서 파생되므로 적합한 순서로 이러한 예외를 catch하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-141">Because <xref:System.ServiceModel.FaultException%601> derives from <xref:System.ServiceModel.FaultException>, and <xref:System.ServiceModel.FaultException> derives from <xref:System.ServiceModel.CommunicationException>, it is important to catch these exceptions in the proper order.</span></span> <span data-ttu-id="3dfd2-142">예를 들어 먼저 <xref:System.ServiceModel.CommunicationException>을 catch하는 try/catch 블록이 있는 경우 모든 지정된 SOAP 오류와 지정되지 않은 SOAP 오류가 여기서 처리됩니다. 사용자 지정 <xref:System.ServiceModel.FaultException%601> 예외를 처리할 이후 catch 블록은 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-142">If, for example, you have a try/catch block in which you first catch <xref:System.ServiceModel.CommunicationException>, all specified and unspecified SOAP faults are handled there; any subsequent catch blocks to handle a custom <xref:System.ServiceModel.FaultException%601> exception are never invoked.</span></span>

<span data-ttu-id="3dfd2-143">하나의 작업이 여러 개의 지정된 오류를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-143">Remember that one operation can return any number of specified faults.</span></span> <span data-ttu-id="3dfd2-144">각 오류는 고유한 형식이며 별도로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-144">Each fault is a unique type and must be handled separately.</span></span>

### <a name="handle-exceptions-when-closing-the-channel"></a><span data-ttu-id="3dfd2-145">채널을 닫을 때 예외 처리</span><span class="sxs-lookup"><span data-stu-id="3dfd2-145">Handle Exceptions When Closing the Channel</span></span>

<span data-ttu-id="3dfd2-146">위에서 설명한 대부분의 논의는 응용 프로그램 메시지, 즉 클라이언트 응용 프로그램이 WCF 클라이언트 개체에서 작업을 호출 하는 경우 클라이언트에서 명시적으로 보내는 메시지를 처리 하는 과정에서 전송 되는 오류를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-146">Most of the preceding discussion has to do with faults sent in the course of processing application messages, that is, messages explicitly sent by the client when the client application calls operations on the WCF client object.</span></span>

<span data-ttu-id="3dfd2-147">로컬 개체 외에도 개체를 삭제하면 재활용 프로세스 중에 발생하는 예외를 발생시키거나 마스킹할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-147">Even with local objects disposing the object can either raise or mask exceptions that occur during the recycling process.</span></span> <span data-ttu-id="3dfd2-148">WCF 클라이언트 개체를 사용 하는 경우 비슷한 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-148">Something similar can occur when you use WCF client objects.</span></span> <span data-ttu-id="3dfd2-149">작업을 호출할 때 설정된 연결을 통해 메시지를 보내게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-149">When you call operations you are sending messages over an established connection.</span></span> <span data-ttu-id="3dfd2-150">연결을 완전히 종료할 수 없거나 연결이 이미 종료된 경우, 모든 작업이 제대로 반환되어도 채널을 닫으면 예외가 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-150">Closing the channel can throw exceptions if the connection cannot be cleanly closed or is already closed, even if all the operations returned properly.</span></span>

<span data-ttu-id="3dfd2-151">일반적으로 클라이언트 개체 채널은 다음 중 한 가지 방법으로 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-151">Typically, client object channels are closed in one of the following ways:</span></span>

- <span data-ttu-id="3dfd2-152">WCF 클라이언트 개체가 재활용 될 때.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-152">When the WCF client object is recycled.</span></span>

- <span data-ttu-id="3dfd2-153">클라이언트 애플리케이션이 <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType>를 호출하는 경우</span><span class="sxs-lookup"><span data-stu-id="3dfd2-153">When the client application calls <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="3dfd2-154">클라이언트 애플리케이션이 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType>를 호출하는 경우</span><span class="sxs-lookup"><span data-stu-id="3dfd2-154">When the client application calls <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="3dfd2-155">클라이언트 애플리케이션이 세션에 대한 종료 작업을 호출하는 경우</span><span class="sxs-lookup"><span data-stu-id="3dfd2-155">When the client application calls an operation that is a terminating operation for a session.</span></span>

<span data-ttu-id="3dfd2-156">모든 경우에 채널을 닫으면 애플리케이션 수준에서 복잡한 기능을 지원할 메시지를 보낼 수 있는 기본 채널을 닫도록 채널에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-156">In all cases, closing the channel instructs the channel to begin closing any underlying channels that may be sending messages to support complex functionality at the application level.</span></span> <span data-ttu-id="3dfd2-157">예를 들어 계약에 세션이 필요한 경우 세션이 설정될 때까지 바인딩 과정에서 서비스 채널과 메시지를 교환하여 세션을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-157">For example, when a contract requires sessions a binding attempts to establish a session by exchanging messages with the service channel until a session is established.</span></span> <span data-ttu-id="3dfd2-158">채널이 닫히면 기본 세션 채널은 세션이 종료되었음을 서비스에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-158">When the channel is closed, the underlying session channel notifies the service that the session is terminated.</span></span> <span data-ttu-id="3dfd2-159">이 때 채널이 이미 중단되었거나 닫혔거나 사용할 수 없는 경우(예: 네트워크 케이블이 연결되지 않은 경우) 클라이언트 채널은 세션이 종료되었으며 예외가 발생할 수 있음을 서비스 채널에 알릴 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-159">In this case, if the channel has already aborted, closed, or is otherwise unusable (for example, when a network cable is unplugged), the client channel cannot inform the service channel that the session is terminated and an exception can result.</span></span>

### <a name="abort-the-channel-if-necessary"></a><span data-ttu-id="3dfd2-160">필요한 경우 채널 중단</span><span class="sxs-lookup"><span data-stu-id="3dfd2-160">Abort the Channel If Necessary</span></span>

<span data-ttu-id="3dfd2-161">채널을 닫아도 예외가 throw될 수 있으므로 올바른 순서로 오류 예외를 catch하는 것뿐만 아니라 catch 블록에서 호출에 사용된 채널을 중단하는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-161">Because closing the channel can also throw exceptions, then, it is recommended that in addition to catching fault exceptions in the correct order, it is important to abort the channel that was used in making the call in the catch block.</span></span>

<span data-ttu-id="3dfd2-162">작업별 오류 정보가 제공되고 다른 작업에서 이 정보를 사용할 수 있으면 드물긴 하지만 채널을 중단하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-162">If the fault conveys error information specific to an operation and it remains possible that others can use it, there is no need to abort the channel (although these cases are rare).</span></span> <span data-ttu-id="3dfd2-163">다른 모든 경우에는 채널을 중단하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-163">In all other cases, it is recommended that you abort the channel.</span></span> <span data-ttu-id="3dfd2-164">이러한 모든 사항을 보여 주는 샘플은 [예상 된 예외](./samples/expected-exceptions.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-164">For a sample that demonstrates all of these points, see [Expected Exceptions](./samples/expected-exceptions.md).</span></span>

<span data-ttu-id="3dfd2-165">다음 코드 예제에서는 선언된 오류와 선언되지 않은 오류를 비롯하여 기본 클라이언트 애플리케이션에서 SOAP 오류 예외를 처리하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-165">The following code example shows how to handle SOAP fault exceptions in a basic client application, including a declared fault and an undeclared fault.</span></span>

> [!NOTE]
> <span data-ttu-id="3dfd2-166">이 샘플 코드에서는 `using` 구문을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-166">This sample code does not use the `using` construct.</span></span> <span data-ttu-id="3dfd2-167">채널을 닫으면 예외가 throw 될 수 있으므로 응용 프로그램에서 WCF 클라이언트를 먼저 만든 다음 동일한 try 블록에서 WCF 클라이언트를 열고 사용 하 고 닫는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-167">Because closing channels can throw exceptions, it is recommended that applications create a WCF client first, and then open, use, and close the WCF client in the same try block.</span></span> <span data-ttu-id="3dfd2-168">자세한 내용은 [Wcf 클라이언트 개요](wcf-client-overview.md) 를 참조 하 고 [Close 및 Abort를 사용 하 여 wcf 클라이언트 리소스를 해제](./samples/use-close-abort-release-wcf-client-resources.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3dfd2-168">For details, see [WCF Client Overview](wcf-client-overview.md) and [Use Close and Abort to release WCF client resources](./samples/use-close-abort-release-wcf-client-resources.md).</span></span>

[!code-csharp[FaultContractAttribute#3](../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
[!code-vb[FaultContractAttribute#3](../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]

## <a name="see-also"></a><span data-ttu-id="3dfd2-169">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3dfd2-169">See also</span></span>

- <xref:System.ServiceModel.FaultException>
- <xref:System.ServiceModel.FaultException%601>
- <xref:System.ServiceModel.CommunicationException?displayProperty=nameWithType>
- [<span data-ttu-id="3dfd2-170">예상되는 예외</span><span class="sxs-lookup"><span data-stu-id="3dfd2-170">Expected Exceptions</span></span>](./samples/expected-exceptions.md)
- [<span data-ttu-id="3dfd2-171">닫기 및 중단을 사용하여 WCF 클라이언트 리소스 해제</span><span class="sxs-lookup"><span data-stu-id="3dfd2-171">Use Close and Abort to release WCF client resources</span></span>](./samples/use-close-abort-release-wcf-client-resources.md)
