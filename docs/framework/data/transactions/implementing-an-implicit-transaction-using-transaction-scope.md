---
title: 트랜잭션 범위를 사용하여 암시적 트랜잭션 구현
description: .NET에서 TransactionScope 클래스를 사용 하 여 암시적 트랜잭션을 구현 합니다. 이 클래스는 코드 블록을 트랜잭션에 참여 하는 것으로 표시 하는 방법을 제공 합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: ff2fe64156d5d72773549d78b2e29631905cbb10
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186863"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="20b94-104">트랜잭션 범위를 사용하여 암시적 트랜잭션 구현</span><span class="sxs-lookup"><span data-stu-id="20b94-104">Implementing an Implicit Transaction using Transaction Scope</span></span>

<span data-ttu-id="20b94-105"><xref:System.Transactions.TransactionScope> 클래스는 트랜잭션 자체와 상호 작용할 필요 없이 코드 블록을 트랜잭션에 참여하는 것으로 표시하는 단순한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-105">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="20b94-106">트랜잭션 범위는 자동으로 앰비언트 트랜잭션을 선택하고 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-106">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="20b94-107">사용하기 쉽고 효율적이므로 트랜잭션 애플리케이션을 개발할 때는 <xref:System.Transactions.TransactionScope> 클래스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-107">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="20b94-108">또한 트랜잭션을 사용하여 명시적으로 리소스를 등록할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-108">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="20b94-109"><xref:System.Transactions> 리소스 관리자(예: SQL Server 2005)는 범위에서 만든 앰비언트 트랜잭션이 있는지 감지하고 자동으로 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-109">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="20b94-110">트랜잭션 범위 만들기</span><span class="sxs-lookup"><span data-stu-id="20b94-110">Creating a transaction scope</span></span>  

 <span data-ttu-id="20b94-111">다음 샘플에서는 <xref:System.Transactions.TransactionScope> 클래스의 단순한 사용을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-111">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="20b94-112">새 개체를 만들면 트랜잭션 범위가 시작 됩니다 <xref:System.Transactions.TransactionScope> .</span><span class="sxs-lookup"><span data-stu-id="20b94-112">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="20b94-113">코드 샘플에 나와 있는 것 처럼 문으로 범위를 만드는 것이 좋습니다 `using` .</span><span class="sxs-lookup"><span data-stu-id="20b94-113">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="20b94-114">`using`문은 c # 및 Visual Basic 모두 사용할 수 있으며, ... 블록과 같은 방식으로 작동 하 여 `try` `finally` 범위가 제대로 삭제 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-114">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="20b94-115"><xref:System.Transactions.TransactionScope>를 시작하면 트랜잭션 관리자는 참가할 트랜잭션을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-115">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="20b94-116">결정 되 면 범위는 항상 해당 트랜잭션에 참여 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-116">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="20b94-117">이러한 결정은 앰비언트 트랜잭션이 있는지 여부와 `TransactionScopeOption` 생성자의 매개 변수 값에 따라 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-117">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="20b94-118">앰비언트 트랜잭션은 코드가 실행되는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-118">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="20b94-119">클래스의 정적 속성을 호출 하 여 앰비언트 트랜잭션에 대 한 참조를 가져올 수 있습니다 <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> <xref:System.Transactions.Transaction> .</span><span class="sxs-lookup"><span data-stu-id="20b94-119">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="20b94-120">이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은이 항목의 [TransactionScopeOption를 사용 하 여 트랜잭션 흐름 관리](#ManageTxFlow) 섹션을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="20b94-120">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="20b94-121">트랜잭션 범위 완료</span><span class="sxs-lookup"><span data-stu-id="20b94-121">Completing a transaction scope</span></span>  

 <span data-ttu-id="20b94-122">애플리케이션이 트랜잭션에서 수행할 작업을 모두 완료하면 <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> 메서드를 한 번만 호출하여 트랜잭션 커밋이 허용됨을 트랜잭션 관리자에게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-122">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="20b94-123">호출을 <xref:System.Transactions.TransactionScope.Complete%2A> 블록의 마지막 문으로 전환 하는 것이 좋습니다 `using` .</span><span class="sxs-lookup"><span data-stu-id="20b94-123">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="20b94-124">트랜잭션 관리자가이를 시스템 오류로 해석 하거나 트랜잭션 범위 내에서 throw 된 예외와 동일 하 게 해석 되므로이 메서드를 호출 하지 못하면 트랜잭션이 중단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-124">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="20b94-125">그러나 이 메서드를 호출해도 반드시 트랜잭션이 커밋되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-125">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="20b94-126">단순히 트랜잭션 관리자에 게 상태를 알리는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-126">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="20b94-127"><xref:System.Transactions.TransactionScope.Complete%2A> 메서드를 호출한 후에는 더 이상 <xref:System.Transactions.Transaction.Current%2A> 속성을 통해 앰비언트 트랜잭션에 액세스할 수 없으며 액세스를 시도하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-127">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="20b94-128"><xref:System.Transactions.TransactionScope>개체가 처음에 트랜잭션을 만든 경우 트랜잭션 관리자가 트랜잭션을 커밋하는 실제 작업은 블록의 마지막 코드 줄 뒤에 발생 합니다 `using` .</span><span class="sxs-lookup"><span data-stu-id="20b94-128">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="20b94-129">트랜잭션을 만들지 않은 경우 <xref:System.Transactions.CommittableTransaction.Commit%2A> 개체 소유자가를 호출할 때마다 커밋이 발생 합니다 <xref:System.Transactions.CommittableTransaction> .</span><span class="sxs-lookup"><span data-stu-id="20b94-129">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="20b94-130">이 시점에서 트랜잭션 관리자는 리소스 관리자를 호출 하 고 <xref:System.Transactions.TransactionScope.Complete%2A> 개체에 대해 메서드가 호출 되었는지 여부에 따라 커밋 또는 롤백을 알립니다 <xref:System.Transactions.TransactionScope> .</span><span class="sxs-lookup"><span data-stu-id="20b94-130">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="20b94-131">`using`문은 <xref:System.Transactions.TransactionScope.Dispose%2A> 예외가 발생 하더라도 개체의 메서드가 호출 되도록 합니다 <xref:System.Transactions.TransactionScope> .</span><span class="sxs-lookup"><span data-stu-id="20b94-131">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="20b94-132"><xref:System.Transactions.TransactionScope.Dispose%2A> 메서드는 트랜잭션 범위의 끝을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-132">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="20b94-133">이 메서드를 호출한 후에 발생 하는 예외는 트랜잭션에 영향을 주지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-133">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="20b94-134">또한 이 메서드는 앰비언트 트랜잭션을 이전 상태로 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-134">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="20b94-135">범위가 트랜잭션을 만들면 <xref:System.Transactions.TransactionAbortedException>이 throw되고 트랜잭션이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-135">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="20b94-136">트랜잭션 관리자가 커밋 결정에 도달할 수 없는 경우 <xref:System.Transactions.TransactionInDoubtException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-136">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="20b94-137">트랜잭션이 커밋되면 예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-137">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="20b94-138">트랜잭션 롤백</span><span class="sxs-lookup"><span data-stu-id="20b94-138">Rolling back a transaction</span></span>  

 <span data-ttu-id="20b94-139">트랜잭션을 롤백하려면 트랜잭션 범위 내에서 <xref:System.Transactions.TransactionScope.Complete%2A> 메서드를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-139">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="20b94-140">예를 들어 범위 내에서 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-140">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="20b94-141">범위가 참여하는 트랜잭션이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-141">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a> <span data-ttu-id="20b94-142">TransactionScopeOption를 사용 하 여 트랜잭션 흐름 관리</span><span class="sxs-lookup"><span data-stu-id="20b94-142">Managing transaction flow using TransactionScopeOption</span></span>  

 <span data-ttu-id="20b94-143">다음 예제의 <xref:System.Transactions.TransactionScope> 메서드와 같이 자체 범위를 사용하는 메서드 내의 `RootMethod`를 사용하는 메서드를 호출하여 트랜잭션 범위를 중첩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-143">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="20b94-144">맨 위의 트랜잭션 범위를 루트 범위라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-144">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="20b94-145"><xref:System.Transactions.TransactionScope> 클래스는 범위의 트랜잭션 동작을 정의하는 <xref:System.Transactions.TransactionScopeOption> 형식의 열거를 받아들이는 여러 개의 오버로드된 생성자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-145">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="20b94-146"><xref:System.Transactions.TransactionScope> 개체에는 다음 세 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-146">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="20b94-147">앰비언트 트랜잭션에 참여하거나 앰비언트 트랜잭션이 없는 경우 새로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-147">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="20b94-148">새 루트 범위로 설정합니다. 즉, 새 트랜잭션을 시작하고 해당 트랜잭션이 자체 범위 내부의 새 앰비언트 트랜잭션이 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-148">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="20b94-149">트랜잭션에 참여하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-149">Not take part in a transaction at all.</span></span> <span data-ttu-id="20b94-150">이렇게 하면 앰비언트 트랜잭션이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-150">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="20b94-151"><xref:System.Transactions.TransactionScopeOption.Required>를 사용하여 범위를 인스턴스화하고 앰비언트 트랜잭션이 있는 경우 범위가 해당 트랜잭션에 참여합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-151">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="20b94-152">반면 앰비언트 트랜잭션이 없으면 범위가 새 트랜잭션을 만들고 루트 범위가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-152">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="20b94-153">이것은 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-153">This is the default value.</span></span> <span data-ttu-id="20b94-154"><xref:System.Transactions.TransactionScopeOption.Required>를 사용하는 경우 루트이든 앰비언트 트랜잭션에 참여하든 관계없이 범위 내부의 코드가 다르게 동작할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-154">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="20b94-155">두 경우에서 모두 동일하게 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-155">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="20b94-156"><xref:System.Transactions.TransactionScopeOption.RequiresNew>를 사용하여 범위를 인스턴스화하는 경우 항상 루트 범위가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="20b94-157">새 트랜잭션을 시작하고 해당 트랜잭션이 범위 내부의 새 앰비언트 트랜잭션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-157">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="20b94-158"><xref:System.Transactions.TransactionScopeOption.Suppress>를 사용하여 범위를 인스턴스화하는 경우 앰비언트 트랜잭션이 있는지 여부에 관계없이 트랜잭션에 참여하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-158">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="20b94-159">이 값을 사용 하 여 인스턴스화된 범위는 항상 `null` 앰비언트 트랜잭션으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-159">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="20b94-160">위의 옵션은 다음 표에 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-160">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="20b94-161">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="20b94-161">TransactionScopeOption</span></span>|<span data-ttu-id="20b94-162">앰비언트 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="20b94-162">Ambient Transaction</span></span>|<span data-ttu-id="20b94-163">범위의 참여 여부</span><span class="sxs-lookup"><span data-stu-id="20b94-163">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="20b94-164">필수</span><span class="sxs-lookup"><span data-stu-id="20b94-164">Required</span></span>|<span data-ttu-id="20b94-165">아니요</span><span class="sxs-lookup"><span data-stu-id="20b94-165">No</span></span>|<span data-ttu-id="20b94-166">새 트랜잭션(루트가 됨)</span><span class="sxs-lookup"><span data-stu-id="20b94-166">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="20b94-167">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="20b94-167">Requires New</span></span>|<span data-ttu-id="20b94-168">아니요</span><span class="sxs-lookup"><span data-stu-id="20b94-168">No</span></span>|<span data-ttu-id="20b94-169">새 트랜잭션(루트가 됨)</span><span class="sxs-lookup"><span data-stu-id="20b94-169">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="20b94-170">표시 안 함</span><span class="sxs-lookup"><span data-stu-id="20b94-170">Suppress</span></span>|<span data-ttu-id="20b94-171">아니요</span><span class="sxs-lookup"><span data-stu-id="20b94-171">No</span></span>|<span data-ttu-id="20b94-172">트랜잭션 없음</span><span class="sxs-lookup"><span data-stu-id="20b94-172">No Transaction</span></span>|  
|<span data-ttu-id="20b94-173">필수</span><span class="sxs-lookup"><span data-stu-id="20b94-173">Required</span></span>|<span data-ttu-id="20b94-174">예</span><span class="sxs-lookup"><span data-stu-id="20b94-174">Yes</span></span>|<span data-ttu-id="20b94-175">앰비언트 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="20b94-175">Ambient  Transaction</span></span>|  
|<span data-ttu-id="20b94-176">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="20b94-176">Requires New</span></span>|<span data-ttu-id="20b94-177">예</span><span class="sxs-lookup"><span data-stu-id="20b94-177">Yes</span></span>|<span data-ttu-id="20b94-178">새 트랜잭션(루트가 됨)</span><span class="sxs-lookup"><span data-stu-id="20b94-178">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="20b94-179">표시 안 함</span><span class="sxs-lookup"><span data-stu-id="20b94-179">Suppress</span></span>|<span data-ttu-id="20b94-180">예</span><span class="sxs-lookup"><span data-stu-id="20b94-180">Yes</span></span>|<span data-ttu-id="20b94-181">트랜잭션 없음</span><span class="sxs-lookup"><span data-stu-id="20b94-181">No Transaction</span></span>|  
  
 <span data-ttu-id="20b94-182"><xref:System.Transactions.TransactionScope> 개체가 기존의 앰비언트 트랜잭션에 참여하는 경우 범위가 트랜잭션을 중단하지 않으면 범위 개체를 삭제해도 트랜잭션이 종료되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-182">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="20b94-183">루트 범위로 앰비언트 트랜잭션을 만든 경우 루트 범위가 삭제되는 경우에만 트랜잭션에서 <xref:System.Transactions.CommittableTransaction.Commit%2A>이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-183">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="20b94-184">수동으로 트랜잭션을 만든 경우 작성자가 트랜잭션을 중단하거나 커밋할 때 트랜잭션이 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-184">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="20b94-185">다음 예제에서는 각각 다른 <xref:System.Transactions.TransactionScope> 값으로 인스턴스화된 세 가지 중첩 범위 개체를 만드는 <xref:System.Transactions.TransactionScopeOption> 개체를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-185">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="20b94-186">이 예제에서는 `scope1`를 사용하여 새 범위(<xref:System.Transactions.TransactionScopeOption.Required>)를 만드는 앰비언트 트랜잭션이 없는 코드 블록을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-186">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="20b94-187">`scope1` 범위는 새 트랜잭션(Transaction A)을 만들 때 루트 범위이며 Transaction A를 앰비언트 트랜잭션으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-187">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="20b94-188">그런 다음 `Scope1`은 각각 다른 <xref:System.Transactions.TransactionScopeOption> 값을 사용하여 세 개의 개체를 추가로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-188">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="20b94-189">예를 들어 `scope2`는 <xref:System.Transactions.TransactionScopeOption.Required>를 사용하여 만들어지고 앰비언트 트랜잭션이 있으므로 `scope1`에서 만든 첫 번째 트랜잭션에 참여합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-189">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="20b94-190">`scope3`은 새 트랜잭션의 루트 범위이고 `scope4`에는 앰비언트 트랜잭션이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-190">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="20b94-191"><xref:System.Transactions.TransactionScopeOption>의 기본값이며 가장 일반적으로 사용되는 값은 <xref:System.Transactions.TransactionScopeOption.Required>이고 다른 값은 각각 고유한 용도를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-191">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="20b94-192">트랜잭션 범위 내의 비트랜잭션 코드</span><span class="sxs-lookup"><span data-stu-id="20b94-192">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="20b94-193"><xref:System.Transactions.TransactionScopeOption.Suppress> 는 코드 섹션에서 수행 하는 작업을 유지 하려는 경우와 작업이 실패할 경우 앰비언트 트랜잭션을 중단 하지 않으려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-193"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="20b94-194">예를 들어 로깅 또는 감사 작업을 수행하려는 경우 또는 앰비언트 트랜잭션이 커밋 또는 중단되든 관계없이 구독자에게 이벤트를 게시하려는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-194">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="20b94-195">이 값을 사용하면 다음 예제와 같이 트랜잭션 범위 내부에 비트랜잭션 코드 섹션이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-195">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="20b94-196">중첩된 범위 내부의 응답</span><span class="sxs-lookup"><span data-stu-id="20b94-196">Voting inside a nested scope</span></span>  

 <span data-ttu-id="20b94-197">중첩된 범위는 루트 범위의 앰비언트 트랜잭션에 참여할 수 있지만 중첩된 범위에서 <xref:System.Transactions.TransactionScope.Complete%2A>를 호출하면 루트 범위에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-197">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="20b94-198">루트 범위에서 마지막 중첩 범위까지의 모든 범위가 트랜잭션을 커밋하도록 응답하는 경우에만 트랜잭션이 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-198">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="20b94-199">중첩된 범위에서 <xref:System.Transactions.TransactionScope.Complete%2A>를 호출하지 않으면 앰비언트 트랜잭션이 즉시 중단되므로 루트 범위에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-199">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="20b94-200">TransactionScope 시간 제한 설정</span><span class="sxs-lookup"><span data-stu-id="20b94-200">Setting the TransactionScope timeout</span></span>  

 <span data-ttu-id="20b94-201"><xref:System.Transactions.TransactionScope>의 오버로드된 생성자 중 일부는 트랜잭션의 시간 제한을 제어하는 데 사용되는 <xref:System.TimeSpan> 형식의 값을 받아들입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-201">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="20b94-202">시간 제한을 0으로 설정하면 시간 제한이 없음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-202">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="20b94-203">무한 시간 제한은 대체로 코드를 단계별로 실행하여 비즈니스 논리의 문제를 격리하고 문제를 찾는 동안 디버그가 시간 초과되지 않도록 하려는 경우 디버깅에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-203">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="20b94-204">무한 시간 제한 값은 트랜잭션 교착 상태에 대한 안전 장치를 재정의하므로 다른 모든 경우에서는 사용 시 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-204">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="20b94-205">일반적으로 두 가지 경우에서 <xref:System.Transactions.TransactionScope> 시간 제한을 기본값이 아닌 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-205">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="20b94-206">첫 번째는 개발 중으로, 애플리케이션이 중단된 트랜잭션을 처리하는 방법을 테스트하려는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-206">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="20b94-207">시간 제한을 더 작은 값(예: 1밀리초)으로 설정하여 트랜잭션이 실패하게 하고 오류 처리 코드를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-207">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="20b94-208">이 값을 기본 시간 제한보다 작은 값으로 설정하는 두 번째 경우는 범위가 리소스 충돌과 관련되어 교착 상태가 발생한다고 생각하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-208">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="20b94-209">이 경우 가능한 한 빨리 트랜잭션을 중단하고 기본 시간 제한이 만료될 때까지 기다리지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-209">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="20b94-210">범위가 앰비언트 트랜잭션에 참여하지만 앰비언트 트랜잭션이 설정된 시간 제한보다 작은 시간 제한을 지정하는 경우 <xref:System.Transactions.TransactionScope> 개체에 더 짧은 새 시간 제한이 적용되고 범위가 지정된 중첩 시간 내에 종료되어야 합니다. 그렇지 않으면 트랜잭션이 자동으로 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-210">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="20b94-211">중첩된 범위의 시간 제한이 앰비언트 트랜잭션의 시간 제한보다 크면 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-211">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="20b94-212">TransactionScope 격리 수준 설정</span><span class="sxs-lookup"><span data-stu-id="20b94-212">Setting the TransactionScope isolation level</span></span>  

 <span data-ttu-id="20b94-213"><xref:System.Transactions.TransactionScope>의 오버로드된 생성자 중 일부는 <xref:System.Transactions.TransactionOptions> 형식의 구조를 받아들여 시간 제한 값 외에 격리 수준을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-213">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="20b94-214">기본적으로 트랜잭션은 격리 수준을 <xref:System.Transactions.IsolationLevel.Serializable>로 설정하여 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-214">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="20b94-215"><xref:System.Transactions.IsolationLevel.Serializable>이 아닌 격리 수준 선택은 일반적으로 읽기를 주로 사용하는 시스템에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-215">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="20b94-216">이 경우 트랜잭션 처리 이론과 트랜잭션 자체의 의미 체계, 관련된 동시성 문제, 시스템 일관성에 대한 영향을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-216">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="20b94-217">또한 모든 리소스 관리자가 모든 격리 수준을 지원하지는 않으며, 구성된 수준보다 더 높은 수준의 트랜잭션에 참여하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-217">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="20b94-218"><xref:System.Transactions.IsolationLevel.Serializable> 외의 모든 격리 수준에서 동일한 정보에 액세스하는 다른 트랜잭션으로 인한 불일치가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-218">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="20b94-219">각 격리 수준의 차이점은 읽기 및 쓰기 잠금의 사용 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-219">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="20b94-220">트랜잭션이 리소스 관리자의 데이터에 액세스할 때만 잠금을 유지하거나 트랜잭션이 커밋 또는 중단될 때까지 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-220">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="20b94-221">전자는 처리량 향상에 효과적이고 후자는 일관성 유지에 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-221">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="20b94-222">두 종류의 잠금과 두 종류의 작업(읽기/쓰기)으로 네 가지 기본 격리 수준이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-222">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="20b94-223">자세한 내용은 <xref:System.Transactions.IsolationLevel> 를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="20b94-223">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="20b94-224">중첩된 <xref:System.Transactions.TransactionScope> 개체를 사용하는 경우 모든 중첩 범위가 앰비언트 트랜잭션에 참여하려면 동일한 격리 수준을 사용하도록 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-224">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="20b94-225">중첩된 <xref:System.Transactions.TransactionScope> 개체가 앰비언트 트랜잭션에 참여하려고 하지만 다른 격리 수준을 지정하는 경우 <xref:System.ArgumentException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-225">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="20b94-226">COM+와의 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="20b94-226">Interop with COM+</span></span>  

 <span data-ttu-id="20b94-227">새 <xref:System.Transactions.TransactionScope> 인스턴스를 만드는 경우 생성자 중 하나에 <xref:System.Transactions.EnterpriseServicesInteropOption> 열거를 사용하여 COM+와 상호 작용하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="20b94-227">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="20b94-228">이에 대 한 자세한 내용은 [엔터프라이즈 서비스 및 COM + 트랜잭션과의 상호 운용성](interoperability-with-enterprise-services-and-com-transactions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="20b94-228">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="20b94-229">참고 항목</span><span class="sxs-lookup"><span data-stu-id="20b94-229">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
