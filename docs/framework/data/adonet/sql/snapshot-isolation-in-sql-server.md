---
title: SQL Server의 스냅샷 격리
description: SQL Server의 스냅숏 격리 및 행 버전 관리에 대 한 개요를 읽고 격리 수준을 사용 하 여 동시성을 관리 하는 방법을 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 4934c031eb9dfb26d60c5233937cbc65ca60d4f7
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91183080"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="85fac-103">SQL Server의 스냅샷 격리</span><span class="sxs-lookup"><span data-stu-id="85fac-103">Snapshot Isolation in SQL Server</span></span>

<span data-ttu-id="85fac-104">스냅샷 격리는 OLTP 애플리케이션의 동시성을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-104">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="85fac-105">스냅샷 격리 및 행 버전 관리 이해</span><span class="sxs-lookup"><span data-stu-id="85fac-105">Understanding Snapshot Isolation and Row Versioning</span></span>  

 <span data-ttu-id="85fac-106">스냅숏 격리가 설정 되 면 각 트랜잭션에 대해 업데이트 된 행 버전을 유지 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-106">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="85fac-107">SQL Server 2019 이전 버전에서는 이러한 버전이 **tempdb**에 저장 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-107">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="85fac-108">SQL Server 2019에는 고유한 행 버전 집합이 필요한 새로운 기능인 ADR (가속화 된 데이터베이스 복구)가 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-108">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="85fac-109">따라서 SQL Server 2019에서 ADR를 사용 하지 않는 경우 행 버전은 **tempdb** 에 항상 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-109">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="85fac-110">ADR가 사용 하도록 설정 된 경우 snapshot 격리 및 ADR와 관련 된 모든 행 버전은 사용자가 지정 하는 파일 그룹의 사용자 데이터베이스에 있는 ADR의 영구 버전 저장소 (PVS)에 보관 됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-110">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="85fac-111">고유한 트랜잭션 시퀀스 번호가 각 트랜잭션을 식별하며 이러한 고유 번호는 각 행 버전에 대해 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-111">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="85fac-112">트랜잭션은 트랜잭션의 시퀀스 번호 앞에 시퀀스 번호가 있는 최신 행 버전에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-112">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="85fac-113">트랜잭션이 시작된 후에 생성된 최신 행 버전은 트랜잭션에서 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-113">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="85fac-114">"스냅샷" 이라는 용어는 트랜잭션의 모든 쿼리가 트랜잭션이 시작되는 시점의 데이터베이스 상태를 기반으로 데이터베이스의 동일한 버전 또는 스냅샷을 본다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-114">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="85fac-115">스냅샷 트랜잭션의 기본 데이터 행이나 데이터 페이지에서는 잠금이 인식되지 않습니다. 따라서 이전에 완료되지 않은 트랜잭션에 의해 차단되지 않고 다른 트랜잭션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-115">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="85fac-116">데이터를 수정하는 트랜잭션은 데이터를 읽는 트랜잭션을 차단하지 않으며 데이터를 읽는 트랜잭션은 일반적으로 SQL Server의 기본 READ COMMITTED 격리 수준에 따라 데이터를 쓰는 트랜잭션을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-116">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="85fac-117">이 비차단 동작 덕분에 복잡한 트랜잭션에 대한 교착 상태의 가능성이 크게 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-117">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="85fac-118">스냅샷 격리는 낙관적 동시성 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-118">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="85fac-119">스냅샷 트랜잭션이 시작된 이후 변경된 데이터에 대한 수정 내용을 커밋하려는 경우 트랜잭션이 롤백되고 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-119">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="85fac-120">수정할 데이터에 액세스하는 SELECT 문에 대해 UPDLOCK 힌트를 사용하여 이를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-120">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="85fac-121">자세한 내용은 SQL Server 온라인 설명서 "잠금 힌트"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="85fac-121">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="85fac-122">스냅샷 격리는 트랜잭션에 사용하기 전에 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 ON으로 설정하여 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-122">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="85fac-123">이렇게 하면 임시 데이터베이스인 **tempdb**에 행 버전을 저장하는 메커니즘이 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-123">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="85fac-124">Transact-SQL ALTER DATABASE 문과 함께 사용하는 각 데이터베이스에서 스냅샷 격리를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-124">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="85fac-125">이러한 점에서 스냅샷 격리는 구성을 필요로 하지 않는 기존 격리 수준 READ COMMITTED, REPEATABLE READ, SERIALIZABLE 및 READ UNCOMMITTED와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-125">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="85fac-126">다음 문은 스냅샷 격리를 활성화하고 기본 READ COMMITTED 동작을 SNAPSHOT으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-126">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="85fac-127">READ_COMMITTED_SNAPSHOT 옵션을 ON으로 설정하면 기본 READ COMMITTED 격리 수준에서 버전이 지정된 행에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-127">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="85fac-128">READ_COMMITTED_SNAPSHOT 옵션이 OFF로 설정되어 있으면 버전이 지정된 행에 액세스하기 위해 각 세션마다 스냅샷 격리 수준을 명시적으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-128">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="85fac-129">격리 수준을 사용하여 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="85fac-129">Managing Concurrency with Isolation Levels</span></span>  

 <span data-ttu-id="85fac-130">Transact-SQL 문이 실행되는 격리 수준에 따라 잠금 및 행 버전 관리 동작이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-130">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="85fac-131">격리 수준은 전체 연결 범위를 가지며 SET TRANSACTION ISOLATION LEVEL 문을 사용하여 연결에 대해 설정되면 연결이 닫히거나 다른 격리 수준이 설정될 때까지 계속 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-131">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="85fac-132">연결이 닫히고 풀로 반환되면 마지막 SET TRANSACTION ISOLATION LEVEL 문의 격리 수준이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-132">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="85fac-133">풀링된 연결을 다시 사용하는 후속 연결은 연결이 풀링되는 시점에 적용된 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-133">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="85fac-134">연결 내에서 실행된 개별 쿼리에는 단일 문 또는 트랜잭션에 대한 격리를 수정하는 잠금 힌트가 포함될 수 있지만 연결의 격리 수준에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-134">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="85fac-135">저장 프로시저 또는 함수에서 설정된 격리 수준 또는 잠금 힌트는 이를 호출하는 연결의 격리 수준을 변경하지 않으며 저장 프로시저 또는 함수 호출 기간 동안만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-135">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="85fac-136">이전 버전의 SQL Server에서는 SQL-92 표준에 정의된 네 가지 격리 수준이 지원되었습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-136">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="85fac-137">READ UNCOMMITTED 다른 트랜잭션에 의해 배치된 잠금을 무시하므로 가장 제한적인 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-137">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="85fac-138">READ UNCOMMITTED로 실행 중인 트랜잭션은 다른 트랜잭션에서 아직 커밋되지 않은 수정된 데이터 값을 읽을 수 있습니다. 이를 "더티" 읽기라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-138">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="85fac-139">READ COMMITTED는 SQL Server의 기본 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-139">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="85fac-140">이를 통해 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터 값을 문이 읽을 수 없도록 지정하여 더티 읽기를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-140">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="85fac-141">다른 트랜잭션은 여전히 현재 트랜잭션의 개별 문 실행 사이에 데이터를 수정, 삽입 또는 삭제할 수 있습니다. 이 경우 반복되지 않은 읽기 또는 "가상" 데이터가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-141">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="85fac-142">REPEATABLE READ는 READ COMMITTED보다 더 제한적인 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-142">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="85fac-143">READ COMMITTED를 포함하며, 현재 트랜잭션이 커밋될 때까지 다른 트랜잭션이 현재 트랜잭션에서 읽은 데이터를 수정하거나 삭제할 수 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-143">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="85fac-144">읽기 데이터의 공유 잠금은 각 문이 끝날 때 해제되지 않고 트랜잭션 기간 동안 유지되기 때문에 동시성이 READ COMMITTED보다 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-144">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="85fac-145">SERIALIZABLE은 전체 키 범위를 잠그고 트랜잭션이 완료될 때까지 해당 잠금을 보유하므로 격리 수준 중에서 가장 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-145">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="85fac-146">REPEATABLE READ를 포함하며 트랜잭션이 완료될 때까지 다른 트랜잭션이 새 행을 현재 트랜잭션에서 읽은 범위에 삽입할 수 없다는 제한을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-146">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="85fac-147">더 자세한 내용은 [트랜잭션 잠금 및 행 버전 관리 지침](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="85fac-147">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="85fac-148">스냅샷 격리 수준 확장명</span><span class="sxs-lookup"><span data-stu-id="85fac-148">Snapshot Isolation Level Extensions</span></span>  

 <span data-ttu-id="85fac-149">SQL Server에서는 SNAPSHOT 격리 수준을 도입하고 READ COMMITTED를 추가로 구현함으로써 SQL-92 격리 수준이 확장되었습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-149">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="85fac-150">READ_COMMITTED_SNAPSHOT 격리 수준은 모든 트랜잭션에 대해 READ COMMITTED를 투명하게 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-150">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="85fac-151">SNAPSHOT 격리는 트랜잭션 내에서 읽은 데이터에 다른 동시 트랜잭션이 변경한 내용을 반영하지 않도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-151">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="85fac-152">트랜잭션은 트랜잭션이 시작할 때 존재하는 데이터 행 버전을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-152">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="85fac-153">데이터를 읽을 때 데이터에 잠금이 배치되지 않으므로 SNAPSHOT 트랜잭션은 다른 트랜잭션이 데이터를 쓰지 못하도록 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-153">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="85fac-154">데이터를 쓰는 트랜잭션은 스냅샷 트랜잭션의 데이터 읽기를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-154">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="85fac-155">사용하려면 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 설정하여 스냅샷 격리를 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-155">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="85fac-156">데이터베이스에서 스냅샷 격리를 사용하는 경우 READ_COMMITTED_SNAPSHOT 데이터베이스 옵션이 READ COMMITTED 격리 수준의 기본 동작을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-156">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="85fac-157">READ_COMMITTED_SNAPSHOT을 명시적으로 ON으로 지정하지 않으면 READ COMMITTED는 모든 암시적 트랜잭션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-157">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="85fac-158">이렇게 하면 READ_COMMITTED_SNAPSHOT OFF(기본값)를 설정하는 것과 동일한 동작이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-158">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="85fac-159">READ_COMMITTED_SNAPSHOT OFF가 적용되는 경우 데이터베이스 엔진은 공유 잠금을 사용하여 기본 격리 수준을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-159">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="85fac-160">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 데이터베이스 엔진이 잠금을 사용하여 데이터를 보호하는 대신 행 버전 관리 및 스냅샷 격리를 기본값으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-160">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="85fac-161">스냅샷 격리 및 행 버전 관리의 작동 방법</span><span class="sxs-lookup"><span data-stu-id="85fac-161">How Snapshot Isolation and Row Versioning Work</span></span>  

 <span data-ttu-id="85fac-162">SNAPSHOT 격리 수준이 활성화된 경우 행이 업데이트될 때마다 SQL Server 데이터베이스 엔진에서 **tempdb**에 원래 행의 복사본을 저장하고 행에 트랜잭션 시퀀스 번호를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-162">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="85fac-163">다음은 이벤트가 발생하는 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-163">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="85fac-164">새 트랜잭션이 시작되고 트랜잭션 시퀀스 번호가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-164">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="85fac-165">데이터베이스 엔진이 트랜잭션 내에서 행을 읽고 트랜잭션 시퀀스 번호보다 낮으면서 시퀀스 번호에 가장 근접한 행 버전을 **tempdb**에서 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-165">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="85fac-166">데이터베이스 엔진은 트랜잭션 시퀀스 번호가 스냅샷 트랜잭션이 시작될 때 활성 상태인 커밋되지 않은 트랜잭션의 트랜잭션 시퀀스 번호 목록에 있지 않은지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-166">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="85fac-167">트랜잭션에서 트랜잭션을 시작할 당시의 행 버전을 **tempdb**에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-167">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="85fac-168">트랜잭션이 시작된 후 삽입된 새 행은 표시되지 않습니다. 이러한 시퀀스 번호 값이 트랜잭션 시퀀스 번호 값보다 높기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-168">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="85fac-169">**tempdb**에 시퀀스 번호 값이 낮은 행 버전이 있으므로 현재 트랜잭션에서 트랜잭션이 시작된 후 삭제된 행이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-169">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="85fac-170">스냅샷 격리의 결과는 트랜잭션이 기본 테이블에 대한 잠금을 준수 또는 배치하지 않고 트랜잭션이 시작할 때 존재한 모든 데이터를 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-170">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="85fac-171">그러므로 경합이 있는 경우 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-171">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="85fac-172">스냅샷 트랜잭션은 항상 낙관적 동시성 제어를 사용하여 다른 트랜잭션이 행을 업데이트하지 못하게 하는 잠금을 보류합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-172">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="85fac-173">스냅샷 트랜잭션이 트랜잭션 시작 후 변경된 행에 업데이트를 커밋하려고 하면 트랜잭션이 롤백되고 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-173">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="85fac-174">ADO.NET에서 스냅샷 격리 사용</span><span class="sxs-lookup"><span data-stu-id="85fac-174">Working with Snapshot Isolation in ADO.NET</span></span>  

 <span data-ttu-id="85fac-175">스냅샷 격리는 ADO.NET에서 <xref:System.Data.SqlClient.SqlTransaction> 클래스를 통해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-175">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="85fac-176">데이터베이스가 스냅샷 격리에 대해 활성화되었지만 READ_COMMITTED_SNAPSHOT ON에 대해 구성되지 않은 경우 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 메서드를 호출할 때 **IsolationLevel.Snapshot** 열거형 값을 사용하여 <xref:System.Data.SqlClient.SqlTransaction>을 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-176">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="85fac-177">이 코드 조각에서는 연결이 열린 <xref:System.Data.SqlClient.SqlConnection> 개체인 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-177">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="85fac-178">예제</span><span class="sxs-lookup"><span data-stu-id="85fac-178">Example</span></span>  

 <span data-ttu-id="85fac-179">다음 예제는 잠긴 데이터에 액세스하려고 시도하여 여러 격리 수준이 어떻게 동작하는지 보여 주며 프로덕션 코드에서는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-179">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="85fac-180">이 코드에서는 SQL Server의 **AdventureWorks** 샘플 데이터베이스에 연결하고 **TestSnapshot**이라는 테이블을 만들어 데이터 행 하나를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-180">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="85fac-181">이 코드는 ALTER DATABASE Transact-SQL 문을 사용하여 데이터베이스에 스냅샷 격리를 설정하지만 READ_COMMITTED_SNAPSHOT 옵션을 설정하지 않으므로 기본 READ COMMITTED 격리 수준 동작이 그대로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-181">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="85fac-182">그런 다음 코드는 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-182">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="85fac-183">SERIALIZABLE 격리 수준을 사용하여 업데이트 트랜잭션을 시작하는 sqlTransaction1을 시작하되 완료하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-183">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="85fac-184">이렇게 하면 테이블을 잠그는 효과가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-184">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="85fac-185">두 번째 연결을 열고 SNAPSHOT 격리 수준을 사용하여 두 번째 트랜잭션을 시작함으로써 **TestSnapshot** 테이블의 데이터를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-185">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="85fac-186">스냅샷 격리를 사용하도록 설정했으므로 이 트랜잭션은 sqlTransaction1이 시작하기 전에 존재했던 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-186">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="85fac-187">세 번째 연결을 열고 READ COMMITTED 격리 수준을 사용하여 트랜잭션을 시작해 테이블의 데이터를 읽으려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-187">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="85fac-188">이 경우 첫 번째 트랜잭션에서 테이블에 적용 된 잠금을 이전에 읽을 수 없고 시간이 초과 되므로 코드에서 데이터를 읽을 수 없습니다. 반복 읽기 및 직렬화 가능 격리 수준이 사용 되는 경우에도 동일한 결과가 발생 합니다. 이러한 격리 수준은 첫 번째 트랜잭션에 배치 된 잠금을 넘어서 읽을 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-188">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="85fac-189">네 번째 연결을 열고 READ UNCOMMITTED 격리 수준을 사용하여 트랜잭션을 시작합니다. 그러면 sqlTransaction1의 커밋되지 않은 값에 대한 더티 읽기가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-189">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="85fac-190">첫 번째 트랜잭션이 커밋되지 않으면 이 값은 실제로는 데이터베이스에 절대 존재할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-190">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="85fac-191">**TestSnapshot** 테이블을 삭제하고 **AdventureWorks** 데이터베이스의 스냅샷 격리 기능을 해제하여 첫 번째 트랜잭션을 롤백하고 정리합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-191">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="85fac-192">다음 예제에서는 연결 풀링이 해제된 상태에서 동일한 연결 문자열을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-192">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="85fac-193">연결이 풀링된 경우 해당 격리 수준을 다시 설정 해도 서버에서 격리 수준이 다시 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-193">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="85fac-194">따라서 풀링된 내부 연결을 사용하는 후속 연결은 풀링된 연결의 격리 수준이 설정된 상태로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-194">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="85fac-195">연결 풀링을 해제하는 또 다른 방법은 각 연결에 대해 명시적으로 격리 수준을 설정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-195">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="85fac-196">예제</span><span class="sxs-lookup"><span data-stu-id="85fac-196">Example</span></span>  

 <span data-ttu-id="85fac-197">다음 예제에서는 데이터를 수정하는 경우의 스냅샷 격리 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-197">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="85fac-198">코드는 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-198">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="85fac-199">**AdventureWorks** 샘플 데이터베이스에 연결하고 SNAPSHOT 격리를 활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-199">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="85fac-200">**TestSnapshotUpdate**라는 테이블을 만들고 샘플 데이터의 행 세 개를 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-200">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="85fac-201">스냅샷 격리를 사용하여 sqlTransaction1을 시작하되 완료하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-201">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="85fac-202">트랜잭션에서 세 개의 데이터 행이 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-202">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="85fac-203">**AdventureWorks**에 대한 두 번째 **SqlConnection**을 만들고 sqlTransaction1에서 선택한 행 중 하나에서 값을 업데이트하는 READ COMMITTED 격리 수준을 사용하여 두 번째 트랜잭션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-203">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="85fac-204">sqlTransaction2를 커밋합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-204">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="85fac-205">sqlTransaction1로 돌아가 sqlTransaction1이 이미 커밋한 동일한 행을 업데이트하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-205">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="85fac-206">오류 3960이 발생하고 sqlTransaction1이 자동으로 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-206">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="85fac-207">콘솔 창에 **SqlException.Number** 및 **SqlException.Message**가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-207">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="85fac-208">**AdventureWorks**에서 스냅샷 격리를 해제하고 **TestSnapshotUpdate** 테이블을 삭제할 정리 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-208">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="85fac-209">스냅샷 격리와 함께 잠금 힌트 사용</span><span class="sxs-lookup"><span data-stu-id="85fac-209">Using Lock Hints with Snapshot Isolation</span></span>  

 <span data-ttu-id="85fac-210">이전 예제에서는 첫 번째 트랜잭션이 데이터를 선택하고, 첫 번째 트랜잭션이 완료되기 전에 두 번째 트랜잭션이 데이터를 업데이트하여 첫 번째 트랜잭션이 같은 행을 업데이트하려고 할 때 업데이트 충돌이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-210">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="85fac-211">트랜잭션 시작 부분에 잠금 힌트를 제공하여 장기 실행 스냅샷 트랜잭션에서 업데이트 충돌이 발생할 가능성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-211">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="85fac-212">다음 SELECT 문은 UPDLOCK 힌트를 사용하여 선택된 행을 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-212">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="85fac-213">UPDLOCK 잠금 힌트를 사용하면 첫 번째 트랜잭션이 완료되기 전에 행을 업데이트하려고 시도하는 모든 행이 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-213">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="85fac-214">그러면 선택한 행이 트랜잭션에서 나중에 업데이트될 때 충돌이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-214">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="85fac-215">SQL Server 온라인 설명서의 "잠금 힌트"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="85fac-215">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="85fac-216">애플리케이션에 충돌이 많은 경우 스냅샷 격리를 선택하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-216">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="85fac-217">힌트는 정말 필요한 경우에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-217">Hints should only be used when really needed.</span></span> <span data-ttu-id="85fac-218">지속적으로 잠금 힌트를 사용하여 작업을 수행하도록 애플리케이션을 디자인하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="85fac-218">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="85fac-219">참고 항목</span><span class="sxs-lookup"><span data-stu-id="85fac-219">See also</span></span>

- [<span data-ttu-id="85fac-220">SQL Server 및 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="85fac-220">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="85fac-221">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="85fac-221">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="85fac-222">트랜잭션 잠금 및 행 버전 관리 지침</span><span class="sxs-lookup"><span data-stu-id="85fac-222">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
