---
title: SQL Server에서 권한 부여 및 권한
description: ADO.NET를 사용 하 여 사용자가 만들 수 있는 사용자 SQL Server가 만들 수 있는 데이터베이스 개체를 만들 수 있는 권한을 명시적으로 부여 하는 방법을 알아봅니다.
ms.date: 03/30/2017
ms.assetid: d340405c-91f4-4837-a3cc-a238ee89888a
ms.openlocfilehash: 748d40ff2c64ae59f43e6296ef591efcb5ff9831
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91197497"
---
# <a name="authorization-and-permissions-in-sql-server"></a><span data-ttu-id="e63de-103">SQL Server에서 권한 부여 및 권한</span><span class="sxs-lookup"><span data-stu-id="e63de-103">Authorization and Permissions in SQL Server</span></span>

<span data-ttu-id="e63de-104">데이터베이스 개체를 만들 때는 사용자가 해당 개체에 액세스할 수 있도록 권한을 명시적으로 부여해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-104">When you create database objects, you must explicitly grant permissions to make them accessible to users.</span></span> <span data-ttu-id="e63de-105">모든 보안 개체에는 권한 문을 통해 보안 주체에게 부여할 수 있는 권한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-105">Every securable object has permissions that can be granted to a principal using permission statements.</span></span>  
  
## <a name="the-principle-of-least-privilege"></a><span data-ttu-id="e63de-106">최소 권한의 원칙</span><span class="sxs-lookup"><span data-stu-id="e63de-106">The Principle of Least Privilege</span></span>  

 <span data-ttu-id="e63de-107">LUA(최소 권한 사용자 계정) 방식을 사용하여 애플리케이션을 개발하는 것은 보안 위협에 대처하는 심층적인 방어 전략을 구현하는 데 있어 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-107">Developing an application using a least-privileged user account (LUA) approach is an important part of a defensive, in-depth strategy for countering security threats.</span></span> <span data-ttu-id="e63de-108">LUA 방식을 사용할 경우 사용자는 최소 권한의 원칙에 따라야 하며, 항상 제한된 사용자 계정으로 로그온해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-108">The LUA approach ensures that users follow the principle of least privilege and always log on with limited user accounts.</span></span> <span data-ttu-id="e63de-109">관리 작업은 고정 서버 역할을 통해 분산되며 `sysadmin` 고정 서버 역할의 사용은 엄격하게 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-109">Administrative tasks are broken out using fixed server roles, and the use of the `sysadmin` fixed server role is severely restricted.</span></span>  
  
 <span data-ttu-id="e63de-110">데이터베이스 사용자에게 권한을 부여할 때는 항상 최소 권한의 원칙에 따라</span><span class="sxs-lookup"><span data-stu-id="e63de-110">Always follow the principle of least privilege when granting permissions to database users.</span></span> <span data-ttu-id="e63de-111">지정된 작업을 수행하는 데 필요한 최소한의 권한을 사용자 또는 역할에 부여해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-111">Grant the minimum permissions necessary to a user or role to accomplish a given task.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="e63de-112">LUA 방식을 사용하여 애플리케이션을 개발하고 테스트하면 개발 프로세스가 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-112">Developing and testing an application using the LUA approach adds a degree of difficulty to the development process.</span></span> <span data-ttu-id="e63de-113">시스템 관리자나 데이터베이스 소유자로 로그온하면 LUA 계정을 사용할 때보다 개체를 만들고 코드를 작성하는 것이 훨씬 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-113">It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account.</span></span> <span data-ttu-id="e63de-114">그러나 높은 수준의 권한을 가진 계정을 사용하여 애플리케이션을 개발하면 최소 권한을 가진 사용자가 높은 수준의 권한이 필요한 애플리케이션을 실행하려고 할 때 기능이 제한되기 때문에 이로 인해 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-114">However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly.</span></span> <span data-ttu-id="e63de-115">사용할 수 없는 기능을 사용할 수 있도록 사용자에게 권한을 과도하게 부여하면 애플리케이션이 공격에 쉽게 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-115">Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack.</span></span> <span data-ttu-id="e63de-116">LUA 계정으로 로그온하여 애플리케이션을 디자인, 개발 및 테스트하면 보안을 보다 체계적으로 계획하여 예기치 않은 문제를 방지할 수 있을 뿐만 아니라 임시 방편으로 높은 권한을 부여하는 위험을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-116">Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix.</span></span> <span data-ttu-id="e63de-117">Windows 인증을 사용하여 배포하도록 애플리케이션을 개발하는 경우에도 SQL Server 로그인을 사용하여 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-117">You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.</span></span>  
  
## <a name="role-based-permissions"></a><span data-ttu-id="e63de-118">역할 기반 권한</span><span class="sxs-lookup"><span data-stu-id="e63de-118">Role-Based Permissions</span></span>  

 <span data-ttu-id="e63de-119">사용자가 아닌 역할에 권한을 부여하면 더 간편하게 보안을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-119">Granting permissions to roles rather than to users simplifies security administration.</span></span> <span data-ttu-id="e63de-120">역할에 할당한 권한 집합은 해당 역할의 모든 멤버에게 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-120">Permission sets that are assigned to roles are inherited by all members of the role.</span></span> <span data-ttu-id="e63de-121">개별 사용자에 대해 별도의 권한 집합을 다시 만드는 것보다는 역할에 사용자를 추가하거나 역할에서 사용자를 제거하는 것이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-121">It is easier to add or remove users from a role than it is to recreate separate permission sets for individual users.</span></span> <span data-ttu-id="e63de-122">역할은 중첩될 수 있지만 너무 많이 중첩하면 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-122">Roles can be nested; however, too many levels of nesting can degrade performance.</span></span> <span data-ttu-id="e63de-123">고정 데이터베이스 역할에 사용자를 추가하여 권한 할당 작업을 간소화할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-123">You can also add users to fixed database roles to simplify assigning permissions.</span></span>  
  
 <span data-ttu-id="e63de-124">스키마 수준에서 권한을 부여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-124">You can grant permissions at the schema level.</span></span> <span data-ttu-id="e63de-125">이렇게 하면 스키마에 새로 만드는 모든 개체에 대한 권한이 자동으로 사용자에게 상속되기 때문에 새 개체를 만들 때마다 권한을 부여하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-125">Users automatically inherit permissions on all new objects created in the schema; you do not need to grant permissions as new objects are created.</span></span>  
  
## <a name="permissions-through-procedural-code"></a><span data-ttu-id="e63de-126">프로시저 코드를 통한 권한 부여</span><span class="sxs-lookup"><span data-stu-id="e63de-126">Permissions Through Procedural Code</span></span>  

 <span data-ttu-id="e63de-127">저장 프로시저 및 사용자 정의 함수와 같은 모듈을 통해 데이터 액세스를 캡슐화하면 애플리케이션의 보안을 강화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-127">Encapsulating data access through modules such as stored procedures and user-defined functions provides an additional layer of protection around your application.</span></span> <span data-ttu-id="e63de-128">예를 들어 저장 프로시저나 함수에 대한 권한만 부여하고 테이블과 같은 기본 개체에 대한 권한은 거부하여 사용자가 데이터베이스 개체와 직접 상호 작용하지 못하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-128">You can prevent users from directly interacting with database objects by granting permissions only to stored procedures or functions while denying permissions to underlying objects such as tables.</span></span> <span data-ttu-id="e63de-129">SQL Server에서는 소유권 체인을 통해 이러한 설정을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-129">SQL Server achieves this by ownership chaining.</span></span>  
  
## <a name="permission-statements"></a><span data-ttu-id="e63de-130">권한 문</span><span class="sxs-lookup"><span data-stu-id="e63de-130">Permission Statements</span></span>  

 <span data-ttu-id="e63de-131">다음 표에서는 세 가지 Transact-SQL 권한 문에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-131">The three Transact-SQL permission statements are described in the following table.</span></span>  
  
|<span data-ttu-id="e63de-132">권한 문</span><span class="sxs-lookup"><span data-stu-id="e63de-132">Permission Statement</span></span>|<span data-ttu-id="e63de-133">설명</span><span class="sxs-lookup"><span data-stu-id="e63de-133">Description</span></span>|  
|--------------------------|-----------------|  
|<span data-ttu-id="e63de-134">GRANT</span><span class="sxs-lookup"><span data-stu-id="e63de-134">GRANT</span></span>|<span data-ttu-id="e63de-135">권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-135">Grants a permission.</span></span>|  
|<span data-ttu-id="e63de-136">REVOKE</span><span class="sxs-lookup"><span data-stu-id="e63de-136">REVOKE</span></span>|<span data-ttu-id="e63de-137">권한을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-137">Revokes a permission.</span></span> <span data-ttu-id="e63de-138">이것은 새 개체의 기본 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-138">This is the default state of a new object.</span></span> <span data-ttu-id="e63de-139">사용자나 역할에 대해 취소한 권한은 해당 보안 주체가 할당된 다른 그룹이나 역할로부터 여전히 상속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-139">A permission revoked from a user or role can still be inherited from other groups or roles to which the principal is assigned.</span></span>|  
|<span data-ttu-id="e63de-140">거부</span><span class="sxs-lookup"><span data-stu-id="e63de-140">DENY</span></span>|<span data-ttu-id="e63de-141">DENY는 권한을 상속할 수 없도록 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-141">DENY revokes a permission so that it cannot be inherited.</span></span> <span data-ttu-id="e63de-142">DENY는 다른 모든 권한보다 우선적으로 적용됩니다. 단, 개체 소유자 또는 `sysadmin`의 멤버에는 DENY가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-142">DENY takes precedence over all permissions, except DENY does not apply to object owners or members of `sysadmin`.</span></span> <span data-ttu-id="e63de-143">`public` 역할에서 개체에 대한 권한을 DENY로 설정하면 해당 권한은 개체 소유자와 `sysadmin` 멤버를 제외한 모든 사용자와 역할에 대해 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-143">If you DENY permissions on an object to the `public` role it is denied to all users and roles except for object owners and `sysadmin` members.</span></span>|  
  
- <span data-ttu-id="e63de-144">GRANT 문을 사용하면 그룹 또는 역할에 권한을 할당할 수 있으며 데이터베이스 사용자는 이 그룹 또는 역할에서 권한을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-144">The GRANT statement can assign permissions to a group or role that can be inherited by database users.</span></span> <span data-ttu-id="e63de-145">그러나 DENY 문은 다른 모든 권한 문보다 우선적으로 적용되므로</span><span class="sxs-lookup"><span data-stu-id="e63de-145">However, the DENY statement takes precedence over all other permission statements.</span></span> <span data-ttu-id="e63de-146">권한이 거부된 사용자는 다른 역할에서 해당 권한을 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-146">Therefore, a user who has been denied a permission cannot inherit it from another role.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e63de-147">`sysadmin` 고정 서버 역할의 멤버 및 개체 소유자의 권한은 거부할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-147">Members of the `sysadmin` fixed server role and object owners cannot be denied permissions.</span></span>  
  
## <a name="ownership-chains"></a><span data-ttu-id="e63de-148">소유권 체인</span><span class="sxs-lookup"><span data-stu-id="e63de-148">Ownership Chains</span></span>  

 <span data-ttu-id="e63de-149">SQL Server에서는 권한이 부여된 보안 주체만 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-149">SQL Server ensures that only principals that have been granted permission can access objects.</span></span> <span data-ttu-id="e63de-150">여러 데이터베이스 개체가 서로 액세스하는 시퀀스를 체인이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-150">When multiple database objects access each other, the sequence is known as a chain.</span></span> <span data-ttu-id="e63de-151">개체 체인의 링크에서 이동할 때 SQL Server는 각 개체를 개별적으로 액세스할 때와는 다른 방법으로 권한을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-151">When SQL Server is traversing the links in the chain, it evaluates permissions differently than it would if it were accessing each item separately.</span></span> <span data-ttu-id="e63de-152">체인을 통해 개체에 액세스할 경우 SQL Server는 먼저 개체의 소유자와 해당 개체를 호출한 소유자(체인의 이전 링크)를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-152">When an object is accessed through a chain, SQL Server first compares the object's owner to the owner of the calling object (the previous link in the chain).</span></span> <span data-ttu-id="e63de-153">두 개체의 소유자가 같으면 참조되는 개체의 권한을 확인하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-153">If both objects have the same owner, permissions on the referenced object are not checked.</span></span> <span data-ttu-id="e63de-154">그러나 개체가 소유자가 서로 다른 또 하나의 개체에 액세스할 때마다 소유권 체인은 끊어지고 SQL Server는 호출자의 보안 컨텍스트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-154">Whenever an object accesses another object that has a different owner, the ownership chain is broken and SQL Server must check the caller's security context.</span></span>  
  
## <a name="procedural-code-and-ownership-chaining"></a><span data-ttu-id="e63de-155">프로시저 코드 및 소유권 체인</span><span class="sxs-lookup"><span data-stu-id="e63de-155">Procedural Code and Ownership Chaining</span></span>  

 <span data-ttu-id="e63de-156">사용자가 테이블에서 데이터를 선택하는 저장 프로시저에 대한 실행 권한을 가지고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-156">Suppose that a user is granted execute permissions on a stored procedure that selects data from a table.</span></span> <span data-ttu-id="e63de-157">이 저장 프로시저와 테이블의 소유자가 동일하면 사용자에게 테이블에 대한 별도의 권한을 부여할 필요가 없으며 해당 사용자의 권한을 거부할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-157">If the stored procedure and the table have the same owner, the user doesn't need to be granted any permissions on the table and can even be denied permissions.</span></span> <span data-ttu-id="e63de-158">그러나 저장 프로시저와 테이블의 소유자가 서로 다르면 SQL Server는 데이터에 대한 액세스를 허용하기 전에 테이블에 대한 사용자의 권한을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-158">However, if the stored procedure and the table have different owners, SQL Server must check the user's permissions on the table before allowing access to the data.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e63de-159">소유권 체인은 동적 SQL 문에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-159">Ownership chaining does not apply in the case of dynamic SQL statements.</span></span> <span data-ttu-id="e63de-160">SQL 문을 실행하는 프로시저를 호출하려면 호출자에게 기본 테이블에 대한 권한을 부여해야 하기 때문에 결과적으로 애플리케이션이 SQL 삽입 공격에 노출될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-160">To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack.</span></span> <span data-ttu-id="e63de-161">SQL Server에서는 가장 및 인증서를 사용한 모듈 서명과 같은 새로운 메커니즘을 제공하므로 기본 테이블에 대한 권한을 부여하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-161">SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables.</span></span> <span data-ttu-id="e63de-162">이러한 기능은 CLR 저장 프로시저에 대해서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-162">These can also be used with CLR stored procedures.</span></span>  
  
## <a name="external-resources"></a><span data-ttu-id="e63de-163">외부 리소스</span><span class="sxs-lookup"><span data-stu-id="e63de-163">External Resources</span></span>  

 <span data-ttu-id="e63de-164">자세한 내용은 다음 리소스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e63de-164">For more information, see the following resources.</span></span>  
  
|<span data-ttu-id="e63de-165">리소스</span><span class="sxs-lookup"><span data-stu-id="e63de-165">Resource</span></span>|<span data-ttu-id="e63de-166">설명</span><span class="sxs-lookup"><span data-stu-id="e63de-166">Description</span></span>|  
|--------------|-----------------|  
|[<span data-ttu-id="e63de-167">권한</span><span class="sxs-lookup"><span data-stu-id="e63de-167">Permissions</span></span>](/sql/relational-databases/security/permissions-database-engine)|<span data-ttu-id="e63de-168">권한 계층 구조, 카탈로그 뷰, 고정 서버 역할 및 데이터베이스 역할의 권한에 대해 설명하는 항목을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e63de-168">Contains topics describing permissions hierarchy, catalog views, and permissions of fixed server and database roles.</span></span>|
  
## <a name="see-also"></a><span data-ttu-id="e63de-169">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e63de-169">See also</span></span>

- [<span data-ttu-id="e63de-170">ADO.NET 애플리케이션 보안</span><span class="sxs-lookup"><span data-stu-id="e63de-170">Securing ADO.NET Applications</span></span>](../securing-ado-net-applications.md)
- [<span data-ttu-id="e63de-171">SQL Server의 애플리케이션 보안 시나리오</span><span class="sxs-lookup"><span data-stu-id="e63de-171">Application Security Scenarios in SQL Server</span></span>](application-security-scenarios-in-sql-server.md)
- [<span data-ttu-id="e63de-172">SQL Server에서 인증</span><span class="sxs-lookup"><span data-stu-id="e63de-172">Authentication in SQL Server</span></span>](authentication-in-sql-server.md)
- [<span data-ttu-id="e63de-173">SQL Server의 서버 및 데이터베이스 역할</span><span class="sxs-lookup"><span data-stu-id="e63de-173">Server and Database Roles in SQL Server</span></span>](server-and-database-roles-in-sql-server.md)
- [<span data-ttu-id="e63de-174">SQL Server에서 소유권 및 사용자와 스키마 분리</span><span class="sxs-lookup"><span data-stu-id="e63de-174">Ownership and User-Schema Separation in SQL Server</span></span>](ownership-and-user-schema-separation-in-sql-server.md)
- [<span data-ttu-id="e63de-175">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="e63de-175">ADO.NET Overview</span></span>](../ado-net-overview.md)
