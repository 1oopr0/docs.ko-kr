---
title: 성능 고려 사항(Entity Framework)
description: ADO.NET Entity Framework의 성능 특징 및 Entity Framework 응용 프로그램의 성능을 향상 시키는 데 도움이 되는 고려 사항에 대해 알아봅니다.
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 799ceff8b0bc370e929f2a4ad99b64a4fde4226a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91156732"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="3e021-103">성능 고려 사항(Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="3e021-103">Performance Considerations (Entity Framework)</span></span>

<span data-ttu-id="3e021-104">이 항목에서는 ADO.NET Entity Framework의 성능 특징에 대해 설명하고, Entity Framework 애플리케이션의 성능 개선을 위해 고려해야 할 몇 가지 사항을 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-104">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="3e021-105">쿼리 실행 단계</span><span class="sxs-lookup"><span data-stu-id="3e021-105">Stages of Query Execution</span></span>  

 <span data-ttu-id="3e021-106">Entity Framework의 쿼리 성능을 보다 잘 이해하기 위해서는 쿼리가 개념적 모델에 대해 실행하고 데이터를 개체로 반환할 때 수행되는 작업을 알고 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-106">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="3e021-107">다음 표에서는 이러한 일련의 작업에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-107">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="3e021-108">작업(Operation)</span><span class="sxs-lookup"><span data-stu-id="3e021-108">Operation</span></span>|<span data-ttu-id="3e021-109">상대 비용</span><span class="sxs-lookup"><span data-stu-id="3e021-109">Relative Cost</span></span>|<span data-ttu-id="3e021-110">빈도</span><span class="sxs-lookup"><span data-stu-id="3e021-110">Frequency</span></span>|<span data-ttu-id="3e021-111">주석</span><span class="sxs-lookup"><span data-stu-id="3e021-111">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="3e021-112">메타데이터 로드</span><span class="sxs-lookup"><span data-stu-id="3e021-112">Loading metadata</span></span>|<span data-ttu-id="3e021-113">보통</span><span class="sxs-lookup"><span data-stu-id="3e021-113">Moderate</span></span>|<span data-ttu-id="3e021-114">애플리케이션 도메인당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-114">Once in each application domain.</span></span>|<span data-ttu-id="3e021-115">Entity Framework에서 사용되는 모델 및 매핑 메타데이터가 <xref:System.Data.Metadata.Edm.MetadataWorkspace>로 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-115">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="3e021-116">이 메타데이터는 전역으로 캐시되고 동일한 애플리케이션 도메인의 다른 <xref:System.Data.Objects.ObjectContext> 인스턴스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-116">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="3e021-117">데이터베이스 연결 열기</span><span class="sxs-lookup"><span data-stu-id="3e021-117">Opening the database connection</span></span>|<span data-ttu-id="3e021-118">보통<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-118">Moderate<sup>1</sup></span></span>|<span data-ttu-id="3e021-119">필요한 만큼</span><span class="sxs-lookup"><span data-stu-id="3e021-119">As needed.</span></span>|<span data-ttu-id="3e021-120">데이터베이스에 대 한 열린 연결은 중요 한 리소스를 사용 하기 때문에 Entity Framework는 필요한 경우에만 데이터베이스 연결을 열고 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-120">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="3e021-121">또한 연결을 명시적으로 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-121">You can also explicitly open the connection.</span></span> <span data-ttu-id="3e021-122">자세한 내용은 [연결 및 트랜잭션 관리](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-122">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="3e021-123">뷰 생성</span><span class="sxs-lookup"><span data-stu-id="3e021-123">Generating views</span></span>|<span data-ttu-id="3e021-124">높은</span><span class="sxs-lookup"><span data-stu-id="3e021-124">High</span></span>|<span data-ttu-id="3e021-125">애플리케이션 도메인당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-125">Once in each application domain.</span></span> <span data-ttu-id="3e021-126">미리 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-126">(Can be pre-generated.)</span></span>|<span data-ttu-id="3e021-127">Entity Framework에서 개념적 모델에 대해 쿼리를 실행하거나 데이터 소스에 변경 내용을 저장하려면 먼저 로컬 쿼리 뷰 집합을 생성하여 데이터베이스에 액세스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-127">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="3e021-128">이러한 뷰를 생성하는 데 비용이 많이 들기 때문에 디자인 타임에 뷰를 미리 생성한 후 프로젝트에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-128">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="3e021-129">자세한 내용은 [방법: 뷰를 미리 생성 하 여 쿼리 성능 향상](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-129">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="3e021-130">쿼리 준비</span><span class="sxs-lookup"><span data-stu-id="3e021-130">Preparing the query</span></span>|<span data-ttu-id="3e021-131">보통<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-131">Moderate<sup>2</sup></span></span>|<span data-ttu-id="3e021-132">고유 쿼리당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-132">Once for each unique query.</span></span>|<span data-ttu-id="3e021-133">쿼리 명령을 작성하고, 모델 및 매핑 메타데이터를 기반으로 명령 트리를 생성하고, 반환된 데이터의 셰이프를 정의하는 비용을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-133">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="3e021-134">Entity SQL 쿼리 명령과 LINQ 쿼리가 모두 캐시되므로 동일한 쿼리를 나중에 실행하는 경우 시간이 더 적게 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-134">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="3e021-135">그러나, 여전히 컴파일된 LINQ 쿼리를 사용하여 나중에 실행할 때 이러한 비용을 줄일 수 있으며 컴파일된 쿼리는 자동으로 캐시되는 LINQ 쿼리에서보다 효율적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-135">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="3e021-136">자세한 내용은 [컴파일된 쿼리 (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-136">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="3e021-137">LINQ 쿼리 실행에 대 한 일반적인 내용은 [LINQ to Entities](./language-reference/linq-to-entities.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-137">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="3e021-138">**참고:**  메모리 내 컬렉션에 연산자를 적용 하는 LINQ to Entities 쿼리 `Enumerable.Contains` 는 자동으로 캐시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-138">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="3e021-139">또한 메모리 내 컬렉션은 컴파일된 LINQ 쿼리에서 매개 변수화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-139">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="3e021-140">쿼리 실행</span><span class="sxs-lookup"><span data-stu-id="3e021-140">Executing the query</span></span>|<span data-ttu-id="3e021-141">낮음<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-141">Low<sup>2</sup></span></span>|<span data-ttu-id="3e021-142">쿼리당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-142">Once for each query.</span></span>|<span data-ttu-id="3e021-143">ADO.NET 데이터 공급자를 사용하여 데이터 소스에 대해 명령을 실행하는 비용입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-143">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="3e021-144">대부분의 데이터 소스에서 쿼리 계획을 캐시하므로 동일한 쿼리를 나중에 실행하는 경우 시간이 더 적게 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-144">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="3e021-145">형식 로드 및 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="3e021-145">Loading and validating types</span></span>|<span data-ttu-id="3e021-146">낮음<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-146">Low<sup>3</sup></span></span>|<span data-ttu-id="3e021-147"><xref:System.Data.Objects.ObjectContext> 인스턴스당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-147">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="3e021-148">형식은 개념적 모델에서 정의하는 형식에 대해 로드되고 유효성이 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-148">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="3e021-149">추적</span><span class="sxs-lookup"><span data-stu-id="3e021-149">Tracking</span></span>|<span data-ttu-id="3e021-150">낮음<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-150">Low<sup>3</sup></span></span>|<span data-ttu-id="3e021-151">쿼리에서 반환하는 개체당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-151">Once for each object that a query returns.</span></span> <span data-ttu-id="3e021-152"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-152"><sup>4</sup></span></span>|<span data-ttu-id="3e021-153">쿼리에서 <xref:System.Data.Objects.MergeOption.NoTracking> 병합 옵션을 사용하는 경우 이 단계는 성능에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-153">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="3e021-154">쿼리에서 <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> 또는 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 병합 옵션을 사용하는 경우 <xref:System.Data.Objects.ObjectStateManager>에서 쿼리 결과를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-154">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="3e021-155">쿼리가 반환한 각 추적된 개체에 대해 <xref:System.Data.EntityKey>가 생성되고 이는 <xref:System.Data.Objects.ObjectStateEntry>에서 <xref:System.Data.Objects.ObjectStateManager>를 만드는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-155">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="3e021-156"><xref:System.Data.Objects.ObjectStateEntry>에 대한 기존 <xref:System.Data.EntityKey>를 찾을 수 있는 경우 기존 개체가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-156">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="3e021-157"><xref:System.Data.Objects.MergeOption.PreserveChanges> 또는 <xref:System.Data.Objects.MergeOption.OverwriteChanges> 옵션이 사용되는 경우 개체를 반환하기 전에 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-157">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="3e021-158">자세한 내용은 [Id 확인, 상태 관리 및 변경 내용 추적](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-158">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="3e021-159">개체 구체화</span><span class="sxs-lookup"><span data-stu-id="3e021-159">Materializing the objects</span></span>|<span data-ttu-id="3e021-160">보통<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-160">Moderate<sup>3</sup></span></span>|<span data-ttu-id="3e021-161">쿼리에서 반환하는 개체당 한 번</span><span class="sxs-lookup"><span data-stu-id="3e021-161">Once for each object that a query returns.</span></span> <span data-ttu-id="3e021-162"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="3e021-162"><sup>4</sup></span></span>|<span data-ttu-id="3e021-163">반환된 <xref:System.Data.Common.DbDataReader> 개체를 읽고, <xref:System.Data.Common.DbDataRecord> 클래스의 각 인스턴스에 있는 값을 기준으로 개체를 만들고 속성 값을 설정하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-163">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="3e021-164"><xref:System.Data.Objects.ObjectContext>에 이미 개체가 있고 쿼리에서 <xref:System.Data.Objects.MergeOption.AppendOnly> 또는 <xref:System.Data.Objects.MergeOption.PreserveChanges> 병합 옵션을 사용하는 경우 이 단계는 성능에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-164">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="3e021-165">자세한 내용은 [Id 확인, 상태 관리 및 변경 내용 추적](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-165">For more information, see [Identity Resolution, State Management, and Change Tracking](/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="3e021-166"><sup>1</sup> 데이터 원본 공급자가 연결 풀링을 구현 하는 경우 연결을 여는 비용이 풀 전체에 분산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-166"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="3e021-167">.NET Provider for SQL Server에서는 연결 풀링을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-167">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="3e021-168"><sup>2</sup> 비용은 쿼리 복잡성이 증가 함에 따라 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-168"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="3e021-169"><sup>3</sup> 쿼리에서 반환 되는 개체 수에 비례하여 총 비용이 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-169"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="3e021-170"><sup>4</sup> entityclient 쿼리가 개체 대신를 반환 하므로 entityclient 쿼리에는이 오버 헤드가 필요 하지 않습니다 <xref:System.Data.EntityClient.EntityDataReader> .</span><span class="sxs-lookup"><span data-stu-id="3e021-170"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="3e021-171">자세한 내용은 [Entity Framework용 EntityClient 공급자](entityclient-provider-for-the-entity-framework.md)(영문)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-171">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="3e021-172">기타 고려 사항</span><span class="sxs-lookup"><span data-stu-id="3e021-172">Additional Considerations</span></span>  

 <span data-ttu-id="3e021-173">다음은 Entity Framework 애플리케이션의 성능에 영향을 줄 수 있는 기타 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-173">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="3e021-174">쿼리 실행</span><span class="sxs-lookup"><span data-stu-id="3e021-174">Query Execution</span></span>  

 <span data-ttu-id="3e021-175">쿼리는 리소스를 많이 사용할 수 있으므로 코드의 어느 시점에, 어느 컴퓨터에서 쿼리를 실행하는지 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-175">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="3e021-176">지연된 실행과 즉시 실행 비교</span><span class="sxs-lookup"><span data-stu-id="3e021-176">Deferred versus immediate execution</span></span>  

 <span data-ttu-id="3e021-177"><xref:System.Data.Objects.ObjectQuery%601> 또는 LINQ 쿼리를 만들 때 쿼리가 즉시 실행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-177">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="3e021-178">쿼리 실행은 `foreach`(C#)나 `For Each`(Visual Basic) 열거 시 또는 <xref:System.Collections.Generic.List%601> 컬렉션을 채우도록 지정된 경우와 같이 결과가 필요할 때까지 지연됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-178">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="3e021-179">쿼리 실행은 사용자가 <xref:System.Data.Objects.ObjectQuery%601.Execute%2A>에서 <xref:System.Data.Objects.ObjectQuery%601> 메서드를 호출하거나 <xref:System.Linq.Enumerable.First%2A> 또는 <xref:System.Linq.Enumerable.Any%2A>와 같은 단일 쿼리를 반환하는 LINQ 메서드를 호출할 때 즉시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-179">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="3e021-180">자세한 내용은 [개체 쿼리](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) 및 [쿼리 실행 (LINQ to Entities)](./language-reference/query-execution.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-180">For more information, see [Object Queries](/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="3e021-181">LINQ 쿼리의 클라이언트 쪽 실행</span><span class="sxs-lookup"><span data-stu-id="3e021-181">Client-side execution of LINQ queries</span></span>  

 <span data-ttu-id="3e021-182">LINQ 쿼리 실행은 데이터 소스를 호스트하는 컴퓨터에서 이루어지지만 일부 LINQ 쿼리는 클라이언트 컴퓨터에서 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-182">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="3e021-183">자세한 내용은 쿼리 실행의 저장소 실행 섹션 [(LINQ to Entities)](./language-reference/query-execution.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-183">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="3e021-184">쿼리 및 매핑 복잡성</span><span class="sxs-lookup"><span data-stu-id="3e021-184">Query and Mapping Complexity</span></span>  

 <span data-ttu-id="3e021-185">엔터티 모델의 매핑 및 개별 쿼리의 복잡성은 쿼리 성능에 상당한 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-185">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="3e021-186">매핑 복잡성</span><span class="sxs-lookup"><span data-stu-id="3e021-186">Mapping complexity</span></span>  

 <span data-ttu-id="3e021-187">개념적 모델의 엔터티와 스토리지 모델의 테이블 간 단순 일대일 매핑보다 다소 복잡한 모델은 일대일 매핑의 모델보다 복잡한 명령을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-187">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="3e021-188">쿼리 복잡성</span><span class="sxs-lookup"><span data-stu-id="3e021-188">Query complexity</span></span>  

 <span data-ttu-id="3e021-189">데이터 소스에 대해 실행되는 명령에 많은 수의 조인이 필요하거나 많은 양의 데이터를 반환하는 쿼리는 다음 방식으로 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-189">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="3e021-190">간단해 보이는 개념적 모델의 쿼리로 인해 데이터 소스에 대해 보다 복잡한 쿼리가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-190">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="3e021-191">이는 Entity Framework에서 개념적 모델에 대한 쿼리를 데이터 소스에 대한 동등한 쿼리로 변환하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-191">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="3e021-192">개념적 모델의 단일 엔터티 집합이 데이터 소스에 있는 둘 이상의 테이블에 매핑되거나 엔터티 간 관계가 조인 테이블에 매핑되면 데이터 소스 쿼리에 대해 실행되는 쿼리 명령에서 하나 이상의 조인을 필요로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-192">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="3e021-193"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> 또는 <xref:System.Data.Objects.ObjectQuery%601> 클래스의 <xref:System.Data.EntityClient.EntityCommand> 메서드를 사용하여 제공된 쿼리의 데이터 소스에 대해 실행된 명령을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-193">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="3e021-194">자세한 내용은 [방법: 저장소 명령 보기](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-194">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="3e021-195">중첩 Entity SQL 쿼리는 서버에서 조인을 만들고 많은 수의 행을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-195">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="3e021-196">다음은 프로젝션 절의 중첩 쿼리 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-196">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="3e021-197">또한 이러한 쿼리로 인해 쿼리 파이프라인이 중첩 쿼리에 대해 개체가 중복된 단일 쿼리를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-197">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="3e021-198">이에 따라 단일 열이 여러 번 중복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-198">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="3e021-199">SLQ Server를 비롯한 일부 데이터베이스에서는 이로 인해 TempDB 테이블 크기가 과도하게 커질 수 있으므로 서버 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-199">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="3e021-200">중첩 쿼리를 실행할 때는 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-200">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="3e021-201">많은 양의 데이터를 반환하는 쿼리는 클라이언트가 결과 집합의 크기에 비례하여 리소스를 사용하는 작업을 수행할 경우 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-201">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="3e021-202">그러므로 쿼리에서 반환되는 데이터 양을 제한하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-202">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="3e021-203">자세한 내용은 [방법: 쿼리 결과 페이지](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-203">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3e021-204">Entity Framework에 의해 자동으로 생성된 명령은 데이터베이스 개발자가 명시적으로 작성한 유사 명령보다 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-204">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="3e021-205">데이터 소스에 대해 실행된 명령에 명시적 제어가 필요한 경우 테이블 반환 함수 또는 저장 프로시저에 대한 매핑을 정의하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-205">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="3e021-206">관계</span><span class="sxs-lookup"><span data-stu-id="3e021-206">Relationships</span></span>  

 <span data-ttu-id="3e021-207">최적의 쿼리 성능을 위해 엔터티 간 관계를 엔터티 모델의 연결과 데이터 소스의 논리적 관계로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-207">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="3e021-208">쿼리 경로</span><span class="sxs-lookup"><span data-stu-id="3e021-208">Query Paths</span></span>  

 <span data-ttu-id="3e021-209">기본적으로 <xref:System.Data.Objects.ObjectQuery%601>를 실행할 때 자체적으로 관계를 나타내는 개체는 반환되지만 관련 개체는 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-209">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="3e021-210">관련 개체는 다음 세 가지 방법 중 하나로 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-210">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="3e021-211"><xref:System.Data.Objects.ObjectQuery%601>가 실행되기 전에 쿼리 경로를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-211">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="3e021-212">개체가 노출하는 탐색 속성에서 `Load` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-212">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="3e021-213"><xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A>에서 <xref:System.Data.Objects.ObjectContext> 옵션을 `true`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-213">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="3e021-214">[엔터티 데이터 모델 Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))를 사용 하 여 개체 계층 코드를 생성 하면이 작업이 자동으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-214">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="3e021-215">자세한 내용은 [생성 된 코드 개요](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-215">For more information see [Generated Code Overview](/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3e021-216">사용할 옵션을 고려할 때는 데이터베이스에 대한 요청의 수와 단일 쿼리에 반환되는 데이터의 양이 서로 상쇄되는 관계임을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-216">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="3e021-217">자세한 내용은 [관련 개체 로드](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-217">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="3e021-218">쿼리 경로 사용</span><span class="sxs-lookup"><span data-stu-id="3e021-218">Using query paths</span></span>  

 <span data-ttu-id="3e021-219">쿼리 경로는 쿼리가 반환하는 개체의 그래프를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-219">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="3e021-220">쿼리 경로를 정의하면 데이터베이스에 대한 단일 요청만이 경로에 정의된 모든 개체를 반환하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-220">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="3e021-221">쿼리 경로를 사용하면 단순 개체 쿼리의 데이터 소스에 대해 복잡한 명령이 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-221">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="3e021-222">이는 관련 개체를 단일 쿼리에서 반환하려면 조인이 하나 이상 필요하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-222">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="3e021-223">이러한 복잡성은 다대다 관계가 포함된 상속이나 경로를 가진 엔터티와 같은 복합 엔터티 모델에 대한 쿼리에서 더 커집니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-223">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3e021-224"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>에서 생성되는 명령을 보려면 <xref:System.Data.Objects.ObjectQuery%601> 메서드를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-224">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="3e021-225">자세한 내용은 [방법: 저장소 명령 보기](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-225">For more information, see [How to: View the Store Commands](/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3e021-226">쿼리 경로에 관련 개체가 너무 많거나 개체에 행 데이터가 너무 많은 경우 데이터 소스에서 쿼리를 완료하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-226">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="3e021-227">쿼리에 필요한 중간 임시 스토리지가 데이터 소스의 용량을 초과하는 경우 이런 현상이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-227">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="3e021-228">이 경우, 관련 개체를 명시적으로 로드하는 방법으로 데이터 원본 쿼리의 복잡성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-228">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="3e021-229">명시적으로 관련 개체 로드</span><span class="sxs-lookup"><span data-stu-id="3e021-229">Explicitly loading related objects</span></span>  

 <span data-ttu-id="3e021-230">`Load` 또는 <xref:System.Data.Objects.DataClasses.EntityCollection%601>를 반환하는 탐색 속성에서 <xref:System.Data.Objects.DataClasses.EntityReference%601> 메서드를 호출하여 관련 개체를 명시적으로 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-230">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="3e021-231">명시적으로 개체를 로드하는 경우 `Load`가 호출될 때마다 데이터베이스에 대한 라운드트립이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-231">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3e021-232">`Load` 문(Visual Basic에서는 `foreach`)을 사용하는 경우와 같이 반환된 개체 컬렉션을 반복하면서 `For Each`를 호출하는 경우 데이터 소스 관련 공급자는 단일 연결에서 여러 활성 결과 집합을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-232">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="3e021-233">SQL Server 데이터베이스의 경우 공급자 연결 문자열에서 `MultipleActiveResultSets = true` 값을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-233">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="3e021-234">엔터티에 <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> 또는 <xref:System.Data.Objects.DataClasses.EntityCollection%601> 속성이 없는 경우에는 <xref:System.Data.Objects.DataClasses.EntityReference%601> 메서드를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-234">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="3e021-235">이 메서드는 POCO 엔터티를 사용하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-235">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="3e021-236">관련 개체를 명시적으로 로드할 때 조인 수 및 중복 데이터 양이 줄어들지만 `Load`에서 데이터베이스에 대한 연결을 반복해야 합니다. 이러한 반복 작업은 많은 수의 개체를 명시적으로 로드하는 경우 비용이 많이 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-236">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="3e021-237">변경 내용 저장</span><span class="sxs-lookup"><span data-stu-id="3e021-237">Saving Changes</span></span>  

 <span data-ttu-id="3e021-238"><xref:System.Data.Objects.ObjectContext.SaveChanges%2A>에서 <xref:System.Data.Objects.ObjectContext> 메서드를 호출할 때 컨텍스트에서 추가되거나, 업데이트되거나, 삭제된 각각의 개체에 대해 별도의 만들기, 업데이트 또는 삭제 명령이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-238">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="3e021-239">이러한 명령은 데이터 소스에서 단일 트랜잭션으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-239">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="3e021-240">쿼리와 마찬가지로 만들기, 업데이트 및 삭제 작업의 성능은 개념적 모델에서의 매핑 복잡성에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-240">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="3e021-241">분산 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="3e021-241">Distributed Transactions</span></span>  

 <span data-ttu-id="3e021-242">DTC(Distributed Transaction Coordinator)에 의해 관리되는 리소스가 필요한 명시적 트랜잭션에서의 작업은 DTC가 필요하지 않은 유사한 작업보다 비용이 훨씬 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-242">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="3e021-243">DTC로의 승격은 다음 상황에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-243">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="3e021-244">항상 명시적 트랜잭션을 DTC로 승격하는 SQL Server 2000 데이터베이스 또는 기타 데이터 소스에 대한 작업을 포함하는 명시적 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="3e021-244">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="3e021-245">Entity Framework에서 연결을 관리 하는 경우 SQL Server 2005에 대 한 작업이 포함 된 명시적 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-245">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="3e021-246">이는 Entity Framework의 기본 동작인 단일 트랜잭션 내에서 연결이 닫히고 다시 열릴 때마다 SQL Server 2005가 DTC로 승격 되기 때문에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-246">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="3e021-247">이 DTC 승격은 SQL Server 2008 사용 시 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-247">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="3e021-248">SQL Server 2005를 사용할 때 이러한 승격이 발생하지 않도록 하려면 트랜잭션 내에서 연결을 명시적으로 열고 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-248">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="3e021-249">자세한 내용은 [연결 및 트랜잭션 관리](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-249">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3e021-250"><xref:System.Transactions> 트랜잭션 내에서 하나 이상의 작업이 실행될 때 명시적 트랜잭션이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-250">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="3e021-251">자세한 내용은 [연결 및 트랜잭션 관리](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-251">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="3e021-252">성능 향상 전략</span><span class="sxs-lookup"><span data-stu-id="3e021-252">Strategies for Improving Performance</span></span>  

 <span data-ttu-id="3e021-253">다음 전략을 사용하면 Entity Framework에서 쿼리의 전체 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-253">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="3e021-254">뷰 미리 생성</span><span class="sxs-lookup"><span data-stu-id="3e021-254">Pre-generate views</span></span>  

 <span data-ttu-id="3e021-255">엔터티 모델을 기반으로 하는 뷰 생성 작업은 처음 애플리케이션에서 쿼리를 실행할 때 상당한 비용이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-255">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="3e021-256">EdmGen.exe 유틸리티를 사용하면 디자인 시 프로젝트에 추가할 수 있는 Visual Basic 또는 C# 코드 파일로 뷰를 미리 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-256">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="3e021-257">T4(Text Template Transformation Toolkit)를 사용하여 미리 컴파일된 뷰를 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-257">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="3e021-258">또한 런타임에 미리 생성된 뷰의 유효성을 검사하여 지정된 엔터티 모델의 현재 버전과 일치하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-258">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="3e021-259">자세한 내용은 [방법: 뷰를 미리 생성 하 여 쿼리 성능 향상](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-259">For more information, see [How to: Pre-Generate Views to Improve Query Performance](/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="3e021-260">매우 큰 모델로 작업하는 경우 고려할 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-260">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="3e021-261">.NET 메타데이터 형식은 지정된 이진 파일의 사용자 문자열 문자 수를 16,777,215(0xFFFFFF)로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-261">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="3e021-262">매우 큰 모델에 대 한 뷰를 생성 하는 경우 뷰 파일이이 크기 제한에 도달 하면 "남아 있는 논리 공간이 없으므로 사용자 문자열을 더 이상 만들 수 없습니다." 라는 메시지가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-262">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="3e021-263">컴파일 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-263">compile error.</span></span> <span data-ttu-id="3e021-264">이 크기 제한은 관리되는 모든 이진 파일에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-264">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="3e021-265">자세한 내용은 크고 복잡 한 모델을 사용할 때 오류를 방지 하는 방법을 보여 주는 [블로그](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-265">For more information see the [blog](/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="3e021-266">쿼리에 대한 NoTracking 병합 옵션 사용</span><span class="sxs-lookup"><span data-stu-id="3e021-266">Consider using the NoTracking merge option for queries</span></span>  

 <span data-ttu-id="3e021-267">개체 컨텍스트에서 반환된 개체를 추적하려면 비용이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-267">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="3e021-268">개체에 대한 변경 내용을 감지하고 동일한 논리 엔터티에 대한 여러 요청에서 동일한 개체 인스턴스를 반환하도록 할 경우 개체가 <xref:System.Data.Objects.ObjectContext> 인스턴스에 연결되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-268">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="3e021-269">개체를 업데이트 하거나 삭제할 계획이 없고 id 관리가 필요 하지 않은 경우 <xref:System.Data.Objects.MergeOption.NoTracking> 쿼리를 실행할 때 병합 옵션을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-269">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="3e021-270">적절한 양의 데이터 반환</span><span class="sxs-lookup"><span data-stu-id="3e021-270">Return the correct amount of data</span></span>  

 <span data-ttu-id="3e021-271">일부 시나리오에서는 <xref:System.Data.Objects.ObjectQuery%601.Include%2A> 메서드를 사용하여 쿼리 경로를 지정하는 작업을 수행하면 데이터베이스에 대한 라운드트립 수가 줄어들어 훨씬 속도가 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-271">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="3e021-272">그러나 또 다른 시나리오에서는 조인 수가 더 적은 아주 간단한 쿼리로 인해 데이터가 덜 중복되어 관련 개체를 로드하는 데이터베이스에 대한 추가 라운드트립의 속도가 보다 더 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-272">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="3e021-273">이 때문에 관련 개체를 검색하는 여러 방법의 성능을 테스트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-273">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="3e021-274">자세한 내용은 [관련 개체 로드](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-274">For more information, see [Loading Related Objects](/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3e021-275">단일 쿼리에서 너무 많은 데이터가 반환되지 않도록 하려면 쿼리 결과를 보다 관리하기 쉬운 그룹으로 페이징하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-275">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="3e021-276">자세한 내용은 [방법: 쿼리 결과 페이지](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-276">For more information, see [How to: Page Through Query Results](/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="3e021-277">ObjectContext의 범위 제한</span><span class="sxs-lookup"><span data-stu-id="3e021-277">Limit the scope of the ObjectContext</span></span>  

 <span data-ttu-id="3e021-278">대부분의 경우 <xref:System.Data.Objects.ObjectContext> 문(Visual Basic에서는 `using`) 내에서 `Using…End Using` 인스턴스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-278">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="3e021-279">이렇게 하면 코드가 문 블록을 종료할 때 개체 컨텍스트와 연결된 리소스가 자동으로 삭제되도록 하여 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-279">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="3e021-280">그러나 컨트롤이 개체 컨텍스트에서 관리하는 개체로 바인딩된 경우 바인딩이 필요할 때까지 <xref:System.Data.Objects.ObjectContext> 인스턴스가 유지 관리되어야 하고, 그렇지 않은 경우 해당 인스턴스가 수동으로 삭제되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-280">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="3e021-281">자세한 내용은 [연결 및 트랜잭션 관리](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-281">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="3e021-282">수동으로 데이터베이스 연결 열기</span><span class="sxs-lookup"><span data-stu-id="3e021-282">Consider opening the database connection manually</span></span>  

 <span data-ttu-id="3e021-283">응용 프로그램에서 일련의 개체 쿼리를 실행 하거나 자주 호출 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 하 여 데이터 원본에 대 한 만들기, 업데이트 및 삭제 작업을 유지 하는 경우 Entity Framework는 지속적으로 데이터 원본에 대 한 연결을 열고 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-283">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="3e021-284">이러한 경우 해당 작업 시작 시 연결을 수동으로 열고, 작업 완료 시 연결을 수동으로 닫거나 삭제하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-284">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="3e021-285">자세한 내용은 [연결 및 트랜잭션 관리](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="3e021-285">For more information, see [Managing Connections and Transactions](/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="3e021-286">성능 데이터</span><span class="sxs-lookup"><span data-stu-id="3e021-286">Performance Data</span></span>  

 <span data-ttu-id="3e021-287">Entity Framework에 대 한 일부 성능 데이터는 [ADO.NET 팀 블로그의](/archive/blogs/adonet/)다음 게시물에 게시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e021-287">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="3e021-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span><span class="sxs-lookup"><span data-stu-id="3e021-288">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="3e021-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span><span class="sxs-lookup"><span data-stu-id="3e021-289">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="3e021-290">ADO.NET Entity Framework Performance Comparison</span><span class="sxs-lookup"><span data-stu-id="3e021-290">ADO.NET Entity Framework Performance Comparison</span></span>](/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="3e021-291">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3e021-291">See also</span></span>

- [<span data-ttu-id="3e021-292">개발 및 배포 고려 사항</span><span class="sxs-lookup"><span data-stu-id="3e021-292">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
