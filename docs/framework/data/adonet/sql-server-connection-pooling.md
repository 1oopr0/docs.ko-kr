---
title: 연결 풀링 SQL Server
description: SQL Server 연결 풀링을 사용 하 여 연결을 여는 비용을 최소화 하 여 새 연결에 대 한 오버 헤드를 줄이는 방법에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07
ms.openlocfilehash: 96d9e9a7e43f71dc30bd2d7a7f1902238941d471
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91156357"
---
# <a name="sql-server-connection-pooling-adonet"></a><span data-ttu-id="2cee4-103">SQL Server 연결 풀링(ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="2cee4-103">SQL Server Connection Pooling (ADO.NET)</span></span>

<span data-ttu-id="2cee4-104">데이터베이스 서버에 연결하는 과정은 일반적으로 시간이 많이 걸리는 여러 단계로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-104">Connecting to a database server typically consists of several time-consuming steps.</span></span> <span data-ttu-id="2cee4-105">즉, 소켓이나 명명된 파이프 같은 실제 채널을 설정하고 서버와의 초기 핸드셰이크를 발생시키며 연결 문자열 정보를 구문 분석할 뿐 아니라 서버에 연결을 인증하고 현재 트랜잭션에 인리스트먼트하기 위해 검사를 실행해야 하는 등의 단계를 거쳐야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-105">A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.</span></span>  
  
 <span data-ttu-id="2cee4-106">실제로 대부분의 애플리케이션에서는 연결을 위해 구성을 하나만 사용하거나 몇 개의 서로 다른 구성을 사용하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-106">In practice, most applications use only one or a few different configurations for connections.</span></span> <span data-ttu-id="2cee4-107">따라서 애플리케이션이 실행되는 동안 여러 개의 동일한 연결이 반복해서 열리고 닫히게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-107">This means that during application execution, many identical connections will be repeatedly opened and closed.</span></span> <span data-ttu-id="2cee4-108">연결을 여는 비용을 최소화 하기 위해 ADO.NET에서는 *연결 풀링*이라는 최적화 기법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-108">To minimize the cost of opening connections, ADO.NET uses an optimization technique called *connection pooling*.</span></span>  
  
 <span data-ttu-id="2cee4-109">연결 풀링을 사용하면 새 연결을 열어야 하는 횟수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-109">Connection pooling reduces the number of times that new connections must be opened.</span></span> <span data-ttu-id="2cee4-110">*풀러* 는 물리적 연결의 소유권을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-110">The *pooler* maintains ownership of the physical connection.</span></span> <span data-ttu-id="2cee4-111">주어진 각 연결 구성에 대해 활성 연결 집합을 활성화된 상태로 유지하여 연결을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-111">It manages connections by keeping alive a set of active connections for each given connection configuration.</span></span> <span data-ttu-id="2cee4-112">사용자가 연결에 `Open`을 호출할 때마다 풀러는 풀에서 사용 가능한 연결을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-112">Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool.</span></span> <span data-ttu-id="2cee4-113">풀링된 연결이 있으면 새 연결을 여는 대신 이를 호출자에게 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-113">If a pooled connection is available, it returns it to the caller instead of opening a new connection.</span></span> <span data-ttu-id="2cee4-114">애플리케이션에서 연결에 `Close`를 호출하면 풀러는 실제로 연결을 닫는 대신 풀링된 활성 연결 집합에 이를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-114">When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it.</span></span> <span data-ttu-id="2cee4-115">연결이 풀로 반환되면 다음에 `Open`을 호출할 때 다시 사용할 수 있는 준비를 갖추게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-115">Once the connection is returned to the pool, it is ready to be reused on the next `Open` call.</span></span>  
  
 <span data-ttu-id="2cee4-116">구성이 동일한 연결만 풀링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-116">Only connections with the same configuration can be pooled.</span></span> <span data-ttu-id="2cee4-117">ADO.NET는 각 구성에 대해 하나씩, 여러 풀을 동시에 보관 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-117">ADO.NET keeps several pools at the same time, one for each configuration.</span></span> <span data-ttu-id="2cee4-118">연결은 연결 문자열을 기준으로 풀로 나뉘며 통합 보안을 사용하는 경우에는 Windows ID를 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-118">Connections are separated into pools by connection string, and by Windows identity when integrated security is used.</span></span> <span data-ttu-id="2cee4-119">또한 연결은 트랜잭션에 인리스트먼트되었는지 여부에 따라 풀링되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-119">Connections are also pooled based on whether they are enlisted in a transaction.</span></span> <span data-ttu-id="2cee4-120"><xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>를 사용할 때는 <xref:System.Data.SqlClient.SqlCredential> 인스턴스가 연결 풀에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-120">When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool.</span></span> <span data-ttu-id="2cee4-121"><xref:System.Data.SqlClient.SqlCredential>의 개별 인스턴스는 사용자 ID 및 암호가 동일한 경우에도 서로 다른 연결 풀을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-121">Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same.</span></span>  
  
 <span data-ttu-id="2cee4-122">연결 풀링을 사용하면 애플리케이션의 성능 및 확장성을 대폭 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-122">Pooling connections can significantly enhance the performance and scalability of your application.</span></span> <span data-ttu-id="2cee4-123">기본적으로 연결 풀링은 ADO.NET에서 사용 하도록 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-123">By default, connection pooling is enabled in ADO.NET.</span></span> <span data-ttu-id="2cee4-124">이를 명시적으로 비활성화하지 않는 한, 풀러는 애플리케이션에서 열리고 닫히는 연결을 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-124">Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application.</span></span> <span data-ttu-id="2cee4-125">또한 여러 개의 연결 문자열 한정자를 지정하여 연결 풀링 동작을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-125">You can also supply several connection string modifiers to control connection pooling behavior.</span></span> <span data-ttu-id="2cee4-126">자세한 내용은 이 항목 뒷부분에 있는 "연결 문자열 키워드를 사용하여 연결 풀링 제어"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-126">For more information, see "Controlling Connection Pooling with Connection String Keywords" later in this topic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cee4-127">연결 풀링을 사용하는 경우와 시간 초과 오류나 기타 로그인 오류가 발생하면 예외가 throw되고 이후 연결 시도가 "차단 기간"인 다음 5초 동안 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-127">When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the "blocking period".</span></span> <span data-ttu-id="2cee4-128">애플리케이션에서 차단 기간 내에 연결을 시도하면 첫 번째 예외가 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-128">If the application attempts to connect within the blocking period, the first exception will be thrown again.</span></span> <span data-ttu-id="2cee4-129">차단 기간이 끝난 후 또 다른 연결이 실패하면 이전 차단 기간의 두 배에서 최대 1분에 이르는 새 차단 기간이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-129">Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.</span></span>  
  
## <a name="pool-creation-and-assignment"></a><span data-ttu-id="2cee4-130">풀 만들기 및 할당</span><span class="sxs-lookup"><span data-stu-id="2cee4-130">Pool Creation and Assignment</span></span>  

 <span data-ttu-id="2cee4-131">연결이 처음 열리면 연결에서 풀과 연결 문자열을 연결하는 정확한 일치 알고리즘에 따라 연결 풀이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-131">When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection.</span></span> <span data-ttu-id="2cee4-132">각 연결 풀은 고유한 연결 문자열과 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-132">Each connection pool is associated with a distinct connection string.</span></span> <span data-ttu-id="2cee4-133">새 연결이 열릴 때 연결 문자열이 기존 풀과 정확히 일치하지 않으면 새 풀이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-133">When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created.</span></span> <span data-ttu-id="2cee4-134">연결은 프로세스, 애플리케이션 도메인, 연결 문자열을 기준으로 풀링되며 통합 보안을 사용하는 경우에는 Windows ID를 기준으로 풀링됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-134">Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity.</span></span> <span data-ttu-id="2cee4-135">연결 문자열은 정확히 일치해야 합니다. 동일한 연결에 다른 순서로 제공된 키워드는 개별적으로 풀링됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-135">Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.</span></span>  
  
 <span data-ttu-id="2cee4-136">다음 C# 예제에서는 새로운 <xref:System.Data.SqlClient.SqlConnection> 개체를 세 개 만들지만, 두 개의 연결 풀로만 이를 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-136">In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them.</span></span> <span data-ttu-id="2cee4-137">첫 번째와 두 번째 연결 문자열은 `Initial Catalog`에 대해 할당된 값이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-137">Note that the first and second connection strings differ by the value assigned for `Initial Catalog`.</span></span>  
  
```csharp
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // Pool A is created.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=pubs"))  
    {  
        connection.Open();
        // Pool B is created because the connection strings differ.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // The connection string matches pool A.  
    }  
```  
  
 <span data-ttu-id="2cee4-138">연결 문자열에 `MinPoolSize`가 지정되어 있지 않거나 0으로 지정되어 있으면 비활성 기간이 지난 후에 풀의 연결이 닫히게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-138">If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity.</span></span> <span data-ttu-id="2cee4-139">그러나 지정된 `MinPoolSize`가 0보다 크면 `AppDomain`이 언로드되어 프로세스가 종료될 때까지 연결 풀이 제거되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-139">However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends.</span></span> <span data-ttu-id="2cee4-140">비활성 또는 빈 풀을 유지 관리하는 데에는 최소의 시스템 오버헤드만 있어도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-140">Maintenance of inactive or empty pools involves minimal system overhead.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cee4-141">장애 조치(failover)와 같은 심각한 오류가 발생하면 풀이 자동으로 지워집니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-141">The pool is automatically cleared when a fatal error occurs, such as a failover.</span></span>  
  
## <a name="adding-connections"></a><span data-ttu-id="2cee4-142">연결 추가</span><span class="sxs-lookup"><span data-stu-id="2cee4-142">Adding Connections</span></span>  

 <span data-ttu-id="2cee4-143">각각의 고유 연결 문자열에 대해 연결 풀이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-143">A connection pool is created for each unique connection string.</span></span> <span data-ttu-id="2cee4-144">풀이 만들어지면 최소 풀 크기 요구 사항이 충족되도록 여러 개의 연결 개체가 만들어져 풀에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-144">When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied.</span></span> <span data-ttu-id="2cee4-145">연결은 지정된 최대 풀 크기(기본값 100) 이하로 필요한 만큼 풀에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-145">Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default).</span></span> <span data-ttu-id="2cee4-146">연결이 닫히거나 삭제되면 다시 풀로 회수됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-146">Connections are released back into the pool when they are closed or disposed.</span></span>  
  
 <span data-ttu-id="2cee4-147"><xref:System.Data.SqlClient.SqlConnection> 개체가 요청될 때 사용 가능한 연결이 있으면 풀에서 해당 개체를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-147">When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available.</span></span> <span data-ttu-id="2cee4-148">연결을 사용하려면 연결이 현재 사용되고 있지 않고, 일치하는 트랜잭션 컨텍스트가 있거나 트랜잭션 컨텍스트와 연결되어 있지 않아야 하며, 서버에 대한 올바른 링크가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-148">To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.</span></span>  
  
 <span data-ttu-id="2cee4-149">연결 풀러는 연결이 다시 풀로 회수될 때 연결을 다시 할당하여 연결 요청을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-149">The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool.</span></span> <span data-ttu-id="2cee4-150">최대 풀 크기에 도달했는데 사용 가능한 연결이 없으면 요청이 대기됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-150">If the maximum pool size has been reached and no usable connection is available, the request is queued.</span></span> <span data-ttu-id="2cee4-151">그러면 풀러는 시간 제한(기본값 15초)에 도달할 때까지 연결을 회수합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-151">The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds).</span></span> <span data-ttu-id="2cee4-152">연결 제한 시간을 초과하기 전에 풀러가 요청을 처리하지 못하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-152">If the pooler cannot satisfy the request before the connection times out, an exception is thrown.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="2cee4-153">사용이 끝난 연결은 풀로 반환되도록 항상 닫는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-153">We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool.</span></span> <span data-ttu-id="2cee4-154">`Close`개체의 또는 메서드 중 하나를 사용 `Dispose` `Connection` 하거나 `using` c #의 문 내에서 모든 연결을 열거나 `Using` Visual Basic 문을 사용 하 여이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-154">You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic.</span></span> <span data-ttu-id="2cee4-155">명시적으로 닫히지 않은 연결은 풀에 추가되거나 반환되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-155">Connections that are not explicitly closed might not be added or returned to the pool.</span></span> <span data-ttu-id="2cee4-156">자세한 내용은 [Using 문](../../../csharp/language-reference/keywords/using-statement.md) 또는 방법: Visual Basic에 대 한 [시스템 리소스 삭제](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-156">For more information, see [using Statement](../../../csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="2cee4-157">클래스의 `Close` 메서드에 있는 `Dispose`, `Connection` 또는 다른 관리 개체에 `DataReader` 또는 `Finalize`를 호출해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-157">Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class.</span></span> <span data-ttu-id="2cee4-158">종료자에서는 클래스에 직접 속한 관리되지 않는 리소스만 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-158">In a finalizer, only release unmanaged resources that your class owns directly.</span></span> <span data-ttu-id="2cee4-159">클래스에 관리되지 않는 리소스가 없는 경우 클래스 정의에 `Finalize` 메서드를 포함하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-159">If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition.</span></span> <span data-ttu-id="2cee4-160">자세한 내용은 [가비지 수집](../../../standard/garbage-collection/index.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-160">For more information, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
<span data-ttu-id="2cee4-161">열기 및 닫기 연결과 관련 된 이벤트에 대 한 자세한 내용은 SQL Server 설명서의 [Audit Login 이벤트 클래스](/sql/relational-databases/event-classes/audit-login-event-class) 및 [Audit Logout 이벤트 클래스](/sql/relational-databases/event-classes/audit-logout-event-class) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-161">For more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation.</span></span>  
  
## <a name="removing-connections"></a><span data-ttu-id="2cee4-162">연결 제거</span><span class="sxs-lookup"><span data-stu-id="2cee4-162">Removing Connections</span></span>  

 <span data-ttu-id="2cee4-163">연결이 4-8분 정도 유휴 상태였거나 풀러에서 서버와 연결하기 어렵다는 것을 감지하면 연결 풀러는 풀에서 연결을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-163">The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed.</span></span> <span data-ttu-id="2cee4-164">이러한 연결은 서버와 통신하려는 시도가 있어야만 감지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-164">Note that a severed connection can be detected only after attempting to communicate with the server.</span></span> <span data-ttu-id="2cee4-165">서버에 더 이상 연결되지 않는 연결이 있으면 그 연결은 잘못된 연결로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-165">If a connection is found that is no longer connected to the server, it is marked as invalid.</span></span> <span data-ttu-id="2cee4-166">잘못된 연결은 연결이 닫혀 있거나 회수되는 경우에만 연결 풀에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-166">Invalid connections are removed from the connection pool only when they are closed or reclaimed.</span></span>  
  
 <span data-ttu-id="2cee4-167">네트워크에 존재하지 않는 서버에 대한 연결이 있는 경우 연결 풀러에서 이 연결을 검색하지 못하고 잘못된 연결로 표시하지 못해도 풀에서 선택할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-167">If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid.</span></span> <span data-ttu-id="2cee4-168">이는 연결이 여전히 유효한지 확인하는 오버헤드가 서버에 또 다른 라운드트립을 발생시켜 풀러를 사용하는 이점을 없애기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-168">This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur.</span></span> <span data-ttu-id="2cee4-169">이 경우 연결을 사용하려는 첫 번째 시도에서 연결하기 어렵다는 것을 감지하게 되며 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-169">When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.</span></span>  
  
## <a name="clearing-the-pool"></a><span data-ttu-id="2cee4-170">풀 지우기</span><span class="sxs-lookup"><span data-stu-id="2cee4-170">Clearing the Pool</span></span>  

 <span data-ttu-id="2cee4-171">ADO.NET 2.0에서는 풀을 지우는 두 가지 새로운 메서드인 및를 도입 했습니다. <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A></span><span class="sxs-lookup"><span data-stu-id="2cee4-171">ADO.NET 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>.</span></span> <span data-ttu-id="2cee4-172">`ClearAllPools`는 지정된 공급자의 연결 풀을 지우며 `ClearPool`은 특정 연결과 관련된 연결 풀을 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-172">`ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection.</span></span> <span data-ttu-id="2cee4-173">메서드를 호출할 때 사용 중인 연결이 있으면 적절히 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-173">If there are connections being used at the time of the call, they are marked appropriately.</span></span> <span data-ttu-id="2cee4-174">그리고 연결이 닫히면 풀로 반환되는 대신 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-174">When they are closed, they are discarded instead of being returned to the pool.</span></span>  
  
## <a name="transaction-support"></a><span data-ttu-id="2cee4-175">트랜잭션 지원</span><span class="sxs-lookup"><span data-stu-id="2cee4-175">Transaction Support</span></span>  

 <span data-ttu-id="2cee4-176">연결은 트랜잭션 컨텍스트에 따라 풀에서 선택되어 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-176">Connections are drawn from the pool and assigned based on transaction context.</span></span> <span data-ttu-id="2cee4-177">연결 문자열에 `Enlist=false`가 지정되어 있는 경우를 제외하고 연결 풀에서는 연결이 <xref:System.Transactions.Transaction.Current%2A> 컨텍스트에 인리스트먼트되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-177">Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context.</span></span> <span data-ttu-id="2cee4-178">연결이 닫혀 인리스트먼트된 `System.Transactions` 트랜잭션이 있는 풀로 반환되면 동일한 `System.Transactions` 트랜잭션이 있는 해당 연결 풀에 대한 다음 요청을 통해 동일한 연결(사용할 수 있는 경우)이 반환되도록 하는 데 따로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-178">When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available.</span></span> <span data-ttu-id="2cee4-179">하지만, 그와 같은 요청이 실행되고 풀링된 연결을 사용할 수 없는 경우 연결은 풀의 비트랜잭트 부분에서 선택되어 인리스트먼트됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-179">If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted.</span></span> <span data-ttu-id="2cee4-180">풀의 어느 영역에서도 연결을 사용할 수 없으면 새 연결이 만들어져 인리스트먼트됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-180">If no connections are available in either area of the pool, a new connection is created and enlisted.</span></span>  
  
 <span data-ttu-id="2cee4-181">연결이 닫힐 때는 풀로 다시 회수되고 트랜잭션 컨텍스트에 따라 적절한 분할로 회수됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-181">When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context.</span></span> <span data-ttu-id="2cee4-182">따라서 분산 트랜잭션이 여전히 보류 중이더라도 오류를 생성하지 않고 연결을 닫을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-182">Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending.</span></span> <span data-ttu-id="2cee4-183">이렇게 하여 분산 트랜잭션을 나중에 커밋하거나 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-183">This allows you to commit or abort the distributed transaction later.</span></span>  
  
## <a name="controlling-connection-pooling-with-connection-string-keywords"></a><span data-ttu-id="2cee4-184">연결 문자열 키워드를 사용하여 연결 풀링 제어</span><span class="sxs-lookup"><span data-stu-id="2cee4-184">Controlling Connection Pooling with Connection String Keywords</span></span>  

 <span data-ttu-id="2cee4-185">`ConnectionString` 개체의 <xref:System.Data.SqlClient.SqlConnection> 속성에서는 연결 문자열 키/값 쌍을 사용하여 연결 풀링 논리의 동작을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-185">The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic.</span></span> <span data-ttu-id="2cee4-186">자세한 내용은 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-186">For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.</span></span>  
  
## <a name="pool-fragmentation"></a><span data-ttu-id="2cee4-187">풀 조각화</span><span class="sxs-lookup"><span data-stu-id="2cee4-187">Pool Fragmentation</span></span>  

 <span data-ttu-id="2cee4-188">풀 조각화는 애플리케이션에서 프로세스가 종료될 때까지 해제되지 않는 많은 수의 풀을 만들어 낼 수 있는 여러 웹 애플리케이션에 공통적으로 발생하는 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-188">Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits.</span></span> <span data-ttu-id="2cee4-189">이렇게 되면 많은 수의 연결이 열려 있는 상태로 메모리를 소모하므로 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-189">This leaves a large number of connections open and consuming memory, which results in poor performance.</span></span>  
  
### <a name="pool-fragmentation-due-to-integrated-security"></a><span data-ttu-id="2cee4-190">통합 보안으로 인한 풀 조각화</span><span class="sxs-lookup"><span data-stu-id="2cee4-190">Pool Fragmentation Due to Integrated Security</span></span>  

 <span data-ttu-id="2cee4-191">연결은 연결 문자열과 사용자 ID에 따라 풀링합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-191">Connections are pooled according to the connection string plus the user identity.</span></span> <span data-ttu-id="2cee4-192">따라서 웹 사이트에 기본 인증이나 Windows 인증과 함께 통합 보안 로그인을 사용하는 경우 사용자당 풀의 수는 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-192">Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user.</span></span> <span data-ttu-id="2cee4-193">이렇게 하면 단일 사용자에 대한 후속 데이터베이스 요청의 성능이 향상되지만 해당 사용자는 다른 사용자가 설정한 연결을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-193">Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users.</span></span> <span data-ttu-id="2cee4-194">또한 데이터베이스 서버에 대한 사용자당 연결이 하나 이상이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-194">It also results in at least one connection per user to the database server.</span></span> <span data-ttu-id="2cee4-195">이는 개발자가 보안 및 감사 요구 사항에 대해 검토해야 하는 특정 웹 애플리케이션 아키텍처의 부작용입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-195">This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.</span></span>  
  
### <a name="pool-fragmentation-due-to-many-databases"></a><span data-ttu-id="2cee4-196">많은 데이터베이스로 인한 풀 조각화</span><span class="sxs-lookup"><span data-stu-id="2cee4-196">Pool Fragmentation Due to Many Databases</span></span>  

 <span data-ttu-id="2cee4-197">많은 인터넷 서비스 공급자가 단일 서버에서 여러 개의 웹 사이트를 호스트합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-197">Many Internet service providers host several Web sites on a single server.</span></span> <span data-ttu-id="2cee4-198">이들은 단일 데이터베이스를 사용하여 폼 인증 로그인을 확인한 다음 해당 사용자나 사용자 그룹에 대해 특정 데이터베이스 연결을 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-198">They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users.</span></span> <span data-ttu-id="2cee4-199">그러면 인증 데이터베이스 연결이 풀링되어 모든 사용자가 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-199">The connection to the authentication database is pooled and used by everyone.</span></span> <span data-ttu-id="2cee4-200">그러나 각 데이터베이스마다 개별 연결 풀이 있으므로 서버에 대한 연결 수가 증가하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-200">However, there is a separate pool of connections to each database, which increase the number of connections to the server.</span></span>  
  
 <span data-ttu-id="2cee4-201">이 역시 애플리케이션 디자인의 부작용입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-201">This is also a side-effect of the application design.</span></span> <span data-ttu-id="2cee4-202">하지만 SQL Server에 연결할 때 보안 수준을 떨어뜨리지 않고 이러한 부작용을 비교적 간단히 해결할 수 있는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-202">There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server.</span></span> <span data-ttu-id="2cee4-203">각 사용자나 그룹에 대해 개별 데이터베이스에 연결하는 대신 서버에 있는 동일한 데이터베이스에 연결한 다음 Transact-SQL USE 문을 실행하여 원하는 데이터베이스로 변경하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-203">Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the Transact-SQL USE statement to change to the desired database.</span></span> <span data-ttu-id="2cee4-204">다음 코드 조각에서는 `master` 데이터베이스에 대한 초기 연결을 만든 다음 이를 `databaseName` 문자열 변수에 지정된 원하는 데이터베이스로 전환하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-204">The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable.</span></span>  
  
```vb  
' Assumes that command is a valid SqlCommand object and that  
' connectionString connects to master.  
    command.Text = "USE DatabaseName"  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    command.ExecuteNonQuery()  
End Using  
```  
  
```csharp  
// Assumes that command is a SqlCommand object and that  
// connectionString connects to master.  
command.Text = "USE DatabaseName";  
using (SqlConnection connection = new SqlConnection(  
  connectionString))  
  {  
    connection.Open();  
    command.ExecuteNonQuery();  
  }  
```  
  
## <a name="application-roles-and-connection-pooling"></a><span data-ttu-id="2cee4-205">애플리케이션 역할 및 연결 풀링</span><span class="sxs-lookup"><span data-stu-id="2cee4-205">Application Roles and Connection Pooling</span></span>  

 <span data-ttu-id="2cee4-206">`sp_setapprole` 시스템 저장 프로시저를 호출하여 SQL Server 애플리케이션 역할을 활성화한 후에는 해당 연결의 보안 컨텍스트를 다시 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-206">After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset.</span></span> <span data-ttu-id="2cee4-207">그러나 풀링이 활성화된 경우 연결이 풀로 반환되고 풀링된 연결이 다시 사용될 때 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-207">However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused.</span></span> <span data-ttu-id="2cee4-208">자세한 내용은 기술 자료 문서 "[OLE DB 리소스 풀링을 사용 하는 SQL 응용 프로그램 역할 오류](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)"를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="2cee4-208">For more information, see the Knowledge Base article, "[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)."</span></span>  
  
### <a name="application-role-alternatives"></a><span data-ttu-id="2cee4-209">애플리케이션 역할의 대안</span><span class="sxs-lookup"><span data-stu-id="2cee4-209">Application Role Alternatives</span></span>  

 <span data-ttu-id="2cee4-210">애플리케이션 역할 대신 사용할 수 있는 보안 메커니즘을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2cee4-210">We recommend that you take advantage of security mechanisms that you can use instead of application roles.</span></span> <span data-ttu-id="2cee4-211">자세한 내용은 [SQL Server에서 응용 프로그램 역할 만들기](./sql/creating-application-roles-in-sql-server.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="2cee4-211">For more information, see [Creating Application Roles in SQL Server](./sql/creating-application-roles-in-sql-server.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2cee4-212">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2cee4-212">See also</span></span>

- [<span data-ttu-id="2cee4-213">연결 풀링</span><span class="sxs-lookup"><span data-stu-id="2cee4-213">Connection Pooling</span></span>](connection-pooling.md)
- [<span data-ttu-id="2cee4-214">SQL Server 및 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="2cee4-214">SQL Server and ADO.NET</span></span>](./sql/index.md)
- [<span data-ttu-id="2cee4-215">성능 카운터</span><span class="sxs-lookup"><span data-stu-id="2cee4-215">Performance Counters</span></span>](performance-counters.md)
- [<span data-ttu-id="2cee4-216">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="2cee4-216">ADO.NET Overview</span></span>](ado-net-overview.md)
