---
title: 분산 트랜잭션
ms.date: 03/30/2017
ms.assetid: 718b257c-bcb2-408e-b004-a7b0adb1c176
ms.openlocfilehash: b6553d50039ca0f4888f0610b187c6b419a462b5
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91153199"
---
# <a name="distributed-transactions"></a><span data-ttu-id="ad760-102">분산 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="ad760-102">Distributed Transactions</span></span>

<span data-ttu-id="ad760-103">트랜잭션은 하나의 단위로 성공(커밋)하거나 실패(중단)한 관련 작업의 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-103">A transaction is a set of related tasks that either succeeds (commit) or fails (abort) as a unit, among other things.</span></span> <span data-ttu-id="ad760-104">*분산 트랜잭션은* 여러 리소스에 영향을 주는 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-104">A *distributed transaction* is a transaction that affects several resources.</span></span> <span data-ttu-id="ad760-105">분산 트랜잭션을 커밋하는 경우 모든 참가자는 데이터의 모든 변경 내용이 영구적으로 유지된다는 것을 보증해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-105">For a distributed transaction to commit, all participants must guarantee that any change to data will be permanent.</span></span> <span data-ttu-id="ad760-106">시스템 작동이 중단되거나 다른 예측할 수 없는 이벤트가 발생해도 변경 내용이 지속되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-106">Changes must persist despite system crashes or other unforeseen events.</span></span> <span data-ttu-id="ad760-107">참가자 중 하나라도 이러한 보증을 이행하지 못하면 전체 트랜잭션이 실패하게 되며 트랜잭션 범위 내의 모든 데이터 변경 내용이 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-107">If even a single participant fails to make this guarantee, the entire transaction fails, and any changes to data within the scope of the transaction are rolled back.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad760-108">트랜잭션이 활성화된 상태에서 `DataReader`를 시작하는 경우 트랜잭션을 커밋하거나 롤백하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-108">An exception will be thrown if you attempt to commit or roll back a transaction if a `DataReader` is started while the transaction is active.</span></span>  
  
## <a name="working-with-systemtransactions"></a><span data-ttu-id="ad760-109">System.Transactions 사용</span><span class="sxs-lookup"><span data-stu-id="ad760-109">Working with System.Transactions</span></span>  

 <span data-ttu-id="ad760-110">.NET Framework에서는 <xref:System.Transactions> 네임스페이스의 API를 통해 분산 트랜잭션을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-110">In the .NET Framework, distributed transactions are managed through the API in the <xref:System.Transactions> namespace.</span></span> <span data-ttu-id="ad760-111">여러 영구 리소스 관리자가 관련되어 있는 경우 <xref:System.Transactions> API는 MS DTC(Microsoft Distributed Transaction Coordinator)와 같은 트랜잭션 모니터에 분산 트랜잭션 처리를 위임하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-111">The <xref:System.Transactions> API will delegate distributed transaction handling to a transaction monitor such as the Microsoft Distributed Transaction Coordinator (MS DTC) when multiple persistent resource managers are involved.</span></span> <span data-ttu-id="ad760-112">자세한 내용은 [트랜잭션 기본 사항](../transactions/transaction-fundamentals.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ad760-112">For more information, see [Transaction Fundamentals](../transactions/transaction-fundamentals.md).</span></span>  
  
 <span data-ttu-id="ad760-113">ADO.NET 2.0에서는 연결을 `EnlistTransaction` 인스턴스에 기록하는 <xref:System.Transactions.Transaction> 메서드를 사용하여 분산 트랜잭션에 기록하는 새로운 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-113">ADO.NET 2.0 introduced support for enlisting in a distributed transaction using the `EnlistTransaction` method, which enlists a connection in a <xref:System.Transactions.Transaction> instance.</span></span> <span data-ttu-id="ad760-114">이전 버전의 ADO.NET에서는 연결의 `EnlistDistributedTransaction` 메서드를 사용하여 연결을 이전 버전과의 호환성이 지원되는 <xref:System.EnterpriseServices.ITransaction> 인스턴스에 인리스트먼트함으로써 분산 트랜잭션에 명시적으로 인리스트먼트했습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-114">In previous versions of ADO.NET, explicit enlistment in distributed transactions was performed using the `EnlistDistributedTransaction` method of a connection to enlist a connection in a <xref:System.EnterpriseServices.ITransaction> instance, which is supported for backwards compatibility.</span></span> <span data-ttu-id="ad760-115">엔터프라이즈 서비스 트랜잭션에 대 한 자세한 내용은 [엔터프라이즈 서비스 및 COM + 트랜잭션과의 상호 운용성](../transactions/interoperability-with-enterprise-services-and-com-transactions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ad760-115">For more information on Enterprise Services transactions, see [Interoperability with Enterprise Services and COM+ Transactions](../transactions/interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
 <span data-ttu-id="ad760-116">.NET Framework Provider for SQL Server를 사용하여 SQL Server 데이터베이스에서 <xref:System.Transactions> 트랜잭션을 실행하는 경우 간단한 <xref:System.Transactions.Transaction>이 자동으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-116">When using a <xref:System.Transactions> transaction with the .NET Framework Provider for SQL Server against a SQL Server database, a lightweight <xref:System.Transactions.Transaction> will automatically be used.</span></span> <span data-ttu-id="ad760-117">그러면 필요할 때만 트랜잭션을 완전 분산 트랜잭션으로 승격시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-117">The transaction can then be promoted to a full distributed transaction on an as-needed basis.</span></span> <span data-ttu-id="ad760-118">자세한 내용은 [SQL Server와의 시스템 트랜잭션 통합](system-transactions-integration-with-sql-server.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ad760-118">For more information, see [System.Transactions Integration with SQL Server](system-transactions-integration-with-sql-server.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad760-119">Oracle 데이터베이스가 한 번에 참여할 수 있는 분산 트랜잭션의 최대 수는 기본적으로 10으로 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-119">The maximum number of distributed transactions that an Oracle database can participate in at one time is set to 10 by default.</span></span> <span data-ttu-id="ad760-120">Oracle 데이터베이스에 연결되어 있을 때 10번째 트랜잭션을 초과하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-120">After the 10th transaction when connected to an Oracle database, an exception is thrown.</span></span> <span data-ttu-id="ad760-121">Oracle은 분산 트랜잭션 내에서 `DDL`을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-121">Oracle does not support `DDL` inside of a distributed transaction.</span></span>  
  
## <a name="automatically-enlisting-in-a-distributed-transaction"></a><span data-ttu-id="ad760-122">자동으로 분산 트랜잭션에 인리스트먼트</span><span class="sxs-lookup"><span data-stu-id="ad760-122">Automatically Enlisting in a Distributed Transaction</span></span>  

 <span data-ttu-id="ad760-123">자동 인리스트먼트는 ADO.NET 연결과 `System.Transactions`를 통합하는 기본 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-123">Automatic enlistment is the default (and preferred) way of integrating ADO.NET connections with `System.Transactions`.</span></span> <span data-ttu-id="ad760-124">연결 개체는 트랜잭션이 활성화되어 있음을 인지하는 경우 기존 분산 트랜잭션에 자동으로 인리스트먼트합니다. `System.Transaction`의 측면에서 볼 때 트랜잭션이 활성화되어 있다는 것은 `Transaction.Current`가 null이 아님을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-124">A connection object will automatically enlist in an existing distributed transaction if it determines that a transaction is active, which, in `System.Transaction` terms, means that `Transaction.Current` is not null.</span></span> <span data-ttu-id="ad760-125">자동 트랜잭션 인리스트먼트는 연결이 열려 있을 때 발생하며</span><span class="sxs-lookup"><span data-stu-id="ad760-125">Automatic transaction enlistment occurs when the connection is opened.</span></span> <span data-ttu-id="ad760-126">그 이후에는 트랜잭션 범위 내에서 명령이 실행되더라도 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-126">It will not happen after that even if a command is executed inside of a transaction scope.</span></span> <span data-ttu-id="ad760-127">`Enlist=false`에 대한 연결 문자열 매개 변수로 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A?displayProperty=nameWithType>를 지정하거나 `OLE DB Services=-7`에 대한 연결 문자열 매개 변수로 <xref:System.Data.OleDb.OleDbConnection.ConnectionString%2A?displayProperty=nameWithType>을 지정하면 기존 트랜잭션에 대한 자동 인리스트먼트를 비활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-127">You can disable auto-enlistment in existing transactions by specifying `Enlist=false` as a connection string parameter for a <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A?displayProperty=nameWithType>, or `OLE DB Services=-7` as a connection string parameter for an <xref:System.Data.OleDb.OleDbConnection.ConnectionString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ad760-128">Oracle 및 ODBC 연결 문자열 매개 변수에 대한 자세한 내용은 <xref:System.Data.OracleClient.OracleConnection.ConnectionString%2A?displayProperty=nameWithType> 및 <xref:System.Data.Odbc.OdbcConnection.ConnectionString%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ad760-128">For more information on Oracle and ODBC connection string parameters, see <xref:System.Data.OracleClient.OracleConnection.ConnectionString%2A?displayProperty=nameWithType> and <xref:System.Data.Odbc.OdbcConnection.ConnectionString%2A?displayProperty=nameWithType>.</span></span>  
  
## <a name="manually-enlisting-in-a-distributed-transaction"></a><span data-ttu-id="ad760-129">수동으로 분산 트랜잭션에 인리스트먼트</span><span class="sxs-lookup"><span data-stu-id="ad760-129">Manually Enlisting in a Distributed Transaction</span></span>  

 <span data-ttu-id="ad760-130">자동 인리스트먼트가 비활성화되어 있거나 연결이 열린 후 시작된 트랜잭션에 인리스트먼트해야 하는 경우에는 사용 중인 공급자에 대한 `EnlistTransaction` 개체의 <xref:System.Data.Common.DbConnection> 메서드를 사용하여 기존 분산 트랜잭션에 인리스트먼트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-130">If auto-enlistment is disabled or you need to enlist a transaction that was started after the connection was opened, you can enlist in an existing distributed transaction using the `EnlistTransaction` method of the <xref:System.Data.Common.DbConnection> object for the provider you are working with.</span></span> <span data-ttu-id="ad760-131">기존 분산 트랜잭션에 인리스트먼트하면 트랜잭션이 커밋되거나 롤백되는 경우 데이터 소스 코드에서 변경된 내용도 함께 커밋되거나 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-131">Enlisting in an existing distributed transaction ensures that, if the transaction is committed or rolled back, modifications made by the code at the data source will be committed or rolled back as well.</span></span>  
  
 <span data-ttu-id="ad760-132">분산 트랜잭션 인리스트먼트는 특히 비즈니스 개체를 풀링할 때 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-132">Enlisting in distributed transactions is particularly applicable when pooling business objects.</span></span> <span data-ttu-id="ad760-133">비즈니스 개체가 열린 연결로 풀링되는 경우 해당 연결이 열리면 자동 트랜잭션 인리스트먼트만 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-133">If a business object is pooled with an open connection, automatic transaction enlistment only occurs when that connection is opened.</span></span> <span data-ttu-id="ad760-134">풀링된 비즈니스 개체를 사용하여 여러 트랜잭션을 수행하는 경우 해당 개체에 대해 열린 연결은 새로 초기화된 트랜잭션에 자동으로 인리스트먼트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-134">If multiple transactions are performed using the pooled business object, the open connection for that object will not automatically enlist in newly initiated transactions.</span></span> <span data-ttu-id="ad760-135">이 경우 연결에 대해 자동 트랜잭션 인리스트먼트를 비활성화한 다음 `EnlistTransaction`을 사용하여 연결을 트랜잭션에 인리스트먼트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-135">In this case, you can disable automatic transaction enlistment for the connection and enlist the connection in transactions using `EnlistTransaction`.</span></span>  
  
 <span data-ttu-id="ad760-136">`EnlistTransaction` 기존 트랜잭션에 대 한 참조 인 형식의 단일 인수를 사용 <xref:System.Transactions.Transaction> 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-136">`EnlistTransaction` takes a single argument of type <xref:System.Transactions.Transaction> that is a reference to the existing transaction.</span></span> <span data-ttu-id="ad760-137">연결의 `EnlistTransaction` 메서드를 호출한 후에는 해당 연결을 통해 데이터 소스에서 수정된 모든 내용이 트랜잭션에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-137">After calling the connection's `EnlistTransaction` method, all modifications made at the data source using the connection are included in the transaction.</span></span> <span data-ttu-id="ad760-138">null 값을 전달하면 현재 분산 트랜잭션 인리스트먼트에서 연결의 인리스트먼트가 취소됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-138">Passing a null value unenlists the connection from its current distributed transaction enlistment.</span></span> <span data-ttu-id="ad760-139">연결은 `EnlistTransaction`을 호출하기 전에 열려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-139">Note that the connection must be opened before calling `EnlistTransaction`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ad760-140">트랜잭션에 연결을 명시적으로 인리스트먼트하면 첫 번째 트랜잭션이 종료될 때까지 인리스트먼트를 취소하거나 다른 트랜잭션에 인리스트먼트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-140">Once a connection is explicitly enlisted on a transaction, it cannot be un-enlisted or enlisted in another transaction until the first transaction finishes.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="ad760-141">연결의 `EnlistTransaction` 메서드를 사용하여 연결에서 트랜잭션이 이미 시작된 경우에는 <xref:System.Data.Common.DbConnection.BeginTransaction%2A>이 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-141">`EnlistTransaction` throws an exception if the connection has already begun a transaction using the connection's <xref:System.Data.Common.DbConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="ad760-142">그러나 트랜잭션이 데이터 소스에서 시작된 로컬 트랜잭션(예: <xref:System.Data.SqlClient.SqlCommand>를 사용하여 명시적으로 BEGIN TRANSACTION 문 실행)인 경우에는 `EnlistTransaction`이 로컬 트랜잭션을 롤백하고 요청 시 기존 분산 트랜잭션에 인리스트먼트합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-142">However, if the transaction is a local transaction started at the data source (for example, executing the BEGIN TRANSACTION statement explicitly using a <xref:System.Data.SqlClient.SqlCommand>), `EnlistTransaction` will roll back the local transaction and enlist in the existing distributed transaction as requested.</span></span> <span data-ttu-id="ad760-143">로컬 트랜잭션이 롤백되었다는 알림은 전송되지 않으므로 <xref:System.Data.Common.DbConnection.BeginTransaction%2A>을 사용하여 시작되지 않은 로컬 트랜잭션을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-143">You will not receive notice that the local transaction was rolled back, and must manage any local transactions not started using <xref:System.Data.Common.DbConnection.BeginTransaction%2A>.</span></span> <span data-ttu-id="ad760-144">SQL Server에서 .NET Framework Data Provider for SQL Server(`SqlClient`)를 사용하는 경우 등록하려고 시도하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-144">If you are using the .NET Framework Data Provider for SQL Server (`SqlClient`) with SQL Server, an attempt to enlist will throw an exception.</span></span> <span data-ttu-id="ad760-145">다른 모든 경우는 탐지되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-145">All other cases will go undetected.</span></span>  
  
## <a name="promotable-transactions-in-sql-server"></a><span data-ttu-id="ad760-146">SQL Server의 승격 가능한 트랜잭션</span><span class="sxs-lookup"><span data-stu-id="ad760-146">Promotable Transactions in SQL Server</span></span>  

 <span data-ttu-id="ad760-147">SQL Server에서는 필요한 경우에만 간단한 로컬 트랜잭션을 분산 트랜잭션으로 자동 승격시킬 수 있는 승격 가능한 트랜잭션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-147">SQL Server supports promotable transactions in which a local lightweight transaction can be automatically promoted to a distributed transaction only if it is required.</span></span> <span data-ttu-id="ad760-148">승격 가능한 트랜잭션은 추가 오버헤드가 필요한 경우를 제외하고 분산 트랜잭션의 추가 오버헤드를 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-148">A promotable transaction does not invoke the added overhead of a distributed transaction unless the added overhead is required.</span></span> <span data-ttu-id="ad760-149">자세한 내용 및 코드 샘플은 [SQL Server와의 시스템 트랜잭션 통합](system-transactions-integration-with-sql-server.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ad760-149">For more information and a code sample, see [System.Transactions Integration with SQL Server](system-transactions-integration-with-sql-server.md).</span></span>  
  
## <a name="configuring-distributed-transactions"></a><span data-ttu-id="ad760-150">분산 트랜잭션 구성</span><span class="sxs-lookup"><span data-stu-id="ad760-150">Configuring Distributed Transactions</span></span>  

 <span data-ttu-id="ad760-151">분산 트랜잭션을 사용하기 위해 네트워크에서 MS DTC를 사용해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-151">You may need to enable the MS DTC over the network in order to use distributed transactions.</span></span> <span data-ttu-id="ad760-152">Windows 방화벽이 활성화되어 있는 경우 MS DTC 서비스에서 네트워크를 사용하거나 MS DTC 포트를 열 수 있도록 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ad760-152">If have the Windows Firewall enabled, you must allow the MS DTC service to use the network or open the MS DTC port.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ad760-153">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ad760-153">See also</span></span>

- [<span data-ttu-id="ad760-154">트랜잭션 및 동시성</span><span class="sxs-lookup"><span data-stu-id="ad760-154">Transactions and Concurrency</span></span>](transactions-and-concurrency.md)
- [<span data-ttu-id="ad760-155">SQL Server와의 System.Transactions 통합</span><span class="sxs-lookup"><span data-stu-id="ad760-155">System.Transactions Integration with SQL Server</span></span>](system-transactions-integration-with-sql-server.md)
- [<span data-ttu-id="ad760-156">ADO.NET 개요</span><span class="sxs-lookup"><span data-stu-id="ad760-156">ADO.NET Overview</span></span>](ado-net-overview.md)
