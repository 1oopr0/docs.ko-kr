---
title: '연습: 부분 신뢰 시나리오에서 코드 내보내기'
description: 부분 신뢰 시나리오에서 코드를 내보내는 방법을 살펴봅니다. 리플렉션 내보내기는 동일한 API를 사용하지만 일부 기능은 부분 신뢰 코드에 특수 권한이 필요합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- reflection emit, anonymously hosted dynamic methods
- partial trust, reflection
- partial trust, emitting dynamic methods
- reflection emit, partial trust scenarios
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- reflection emit, dynamic methods
- dynamic methods
ms.assetid: c45be261-2a9d-4c4e-9bd6-27f0931b7d25
ms.openlocfilehash: 70adb3ce67b45459b18741948092a912f6173731
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/21/2020
ms.locfileid: "86865192"
---
# <a name="walkthrough-emitting-code-in-partial-trust-scenarios"></a><span data-ttu-id="6baac-104">연습: 부분 신뢰 시나리오에서 코드 내보내기</span><span class="sxs-lookup"><span data-stu-id="6baac-104">Walkthrough: Emitting Code in Partial Trust Scenarios</span></span>

<span data-ttu-id="6baac-105">리플렉션 내보내기에는 완전 또는 부분 신뢰에서 동일한 API 집합이 사용되지만 일부 기능의 경우 부분적으로 신뢰할 수 있는 코드에 특수 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-105">Reflection emit uses the same API set in full or partial trust, but some features require special permissions in partially trusted code.</span></span> <span data-ttu-id="6baac-106">또한 리플렉션 내보내기에는 부분 신뢰와 함께 보안 투명 어셈블리에서 사용되도록 디자인된 익명으로 호스트되는 동적 메서드의 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-106">In addition, reflection emit has a feature, anonymously hosted dynamic methods, that is designed to be used with partial trust and by security-transparent assemblies.</span></span>

> [!NOTE]
> <span data-ttu-id="6baac-107">.NET Framework 3.5 이전에는 코드 내보내기에는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission>이 필요했습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-107">Before .NET Framework 3.5, emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="6baac-108">이 권한은 기본적으로 `FullTrust` 및 `Intranet` 명명된 권한 집합에 포함되지만 `Internet` 권한 집합에는 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-108">This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="6baac-109">따라서 <xref:System.Security.SecurityCriticalAttribute> 특성이 있고 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>에 대해 <xref:System.Security.PermissionSet.Assert%2A> 메서드를 실행한 경우에만 부분 신뢰 영역에서 라이브러리를 사용할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-109">Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="6baac-110">코딩 오류가 있을 경우 보안 허점이 발생할 수 있으므로 이러한 라이브러리는 신중한 보안 검토가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-110">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="6baac-111">.NET Framework 3.5에서는 코드 생성이 기본적으로 권한 있는 작업이 아니기 때문에 보안 요구를 실행하지 않고 부분 신뢰 시나리오에서 코드를 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-111">The .NET Framework 3.5 allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="6baac-112">즉, 생성된 코드에 코드를 내보내는 어셈블리보다 많은 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-112">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="6baac-113">따라서 코드를 내보내는 라이브러리가 보안상 투명할 수 있으며 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>를 어설션할 필요가 없으므로 보안 라이브러리 작성 시 철저한 보안 검토가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-113">This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.</span></span>

<span data-ttu-id="6baac-114">이 연습에서는 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-114">This walkthrough illustrates the following tasks:</span></span>

- <span data-ttu-id="6baac-115">[부분적으로 신뢰할 수 있는 코드를 테스트하기 위한 간단한 샌드박스 설정](#Setting_up).</span><span class="sxs-lookup"><span data-stu-id="6baac-115">[Setting up a simple sandbox for testing partially trusted code](#Setting_up).</span></span>

  > [!IMPORTANT]
  > <span data-ttu-id="6baac-116">부분 신뢰에서 코드를 간단하게 실험하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-116">This is a simple way to experiment with code in partial trust.</span></span> <span data-ttu-id="6baac-117">실제로 신뢰할 수 없는 위치에서 나오는 코드를 실행하려면 [방법: 샌드박스에서 부분적으로 신뢰할 수 있는 코드 실행](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6baac-117">To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>

- <span data-ttu-id="6baac-118">[부분적으로 신뢰할 수 있는 애플리케이션 도메인에서 코드 실행](#Running_code).</span><span class="sxs-lookup"><span data-stu-id="6baac-118">[Running code in partially trusted application domains](#Running_code).</span></span>

- <span data-ttu-id="6baac-119">[익명으로 호스트된 동적 메서드를 사용하여 부분 신뢰에서 코드 내보내기 및 실행](#Using_methods).</span><span class="sxs-lookup"><span data-stu-id="6baac-119">[Using anonymously hosted dynamic methods to emit and execute code in partial trust](#Using_methods).</span></span>

<span data-ttu-id="6baac-120">부분 신뢰 시나리오의 코드 내보내기에 대한 자세한 내용은 [리플렉션 내보내기의 보안 문제점](security-issues-in-reflection-emit.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6baac-120">For more information about emitting code in partial trust scenarios, see [Security Issues in Reflection Emit](security-issues-in-reflection-emit.md).</span></span>

<span data-ttu-id="6baac-121">이러한 절차에 표시된 코드의 전체 목록을 보려면 이 연습의 끝부분에 있는 [예제 섹션](#Example)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6baac-121">For a complete listing of the code shown in these procedures, see the [Example section](#Example) at the end of this walkthrough.</span></span>

<a name="Setting_up"></a>

## <a name="setting-up-partially-trusted-locations"></a><span data-ttu-id="6baac-122">부분적으로 신뢰할 수 있는 위치 설정</span><span class="sxs-lookup"><span data-stu-id="6baac-122">Setting up Partially Trusted Locations</span></span>

<span data-ttu-id="6baac-123">다음 두 절차는 부분 신뢰를 사용하여 코드를 테스트할 수 있는 위치를 설정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-123">The following two procedures show how to set up locations from which you can test code with partial trust.</span></span>

- <span data-ttu-id="6baac-124">첫 번째 절차는 코드에 인터넷 권한이 부여되는 샌드박스가 적용된 애플리케이션 도메인을 만드는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-124">The first procedure shows how to create a sandboxed application domain in which code is granted Internet permissions.</span></span>

- <span data-ttu-id="6baac-125">두 번째 절차는 동일하거나 낮은 신뢰 수준 어셈블리의 전용 데이터에 액세스할 수 있도록 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그와 함께 <xref:System.Security.Permissions.ReflectionPermission>을 부분적으로 신뢰할 수 있는 애플리케이션 도메인에 추가하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-125">The second procedure shows how to add <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust.</span></span>

### <a name="creating-sandboxed-application-domains"></a><span data-ttu-id="6baac-126">샌드박스가 적용된 애플리케이션 도메인 만들기</span><span class="sxs-lookup"><span data-stu-id="6baac-126">Creating Sandboxed Application Domains</span></span>

<span data-ttu-id="6baac-127">어셈블리가 부분 신뢰로 실행되는 애플리케이션 도메인을 만들려면 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버로드를 사용하여 애플리케이션 도메인을 만드는 방식으로 어셈블리에 부여되는 권한 집합을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-127">To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to create the application domain.</span></span> <span data-ttu-id="6baac-128">권한 집합을 지정하는 가장 쉬운 방법은 보안 정책에서 명명된 권한 집합을 검색하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-128">The easiest way to specify the grant set is to retrieve a named permission set from security policy.</span></span>

<span data-ttu-id="6baac-129">다음 절차에서는 코드를 부분 신뢰로 실행하는 샌드박스가 적용된 애플리케이션 도메인을 만들어 내보낸 코드가 public 형식의 public 멤버에만 액세스할 수 있는 시나리오를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-129">The following procedure creates a sandboxed application domain that runs your code with partial trust, to test scenarios in which emitted code can access only public members of public types.</span></span> <span data-ttu-id="6baac-130">이후 절차에서는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>를 추가하여 내보낸 코드가 동일하거나 낮은 수준의 권한이 부여된 어셈블리의 public이 아닌 형식 및 멤버에 액세스할 수 있는 시나리오를 테스트하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-130">A subsequent procedure shows how to add <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions.</span></span>

#### <a name="to-create-an-application-domain-with-partial-trust"></a><span data-ttu-id="6baac-131">부분 신뢰를 사용하여 애플리케이션 도메인을 만들려면</span><span class="sxs-lookup"><span data-stu-id="6baac-131">To create an application domain with partial trust</span></span>

1. <span data-ttu-id="6baac-132">샌드박스가 적용된 애플리케이션 도메인에서 어셈블리에 부여할 권한 집합을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-132">Create a permission set to grant to the assemblies in the sandboxed application domain.</span></span> <span data-ttu-id="6baac-133">이 경우 인터넷 영역의 권한 집합이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-133">In this case, the permission set of the Internet zone is used.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#2)]
    [!code-vb[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#2)]

2. <span data-ttu-id="6baac-134"><xref:System.AppDomainSetup> 개체를 만들어 애플리케이션 경로를 통해 애플리케이션 도메인을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-134">Create an <xref:System.AppDomainSetup> object to initialize the application domain with an application path.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="6baac-135">간단히 설명하기 위해 이 코드 예제에서는 현재 폴더를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-135">For simplicity, this code example uses the current folder.</span></span> <span data-ttu-id="6baac-136">실제로 인터넷에서 나오는 코드를 실행하려면 [방법: 샌드박스에서 부분적으로 신뢰할 수 있는 코드 실행](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)의 설명대로 신뢰할 수 없는 코드에 별도의 폴더를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-136">To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md).</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#3)]
    [!code-vb[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#3)]

3. <span data-ttu-id="6baac-137">애플리케이션 도메인을 만들어 애플리케이션 도메인 설정 정보 및 애플리케이션 도메인에서 실행되는 모든 어셈블리의 권한 집합을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-137">Create the application domain, specifying the application domain setup information and the grant set for all assemblies that execute in the application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#5)]
    [!code-vb[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#5)]

    <span data-ttu-id="6baac-138"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버로드의 마지막 매개 변수를 사용하여 애플리케이션 도메인의 권한 집합이 아닌 완전 신뢰가 부여되는 어셈블리 집합을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-138">The last parameter of the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain.</span></span> <span data-ttu-id="6baac-139">애플리케이션에서 사용하는 .NET Framework 어셈블리는 글로벌 어셈블리 캐시에 있으므로 해당 어셈블리를 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-139">You do not have to specify the .NET Framework assemblies that your application uses, because those assemblies are in the global assembly cache.</span></span> <span data-ttu-id="6baac-140">전역 어셈블리 캐시의 어셈블리는 항상 완전히 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-140">Assemblies in the global assembly cache are always fully trusted.</span></span> <span data-ttu-id="6baac-141">이 매개 변수를 사용하여 전역 어셈블리 캐시에 없는 강력한 이름의 어셈블리를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-141">You can use this parameter to specify strong-named assemblies that are not in the global assembly cache.</span></span>

### <a name="adding-restrictedmemberaccess-to-sandboxed-domains"></a><span data-ttu-id="6baac-142">샌드박스가 적용된 도메인에 RestrictedMemberAccess 추가</span><span class="sxs-lookup"><span data-stu-id="6baac-142">Adding RestrictedMemberAccess to Sandboxed Domains</span></span>

<span data-ttu-id="6baac-143">호스트 애플리케이션에서는 익명으로 호스트된 동적 메서드가 코드를 내보내는 어셈블리의 신뢰 수준과 같거나 낮은 신뢰 수준을 가진 어셈블리의 전용 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-143">Host applications can allow anonymously hosted dynamic methods to have access to private data in assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span> <span data-ttu-id="6baac-144">JIT(Just-In-Time) 표시 유형 확인을 건너뛰는 이 제한된 기능을 사용할 수 있도록 호스트 애플리케이션에서는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>(RMA) 플래그가 있는 <xref:System.Security.Permissions.ReflectionPermission> 개체를 권한 집합에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-144">To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) flag to the grant set.</span></span>

<span data-ttu-id="6baac-145">예를 들어 호스트에서는 인터넷 애플리케이션에 인터넷 권한과 RMA를 부여할 수 있으므로 인터넷 애플리케이션은 자체 어셈블리의 전용 데이터에 액세스하는 코드를 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-145">For example, a host might grant Internet applications Internet permissions plus RMA, so that an Internet application can emit code that accesses private data in its own assemblies.</span></span> <span data-ttu-id="6baac-146">액세스는 같거나 낮은 신뢰 수준의 어셈블리로 제한되므로 인터넷 애플리케이션은 .NET Framework 어셈블리와 같이 완전히 신뢰할 수 있는 어셈블리의 멤버에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-146">Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as .NET Framework assemblies.</span></span>

> [!NOTE]
> <span data-ttu-id="6baac-147">권한 상승을 방지하기 위해 익명으로 호스트된 동적 메서드가 생성될 때 내보내는 어셈블리에 대한 스택 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-147">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="6baac-148">메서드가 호출되면 스택 정보가 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-148">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="6baac-149">따라서 완전히 신뢰할 수 있는 코드에서 호출되는 익명으로 호스트된 동적 메서드는 계속해서 내보내는 어셈블리의 신뢰 수준으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-149">Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.</span></span>

#### <a name="to-create-an-application-domain-with-partial-trust-plus-rma"></a><span data-ttu-id="6baac-150">부분 신뢰 및 RMA를 사용하여 애플리케이션 도메인을 만들려면</span><span class="sxs-lookup"><span data-stu-id="6baac-150">To create an application domain with partial trust plus RMA</span></span>

1. <span data-ttu-id="6baac-151"><xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>(RMA) 플래그가 있는 새 <xref:System.Security.Permissions.ReflectionPermission> 개체를 만들고 <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> 메서드를 사용하여 권한 집합에 권한을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-151">Create a new <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) flag, and use the <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> method to add the permission to the grant set.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#7)]
    [!code-vb[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#7)]

    <span data-ttu-id="6baac-152"><xref:System.Security.PermissionSet.AddPermission%2A> 메서드는 권한 집합에 권한을 추가합니다(권한이 포함되지 않은 경우).</span><span class="sxs-lookup"><span data-stu-id="6baac-152">The <xref:System.Security.PermissionSet.AddPermission%2A> method adds the permission to the grant set if it is not already included.</span></span> <span data-ttu-id="6baac-153">권한이 이미 권한 집합에 포함된 경우 지정된 플래그가 기존 권한에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-153">If the permission is already included in the grant set, the specified flags are added to the existing permission.</span></span>

    > [!NOTE]
    > <span data-ttu-id="6baac-154">RMA는 익명으로 호스트된 동적 메서드의 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-154">RMA is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="6baac-155">일반 동적 메서드가 JIT 표시 유형 확인을 건너뛰면 내보낸 코드에 완전 신뢰가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-155">When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.</span></span>

2. <span data-ttu-id="6baac-156">애플리케이션 도메인을 만들어 애플리케이션 도메인 설정 정보 및 권한 집합을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-156">Create the application domain, specifying the application domain setup information and the grant set.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#8)]
    [!code-vb[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#8)]

<a name="Running_code"></a>

## <a name="running-code-in-sandboxed-application-domains"></a><span data-ttu-id="6baac-157">샌드박스가 적용된 애플리케이션 도메인에서 코드 실행</span><span class="sxs-lookup"><span data-stu-id="6baac-157">Running Code in Sandboxed Application Domains</span></span>

<span data-ttu-id="6baac-158">다음 절차에서는 애플리케이션 도메인에서 실행할 수 있는 메서드를 사용하여 클래스를 정의하는 방법, 도메인에서 클래스 인스턴스를 만드는 방법 및 해당 메서드를 실행하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-158">The following procedure explains how to define a class by using methods that can be executed in an application domain, how to create an instance of the class in the domain, and how to execute its methods.</span></span>

#### <a name="to-define-and-execute-a-method-in-an-application-domain"></a><span data-ttu-id="6baac-159">애플리케이션 도메인에서 메서드를 정의 및 실행하려면</span><span class="sxs-lookup"><span data-stu-id="6baac-159">To define and execute a method in an application domain</span></span>

1. <span data-ttu-id="6baac-160"><xref:System.MarshalByRefObject>에서 파생된 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-160">Define a class that derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="6baac-161">이 작업을 통해 다른 애플리케이션 도메인에서 클래스 인스턴스를 만들고 애플리케이션 도메인 경계에 걸쳐 메서드 호출을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-161">This enables you to create instances of the class in other application domains and to make method calls across application domain boundaries.</span></span> <span data-ttu-id="6baac-162">이 예제에서 클래스 이름은 `Worker`입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-162">The class in this example is named `Worker`.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#10)]
    [!code-vb[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#10)]

2. <span data-ttu-id="6baac-163">실행할 코드가 포함된 public 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-163">Define a public method that contains the code you want to execute.</span></span> <span data-ttu-id="6baac-164">이 예제에서 코드는 간단한 동적 메서드를 내보내고, 대리자를 만들어 메서드를 실행하고, 대리자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-164">In this example, the code emits a simple dynamic method, creates a delegate to execute the method, and invokes the delegate.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#11)]
    [!code-vb[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#11)]

3. <span data-ttu-id="6baac-165">기본 프로그램에서 어셈블리의 표시 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-165">In your main program, get the display name of your assembly.</span></span> <span data-ttu-id="6baac-166">이 이름은 샌드박스가 적용된 애플리케이션 도메인에서 `Worker` 클래스의 인스턴스를 만들 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-166">This name is used when you create instances of the `Worker` class in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#14)]
    [!code-vb[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#14)]

4. <span data-ttu-id="6baac-167">기본 프로그램에서 이 연습의 [첫 번째 절차](#Setting_up)에 설명된 대로 샌드박스가 적용된 애플리케이션 도메인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-167">In your main program, create a sandboxed application domain, as described in [the first procedure](#Setting_up) in this walkthrough.</span></span> <span data-ttu-id="6baac-168">`SimpleEmitDemo` 메서드는 public 메서드만 사용하므로 `Internet` 권한 집합에 권한을 추가할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-168">You do not have to add any permissions to the `Internet` permission set, because the `SimpleEmitDemo` method uses only public methods.</span></span>

5. <span data-ttu-id="6baac-169">기본 프로그램에서 샌드박스가 적용된 애플리케이션 도메인에서 `Worker` 클래스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-169">In your main program, create an instance of the `Worker` class in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#12)]
    [!code-vb[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#12)]

    <span data-ttu-id="6baac-170"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 메서드는 대상 애플리케이션 도메인에서 개체를 만들고 개체의 속성과 메서드를 호출하는 데 사용될 수 있는 프록시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-170">The <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object.</span></span>

    > [!NOTE]
    > <span data-ttu-id="6baac-171">Visual Studio에서 이 코드를 사용하는 경우 네임스페이스를 포함하도록 클래스의 이름을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-171">If you use this code in Visual Studio, you must change the name of the class to include the namespace.</span></span> <span data-ttu-id="6baac-172">기본적으로 네임스페이스는 프로젝트의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-172">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="6baac-173">예를 들어 프로젝트가 "PartialTrust"이면 클래스 이름은 "PartialTrust.Worker"입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-173">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>

6. <span data-ttu-id="6baac-174">`SimpleEmitDemo` 메서드를 호출하는 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-174">Add code to call the `SimpleEmitDemo` method.</span></span> <span data-ttu-id="6baac-175">호출은 애플리케이션 도메인 경계에서 마샬링되고 코드는 샌드박스가 적용된 애플리케이션 도메인에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-175">The call is marshaled across the application domain boundary, and the code is executed in the sandboxed application domain.</span></span>

    [!code-csharp[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#13)]
    [!code-vb[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#13)]

<a name="Using_methods"></a>

## <a name="using-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="6baac-176">익명으로 호스트된 동적 메서드 사용</span><span class="sxs-lookup"><span data-stu-id="6baac-176">Using Anonymously Hosted Dynamic Methods</span></span>

<span data-ttu-id="6baac-177">익명으로 호스트된 동적 메서드는 시스템에서 제공되는 투명 어셈블리와 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-177">Anonymously hosted dynamic methods are associated with a transparent assembly that is provided by the system.</span></span> <span data-ttu-id="6baac-178">따라서 메서드에 포함된 코드는 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-178">Therefore, the code they contain is transparent.</span></span> <span data-ttu-id="6baac-179">반면, 일반 동적 메서드는 기존 모듈과 연결되고(직접 지정되거나 연결된 형식에서 유추됨) 해당 모듈의 보안 수준을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-179">Ordinary dynamic methods, on the other hand, must be associated with an existing module (whether directly specified or inferred from an associated type), and take their security level from that module.</span></span>

> [!NOTE]
> <span data-ttu-id="6baac-180">익명 호스팅을 제공하는 어셈블리와 동적 메서드를 연결하는 유일한 방법은 다음 절차에 설명된 생성자를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-180">The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure.</span></span> <span data-ttu-id="6baac-181">익명 호스팅 어셈블리에서는 모듈을 명시적으로 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-181">You cannot explicitly specify a module in the anonymous hosting assembly.</span></span>

<span data-ttu-id="6baac-182">일반 동적 메서드는 연결된 모듈의 internal 멤버 또는 연결된 형식의 private 멤버에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-182">Ordinary dynamic methods have access to the internal members of the module they are associated with, or to the private members of the type they are associated with.</span></span> <span data-ttu-id="6baac-183">익명으로 호스트된 동적 메서드는 다른 코드에서 분리되므로 전용 데이터에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-183">Because anonymously hosted dynamic methods are isolated from other code, they do not have access to private data.</span></span> <span data-ttu-id="6baac-184">하지만 JIT 표시 유형 확인을 건너뛰어 전용 데이터에 대한 액세스 권한을 얻는 제한된 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-184">However, they do have a restricted ability to skip JIT visibility checks to gain access to private data.</span></span> <span data-ttu-id="6baac-185">이 기능은 코드를 내보내는 어셈블리의 신뢰 수준과 같거나 낮은 신뢰 수준을 가진 어셈블리로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-185">This ability is limited to assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.</span></span>

<span data-ttu-id="6baac-186">권한 상승을 방지하기 위해 익명으로 호스트된 동적 메서드가 생성될 때 내보내는 어셈블리에 대한 스택 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-186">To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.</span></span> <span data-ttu-id="6baac-187">메서드가 호출되면 스택 정보가 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-187">When the method is invoked, the stack information is checked.</span></span> <span data-ttu-id="6baac-188">완전히 신뢰할 수 있는 코드에서 호출되는 익명으로 호스트된 동적 메서드는 계속해서 메서드를 내보낸 어셈블리의 신뢰 수준으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-188">An anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the assembly that emitted it.</span></span>

#### <a name="to-use-anonymously-hosted-dynamic-methods"></a><span data-ttu-id="6baac-189">익명으로 호스트된 동적 메서드를 사용하려면</span><span class="sxs-lookup"><span data-stu-id="6baac-189">To use anonymously hosted dynamic methods</span></span>

- <span data-ttu-id="6baac-190">연결된 모듈 또는 형식을 지정하지 않는 생성자를 사용하여 익명으로 호스트된 동적 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-190">Create an anonymously hosted dynamic method by using a constructor that does not specify an associated module or type.</span></span>

  [!code-csharp[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#15)]
  [!code-vb[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#15)]

  <span data-ttu-id="6baac-191">public 형식 및 메서드만 사용하는 익명으로 호스트된 동적 메서드의 경우 제한된 멤버 액세스가 필요하지 않고 JIT 표시 유형 확인을 건너뛸 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-191">If an anonymously hosted dynamic method uses only public types and methods, it does not require restricted member access and does not have to skip JIT visibility checks.</span></span>

  <span data-ttu-id="6baac-192">동적 메서드를 내보내기 위한 특수 권한이 필요하지 않지만, 내보낸 코드에는 코드에서 사용하는 형식 및 메서드에 필요한 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-192">No special permissions are required to emit a dynamic method, but the emitted code requires the permissions that are demanded by the types and methods it uses.</span></span> <span data-ttu-id="6baac-193">예를 들어 내보낸 코드가 파일에 액세스하는 메서드를 호출할 경우 <xref:System.Security.Permissions.FileIOPermission>이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-193">For example, if the emitted code calls a method that accesses a file, it requires <xref:System.Security.Permissions.FileIOPermission>.</span></span> <span data-ttu-id="6baac-194">신뢰 수준에 권한이 포함되지 않은 경우 내보낸 코드가 실행될 때 보안 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-194">If the trust level does not include that permission, a security exception is thrown when the emitted code is executed.</span></span> <span data-ttu-id="6baac-195">여기 표시된 코드는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 메서드만 사용하는 동적 메서드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-195">The code shown here emits a dynamic method that uses only the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6baac-196">따라서 코드는 부분적으로 신뢰할 수 있는 위치에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-196">Therefore, the code can be executed from partially trusted locations.</span></span>

- <span data-ttu-id="6baac-197">또는 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 생성자를 사용하고 `restrictedSkipVisibility` 매개 변수를 `true`로 지정하여 JIT 표시 유형 확인을 건너뛰는 제한된 기능을 가진 익명으로 호스트된 동적 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-197">Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor and specifying `true` for the `restrictedSkipVisibility` parameter.</span></span>

  [!code-csharp[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#16)]
  [!code-vb[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#16)]

  <span data-ttu-id="6baac-198">익명으로 호스트된 동적 메서드는 내보내는 어셈블리의 신뢰 수준과 같거나 낮은 신뢰 수준을 가진 어셈블리의 전용 데이터에만 액세스할 수 있도록 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-198">The restriction is that the anonymously hosted dynamic method can access private data only in assemblies with trust levels equal to or less than the trust level of the emitting assembly.</span></span> <span data-ttu-id="6baac-199">예를 들어 인터넷 신뢰로 실행되고 있는 동적 메서드는 인터넷 신뢰로 실행되고 있는 다른 어셈블리의 전용 데이터에 액세스할 수 있지만 .NET Framework 어셈블리의 전용 데이터에는 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-199">For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of .NET Framework assemblies.</span></span> <span data-ttu-id="6baac-200">.NET Framework 어셈블리는 글로벌 어셈블리 캐시에 설치되고 항상 완전히 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-200">.NET Framework assemblies are installed in the global assembly cache and are always fully trusted.</span></span>

  <span data-ttu-id="6baac-201">익명으로 호스트된 동적 메서드는 호스트 애플리케이션에서 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그로 <xref:System.Security.Permissions.ReflectionPermission>을 부여하는 경우에만 JIT 표시 유형 확인을 건너뛰는 이 제한된 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-201">Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="6baac-202">메서드가 호출될 때 이 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-202">The demand for this permission is made when the method is invoked.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6baac-203">동적 메서드가 생성될 때 내보내는 어셈블리의 호출 스택 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-203">Call stack information for the emitting assembly is included when the dynamic method is constructed.</span></span> <span data-ttu-id="6baac-204">따라서 메서드를 호출하는 어셈블리가 아닌 내보내는 어셈블리에 대한 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-204">Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method.</span></span> <span data-ttu-id="6baac-205">이렇게 하면 내보낸 코드가 높은 권한으로 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-205">This prevents the emitted code from being executed with elevated permissions.</span></span>

  <span data-ttu-id="6baac-206">이 연습의 끝부분에 있는 [전체 코드 예제](#Example)는 제한된 멤버 액세스의 사용 및 제한 사항을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-206">The [complete code example](#Example) at the end of this walkthrough demonstrates the use and limitations of restricted member access.</span></span> <span data-ttu-id="6baac-207">`Worker` 클래스에는 표시 유형 확인을 건너뛰는 제한된 기능을 사용하거나 사용하지 않고 익명으로 호스트된 동적 메서드를 만들 수 있는 메서드가 포함되며 예제에서는 다양한 신뢰 수준을 가진 애플리케이션 도메인에서 이 메서드를 실행한 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-207">Its `Worker` class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6baac-208">표시 유형 확인을 건너뛰는 제한된 기능은 익명으로 호스트된 동적 메서드의 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-208">The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods.</span></span> <span data-ttu-id="6baac-209">일반 동적 메서드가 JIT 표시 유형 확인을 건너뛸 경우 완전 신뢰가 부여되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-209">When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.</span></span>

<a name="Example"></a>

## <a name="example"></a><span data-ttu-id="6baac-210">예제</span><span class="sxs-lookup"><span data-stu-id="6baac-210">Example</span></span>

### <a name="description"></a><span data-ttu-id="6baac-211">설명</span><span class="sxs-lookup"><span data-stu-id="6baac-211">Description</span></span>

<span data-ttu-id="6baac-212">다음 코드 예제는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 플래그를 사용하여 대상 멤버가 코드를 내보내는 어셈블리와 같거나 낮은 신뢰 수준에 있는 경우에만 익명으로 호스트된 동적 메서드가 JIT 표시 유형 확인을 건너뛰도록 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-212">The following code example demonstrates the use of the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code.</span></span>

<span data-ttu-id="6baac-213">예제에서는 애플리케이션 도메인 경계에서 마샬링될 수 있는 `Worker` 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-213">The example defines a `Worker` class that can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="6baac-214">클래스에는 동적 메서드를 내보내고 실행하는 두 개의 `AccessPrivateMethod` 메서드 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-214">The class has two `AccessPrivateMethod` method overloads that emit and execute dynamic methods.</span></span> <span data-ttu-id="6baac-215">첫 번째 오버로드는 `Worker` 클래스의 private `PrivateMethod` 메서드를 호출하는 동적 메서드를 내보내며 JIT 표시 유형 확인 여부에 관계없이 동적 메서드를 내보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-215">The first overload emits a dynamic method that calls the private `PrivateMethod` method of the `Worker` class, and it can emit the dynamic method with or without JIT visibility checks.</span></span> <span data-ttu-id="6baac-216">두 번째 오버로드는 <xref:System.String> 클래스의 `internal` 속성(Visual Basic의 `Friend` 속성)에 액세스하는 동적 메서드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-216">The second overload emits a dynamic method that accesses an `internal` property (`Friend` property in Visual Basic) of the <xref:System.String> class.</span></span>

<span data-ttu-id="6baac-217">예제에서는 도우미 메서드를 사용하여 `Internet` 권한으로 제한된 권한 집합을 만들고 나서 <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> 메서드 오버로드로 애플리케이션 도메인을 만들어 도메인에서 실행되는 모든 코드가 이 권한 집합을 사용하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-217">The example uses a helper method to create a grant set limited to `Internet` permissions, and then creates an application domain, using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to specify that all code that executes in the domain uses this grant set.</span></span> <span data-ttu-id="6baac-218">예제에서는 애플리케이션 도메인에서 `Worker` 클래스 인스턴스를 만들고 `AccessPrivateMethod` 메서드를 두 번 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-218">The example creates an instance of the `Worker` class in the application domain, and executes the `AccessPrivateMethod` method two times.</span></span>

- <span data-ttu-id="6baac-219">`AccessPrivateMethod` 메서드가 처음 실행될 때 JIT 표시 유형 확인이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-219">The first time the `AccessPrivateMethod` method is executed, JIT visibility checks are enforced.</span></span> <span data-ttu-id="6baac-220">JIT 표시 유형 확인을 실행하면 동적 메서드가 private 메서드에 액세스할 수 없으므로 동적 메서드는 호출 시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-220">The dynamic method fails when it is invoked, because JIT visibility checks prevent it from accessing the private method.</span></span>

- <span data-ttu-id="6baac-221">`AccessPrivateMethod` 메서드가 두 번째로 실행될 때는 JIT 표시 유형 확인을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-221">The second time the `AccessPrivateMethod` method is executed, JIT visibility checks are skipped.</span></span> <span data-ttu-id="6baac-222">`Internet` 권한 집합은 표시 유형 확인을 건너뛸 충분한 권한을 부여하지 않으므로 동적 메서드는 컴파일 시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-222">The dynamic method fails when it is compiled, because the `Internet` grant set does not grant sufficient permissions to skip visibility checks.</span></span>

<span data-ttu-id="6baac-223">예제에서는 <xref:System.Security.Permissions.ReflectionPermission>을 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>와 함께 권한 집합에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-223">The example adds <xref:System.Security.Permissions.ReflectionPermission> with <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> to the grant set.</span></span> <span data-ttu-id="6baac-224">예제에서는 그다음에 두 번째 도메인을 만들어 도메인에서 실행되는 모든 코드에 새 권한 집합의 권한이 부여되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-224">The example then creates a second domain, specifying that all code that executes in the domain is granted the permissions in the new grant set.</span></span> <span data-ttu-id="6baac-225">예제에서는 새 애플리케이션 도메인에서 `Worker` 클래스 인스턴스를 만들고 `AccessPrivateMethod` 메서드의 오버로드를 둘 다 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-225">The example creates an instance of the `Worker` class in the new application domain, and executes both overloads of the `AccessPrivateMethod` method.</span></span>

- <span data-ttu-id="6baac-226">`AccessPrivateMethod` 메서드의 첫 번째 오버로드가 실행되고 JIT 표시 유형 확인을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-226">The first overload of the `AccessPrivateMethod` method is executed, and JIT visibility checks are skipped.</span></span> <span data-ttu-id="6baac-227">코드를 내보내는 어셈블리가 private 메서드를 포함하는 어셈블리와 같기 때문에 동적 메서드가 성공적으로 컴파일 및 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-227">The dynamic method compiles and executes successfully, because the assembly that emits the code is the same as the assembly that contains the private method.</span></span> <span data-ttu-id="6baac-228">따라서 신뢰 수준이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-228">Therefore, the trust levels are equal.</span></span> <span data-ttu-id="6baac-229">`Worker` 클래스를 포함하는 애플리케이션에 여러 어셈블리가 있는 경우에는 모든 어셈블리의 신뢰 수준이 같으므로 모든 해당 어셈블리에 대해 동일한 프로세스가 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-229">If the application that contains the `Worker` class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level.</span></span>

- <span data-ttu-id="6baac-230">`AccessPrivateMethod` 메서드의 두 번째 오버로드가 실행되고 다시 JIT 표시 유형 확인을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-230">The second overload of the `AccessPrivateMethod` method is executed, and again JIT visibility checks are skipped.</span></span> <span data-ttu-id="6baac-231">이때 동적 메서드는 <xref:System.String> 클래스의 `internal` `FirstChar` 속성에 액세스하려고 하므로 동적 메서드가 컴파일 시 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-231">This time the dynamic method fails when it is compiled, because it tries to access the `internal` `FirstChar` property of the <xref:System.String> class.</span></span> <span data-ttu-id="6baac-232"><xref:System.String> 클래스를 포함하는 어셈블리는 완전히 신뢰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-232">The assembly that contains the <xref:System.String> class is fully trusted.</span></span> <span data-ttu-id="6baac-233">따라서 이 어셈블리는 코드를 내보내는 어셈블리보다 신뢰 수준이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-233">Therefore, it is at a higher level of trust than the assembly that emits the code.</span></span>

<span data-ttu-id="6baac-234">이 비교는 신뢰할 수 있는 코드의 보안을 손상시키지 않고 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>를 사용하여 부분적으로 신뢰할 수 있는 코드가 다른 부분적으로 신뢰할 수 있는 코드의 표시 유형 확인을 건너뛰는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-234">This comparison shows how <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code.</span></span>

### <a name="code"></a><span data-ttu-id="6baac-235">코드</span><span class="sxs-lookup"><span data-stu-id="6baac-235">Code</span></span>

[!code-csharp[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#1)]
[!code-vb[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#1)]

## <a name="compiling-the-code"></a><span data-ttu-id="6baac-236">코드 컴파일</span><span class="sxs-lookup"><span data-stu-id="6baac-236">Compiling the Code</span></span>

- <span data-ttu-id="6baac-237">Visual Studio에서 이 코드 예제를 빌드하는 경우 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 메서드에 클래스를 전달할 때 네임스페이스를 포함하도록 해당 클래스의 이름을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-237">If you build this code example in Visual Studio, you must change the name of the class to include the namespace when you pass it to the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method.</span></span> <span data-ttu-id="6baac-238">기본적으로 네임스페이스는 프로젝트의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-238">By default, the namespace is the name of the project.</span></span> <span data-ttu-id="6baac-239">예를 들어 프로젝트가 "PartialTrust"이면 클래스 이름은 "PartialTrust.Worker"입니다.</span><span class="sxs-lookup"><span data-stu-id="6baac-239">For example, if the project is "PartialTrust", the class name must be "PartialTrust.Worker".</span></span>

## <a name="see-also"></a><span data-ttu-id="6baac-240">참조</span><span class="sxs-lookup"><span data-stu-id="6baac-240">See also</span></span>

- [<span data-ttu-id="6baac-241">리플렉션 내보내기의 보안 문제점</span><span class="sxs-lookup"><span data-stu-id="6baac-241">Security Issues in Reflection Emit</span></span>](security-issues-in-reflection-emit.md)
- [<span data-ttu-id="6baac-242">방법: 샌드박스에서 부분적으로 신뢰할 수 있는 코드 실행</span><span class="sxs-lookup"><span data-stu-id="6baac-242">How to: Run Partially Trusted Code in a Sandbox</span></span>](../misc/how-to-run-partially-trusted-code-in-a-sandbox.md)
