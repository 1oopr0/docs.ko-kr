---
title: 그래픽 렌더링 개요
description: 모든 개체가 Windows Presentation Foundation (WPF)에서 파생 되는 기본 그래픽 렌더링 클래스의 역할에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- graphics [WPF], rendering
- rendering graphics [WPF]
ms.assetid: 6dec9657-4d8c-4e46-8c54-40fb80008265
ms.openlocfilehash: 96a7ea999f27e89dc22c10329214de7e3fa60341
ms.sourcegitcommit: b6a1869f97a37f11a68c90afde1a520a6887dcbc
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/02/2020
ms.locfileid: "85853630"
---
# <a name="wpf-graphics-rendering-overview"></a><span data-ttu-id="4431e-103">WPF 그래픽 렌더링 개요</span><span class="sxs-lookup"><span data-stu-id="4431e-103">WPF Graphics Rendering Overview</span></span>
<span data-ttu-id="4431e-104">이 항목에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 시각적 계층에 대해 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-104">This topic provides an overview of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual layer.</span></span> <span data-ttu-id="4431e-105"><xref:System.Windows.Media.Visual>모델에서 렌더링을 지원 하기 위해 클래스의 역할에 중점을 둔 것 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-105">It focuses on the role of the <xref:System.Windows.Media.Visual> class for rendering support in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model.</span></span>  

<a name="role_of_visual_object"></a>
## <a name="role-of-the-visual-object"></a><span data-ttu-id="4431e-106">시각적 개체의 역할</span><span class="sxs-lookup"><span data-stu-id="4431e-106">Role of the Visual Object</span></span>  
 <span data-ttu-id="4431e-107"><xref:System.Windows.Media.Visual>클래스는 모든 개체가 파생 되는 기본 추상화입니다 <xref:System.Windows.FrameworkElement> .</span><span class="sxs-lookup"><span data-stu-id="4431e-107">The <xref:System.Windows.Media.Visual> class is the basic abstraction from which every <xref:System.Windows.FrameworkElement> object derives.</span></span> <span data-ttu-id="4431e-108">또한 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 새 컨트롤을 작성하기 위한 진입점으로도 사용되며, Win32 애플리케이션 모델에서는 여러 가지 측면에서 창 핸들(HWND)로도 간주될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-108">It also serves as the entry point for writing new controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], and in many ways can be thought of as the window handle (HWND) in the Win32 application model.</span></span>  
  
 <span data-ttu-id="4431e-109"><xref:System.Windows.Media.Visual>개체는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 기본 역할이 렌더링 지원을 제공 하는 핵심 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-109">The <xref:System.Windows.Media.Visual> object is a core [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] object, whose primary role is to provide rendering support.</span></span> <span data-ttu-id="4431e-110">및와 같은 사용자 인터페이스 컨트롤 <xref:System.Windows.Controls.Button> <xref:System.Windows.Controls.TextBox> 은 클래스에서 파생 되 <xref:System.Windows.Media.Visual> 고 렌더링 데이터를 유지 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-110">User interface controls, such as <xref:System.Windows.Controls.Button> and <xref:System.Windows.Controls.TextBox>, derive from the <xref:System.Windows.Media.Visual> class, and use it for persisting their rendering data.</span></span> <span data-ttu-id="4431e-111"><xref:System.Windows.Media.Visual>개체는 다음에 대 한 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-111">The <xref:System.Windows.Media.Visual> object provides support for:</span></span>  
  
- <span data-ttu-id="4431e-112">출력 표시: 시각적 개체의 serialize된 지속형 그리기 콘텐츠 렌더링</span><span class="sxs-lookup"><span data-stu-id="4431e-112">Output display: Rendering the persisted, serialized drawing content of a visual.</span></span>  
  
- <span data-ttu-id="4431e-113">변환: 시각적 개체에 대해 변환 수행</span><span class="sxs-lookup"><span data-stu-id="4431e-113">Transformations: Performing transformations on a visual.</span></span>  
  
- <span data-ttu-id="4431e-114">클리핑: 시각적 개체에 대해 클리핑 영역 지원 제공</span><span class="sxs-lookup"><span data-stu-id="4431e-114">Clipping: Providing clipping region support for a visual.</span></span>  
  
- <span data-ttu-id="4431e-115">적중 테스트: 좌표 또는 기하 도형이 시각적 개체의 범위 내에 포함되어 있는지 여부 확인</span><span class="sxs-lookup"><span data-stu-id="4431e-115">Hit testing: Determining whether a coordinate or geometry is contained within the bounds of a visual.</span></span>  
  
- <span data-ttu-id="4431e-116">경계 상자 계산: 시각적 개체의 경계 사각형 결정</span><span class="sxs-lookup"><span data-stu-id="4431e-116">Bounding box calculations: Determining the bounding rectangle of a visual.</span></span>  
  
 <span data-ttu-id="4431e-117">그러나 개체에는 <xref:System.Windows.Media.Visual> 다음과 같은 비 렌더링 기능에 대 한 지원이 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-117">However, the <xref:System.Windows.Media.Visual> object does not include support for non-rendering features, such as:</span></span>  
  
- <span data-ttu-id="4431e-118">이벤트 처리</span><span class="sxs-lookup"><span data-stu-id="4431e-118">Event handling</span></span>  
  
- <span data-ttu-id="4431e-119">Layout</span><span class="sxs-lookup"><span data-stu-id="4431e-119">Layout</span></span>  
  
- <span data-ttu-id="4431e-120">스타일</span><span class="sxs-lookup"><span data-stu-id="4431e-120">Styles</span></span>  
  
- <span data-ttu-id="4431e-121">데이터 바인딩</span><span class="sxs-lookup"><span data-stu-id="4431e-121">Data binding</span></span>  
  
- <span data-ttu-id="4431e-122">전역화</span><span class="sxs-lookup"><span data-stu-id="4431e-122">Globalization</span></span>  
  
 <span data-ttu-id="4431e-123"><xref:System.Windows.Media.Visual>는 자식 클래스가 파생 되어야 하는 공용 추상 클래스로 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-123"><xref:System.Windows.Media.Visual> is exposed as a public abstract class from which child classes must be derived.</span></span> <span data-ttu-id="4431e-124">다음 그림에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 노출되는 시각적 개체의 계층 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-124">The following illustration shows the hierarchy of the visual objects that are exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 ![시각적 개체에서 파생된 클래스의 다이어그램](./media/wpf-graphics-rendering-overview/classes-derived-visual-object.png)
  
### <a name="drawingvisual-class"></a><span data-ttu-id="4431e-126">DrawingVisual 클래스</span><span class="sxs-lookup"><span data-stu-id="4431e-126">DrawingVisual Class</span></span>  
 <span data-ttu-id="4431e-127">는 <xref:System.Windows.Media.DrawingVisual> 도형, 이미지 또는 텍스트를 렌더링 하는 데 사용 되는 간단한 그리기 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-127">The <xref:System.Windows.Media.DrawingVisual> is a lightweight drawing class that is used to render shapes, images, or text.</span></span> <span data-ttu-id="4431e-128">이 클래스는 런타임 성능을 향상시키는 레이아웃이나 이벤트 처리를 제공하지 않으므로 간단한 클래스로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-128">This class is considered lightweight because it does not provide layout or event handling, which improves its runtime performance.</span></span> <span data-ttu-id="4431e-129">이러한 이유 때문에 그리기는 배경 및 클립 아트에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-129">For this reason, drawings are ideal for backgrounds and clip art.</span></span> <span data-ttu-id="4431e-130">를 <xref:System.Windows.Media.DrawingVisual> 사용 하 여 사용자 지정 시각적 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-130">The <xref:System.Windows.Media.DrawingVisual> can be used to create a custom visual object.</span></span> <span data-ttu-id="4431e-131">자세한 내용은 [DrawingVisual 개체 사용](using-drawingvisual-objects.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-131">For more information, see [Using DrawingVisual Objects](using-drawingvisual-objects.md).</span></span>  
  
### <a name="viewport3dvisual-class"></a><span data-ttu-id="4431e-132">Viewport3DVisual 클래스</span><span class="sxs-lookup"><span data-stu-id="4431e-132">Viewport3DVisual Class</span></span>  
 <span data-ttu-id="4431e-133">는 <xref:System.Windows.Media.Media3D.Viewport3DVisual> 2 차원 및 개체 간의 브리지를 제공 합니다 <xref:System.Windows.Media.Visual> <xref:System.Windows.Media.Media3D.Visual3D> .</span><span class="sxs-lookup"><span data-stu-id="4431e-133">The <xref:System.Windows.Media.Media3D.Viewport3DVisual> provides a bridge between 2D <xref:System.Windows.Media.Visual> and <xref:System.Windows.Media.Media3D.Visual3D> objects.</span></span> <span data-ttu-id="4431e-134"><xref:System.Windows.Media.Media3D.Visual3D>클래스는 모든 3d 시각적 요소의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-134">The <xref:System.Windows.Media.Media3D.Visual3D> class is the base class for all 3D visual elements.</span></span> <span data-ttu-id="4431e-135">에서는 <xref:System.Windows.Media.Media3D.Viewport3DVisual> 값과 값을 정의 해야 합니다 <xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A> <xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A> .</span><span class="sxs-lookup"><span data-stu-id="4431e-135">The <xref:System.Windows.Media.Media3D.Viewport3DVisual> requires that you define a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A> value and a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A> value.</span></span> <span data-ttu-id="4431e-136">카메라를 사용하면 장면을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-136">The camera allows you to view the scene.</span></span> <span data-ttu-id="4431e-137">뷰포트는 프로젝션이 2D 표면에 매핑되는 위치를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-137">The viewport establishes where the projection maps onto the 2D surface.</span></span> <span data-ttu-id="4431e-138">의 3D에 대 한 자세한 내용은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [3D 그래픽 개요](3-d-graphics-overview.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-138">For more information on 3D in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [3D Graphics Overview](3-d-graphics-overview.md).</span></span>  
  
### <a name="containervisual-class"></a><span data-ttu-id="4431e-139">ContainerVisual 클래스</span><span class="sxs-lookup"><span data-stu-id="4431e-139">ContainerVisual Class</span></span>  
 <span data-ttu-id="4431e-140"><xref:System.Windows.Media.ContainerVisual>클래스는 개체의 컬렉션에 대 한 컨테이너로 사용 됩니다 <xref:System.Windows.Media.Visual> .</span><span class="sxs-lookup"><span data-stu-id="4431e-140">The <xref:System.Windows.Media.ContainerVisual> class is used as a container for a collection of <xref:System.Windows.Media.Visual> objects.</span></span> <span data-ttu-id="4431e-141"><xref:System.Windows.Media.DrawingVisual>클래스는 클래스에서 파생 되므로 <xref:System.Windows.Media.ContainerVisual> 시각적 개체의 컬렉션을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-141">The <xref:System.Windows.Media.DrawingVisual> class derives from the <xref:System.Windows.Media.ContainerVisual> class, allowing it to contain a collection of visual objects.</span></span>  
  
### <a name="drawing-content-in-visual-objects"></a><span data-ttu-id="4431e-142">시각적 개체의 그리기 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="4431e-142">Drawing Content in Visual Objects</span></span>  
 <span data-ttu-id="4431e-143"><xref:System.Windows.Media.Visual>개체는 해당 렌더링 데이터를 **벡터 그래픽 명령 목록**으로 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-143">A <xref:System.Windows.Media.Visual> object stores its render data as a **vector graphics instruction list**.</span></span> <span data-ttu-id="4431e-144">명령 목록의 각 항목은 그래픽 데이터 및 연결된 리소스의 하위 수준 집합을 serialize된 형식으로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-144">Each item in the instruction list represents a low-level set of graphics data and associated resources in a serialized format.</span></span> <span data-ttu-id="4431e-145">그리기 콘텐츠를 포함할 수 있는 렌더링 데이터 형식에는 네 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-145">There are four different types of render data that can contain drawing content.</span></span>  
  
|<span data-ttu-id="4431e-146">그리기 콘텐츠 형식</span><span class="sxs-lookup"><span data-stu-id="4431e-146">Drawing content type</span></span>|<span data-ttu-id="4431e-147">설명</span><span class="sxs-lookup"><span data-stu-id="4431e-147">Description</span></span>|  
|--------------------------|-----------------|  
|<span data-ttu-id="4431e-148">벡터 그래픽</span><span class="sxs-lookup"><span data-stu-id="4431e-148">Vector graphics</span></span>|<span data-ttu-id="4431e-149">벡터 그래픽 데이터와 관련 된 모든 <xref:System.Windows.Media.Brush> 및 정보를 나타냅니다 <xref:System.Windows.Media.Pen> .</span><span class="sxs-lookup"><span data-stu-id="4431e-149">Represents vector graphics data, and any associated <xref:System.Windows.Media.Brush> and <xref:System.Windows.Media.Pen> information.</span></span>|  
|<span data-ttu-id="4431e-150">이미지</span><span class="sxs-lookup"><span data-stu-id="4431e-150">Image</span></span>|<span data-ttu-id="4431e-151">로 정의 된 영역 내의 이미지를 나타냅니다 <xref:System.Windows.Rect> .</span><span class="sxs-lookup"><span data-stu-id="4431e-151">Represents an image within a region defined by a <xref:System.Windows.Rect>.</span></span>|  
|<span data-ttu-id="4431e-152">문자 모양</span><span class="sxs-lookup"><span data-stu-id="4431e-152">Glyph</span></span>|<span data-ttu-id="4431e-153"><xref:System.Windows.Media.GlyphRun>지정 된 글꼴 리소스에서 문자 모양의 시퀀스인를 렌더링 하는 그리기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-153">Represents a drawing that renders a <xref:System.Windows.Media.GlyphRun>, which is a sequence of glyphs from a specified font resource.</span></span> <span data-ttu-id="4431e-154">이 방식에 따라 텍스트가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-154">This is how text is represented.</span></span>|  
|<span data-ttu-id="4431e-155">동영상</span><span class="sxs-lookup"><span data-stu-id="4431e-155">Video</span></span>|<span data-ttu-id="4431e-156">비디오를 렌더링하는 그리기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-156">Represents a drawing that renders video.</span></span>|  
  
 <span data-ttu-id="4431e-157">를 <xref:System.Windows.Media.DrawingContext> 사용 하면를 시각적 콘텐츠로 채울 수 있습니다 <xref:System.Windows.Media.Visual> .</span><span class="sxs-lookup"><span data-stu-id="4431e-157">The <xref:System.Windows.Media.DrawingContext> allows you to populate a <xref:System.Windows.Media.Visual> with visual content.</span></span> <span data-ttu-id="4431e-158"><xref:System.Windows.Media.DrawingContext>개체의 그리기 명령을 사용 하는 경우에는 나중에 그래픽 시스템에서 사용할 수 있도록 렌더링 데이터 집합을 저장 하는 것입니다. 화면에 실시간으로 그리지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-158">When you use a <xref:System.Windows.Media.DrawingContext> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time.</span></span>  
  
 <span data-ttu-id="4431e-159">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]와 같은 컨트롤을 만들 때 <xref:System.Windows.Controls.Button> 컨트롤은 자체적으로 그리기 위해 렌더링 데이터를 암시적으로 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-159">When you create a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, such as a <xref:System.Windows.Controls.Button>, the control implicitly generates render data for drawing itself.</span></span> <span data-ttu-id="4431e-160">예를 들어 <xref:System.Windows.Controls.ContentControl.Content%2A> 의 속성을 설정 하면 <xref:System.Windows.Controls.Button> 컨트롤에서 문자 모양의 렌더링 표현을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-160">For example, setting the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the <xref:System.Windows.Controls.Button> causes the control to store a rendering representation of a glyph.</span></span>  
  
 <span data-ttu-id="4431e-161">는 <xref:System.Windows.Media.Visual> 해당 콘텐츠 <xref:System.Windows.Media.Drawing> 를 내에 포함 된 하나 이상의 개체로 설명 합니다 <xref:System.Windows.Media.DrawingGroup> .</span><span class="sxs-lookup"><span data-stu-id="4431e-161">A <xref:System.Windows.Media.Visual> describes its content as one or more <xref:System.Windows.Media.Drawing> objects contained within a <xref:System.Windows.Media.DrawingGroup>.</span></span> <span data-ttu-id="4431e-162"><xref:System.Windows.Media.DrawingGroup>또한는 불투명 마스크, 변환, 비트맵 효과 및 해당 내용에 적용 되는 기타 작업을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-162">A <xref:System.Windows.Media.DrawingGroup> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents.</span></span> <span data-ttu-id="4431e-163"><xref:System.Windows.Media.DrawingGroup>콘텐츠를 렌더링할 때 작업은,,,, <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A> <xref:System.Windows.Media.DrawingGroup.Opacity%2A> <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A> <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A> <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A> 및 <xref:System.Windows.Media.DrawingGroup.Transform%2A> 순서로 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-163"><xref:System.Windows.Media.DrawingGroup> operations are applied in the following order when content is rendered: <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A>, <xref:System.Windows.Media.DrawingGroup.Opacity%2A>, <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A>, <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A>, <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A>, and then <xref:System.Windows.Media.DrawingGroup.Transform%2A>.</span></span>  
  
 <span data-ttu-id="4431e-164">다음 그림에서는 <xref:System.Windows.Media.DrawingGroup> 렌더링 시퀀스 중에 연산이 적용 되는 순서를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-164">The following illustration shows the order in which <xref:System.Windows.Media.DrawingGroup> operations are applied during the rendering sequence.</span></span>  
  
 <span data-ttu-id="4431e-165">![DrawingGroup 작업의 순서](./media/graphcismm-drawinggroup-order.png "graphcismm_drawinggroup_order")</span><span class="sxs-lookup"><span data-stu-id="4431e-165">![DrawingGroup order of operations](./media/graphcismm-drawinggroup-order.png "graphcismm_drawinggroup_order")</span></span>  
<span data-ttu-id="4431e-166">DrawingGroup 작업의 순서</span><span class="sxs-lookup"><span data-stu-id="4431e-166">Order of DrawingGroup operations</span></span>  
  
 <span data-ttu-id="4431e-167">자세한 내용은 [그리기 개체 개요](drawing-objects-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-167">For more information, see [Drawing Objects Overview](drawing-objects-overview.md).</span></span>  
  
#### <a name="drawing-content-at-the-visual-layer"></a><span data-ttu-id="4431e-168">시각적 계층에서 그리기 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="4431e-168">Drawing Content at the Visual Layer</span></span>  
 <span data-ttu-id="4431e-169">는 직접 인스턴스화할 수 없습니다 <xref:System.Windows.Media.DrawingContext> . 그러나 및와 같은 특정 메서드에서 드로잉 컨텍스트를 가져올 수 있습니다 <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4431e-169">You never directly instantiate a <xref:System.Windows.Media.DrawingContext>; you can, however, acquire a drawing context from certain methods, such as <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> and <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4431e-170">다음 예제에서는에서를 검색 하 <xref:System.Windows.Media.DrawingContext> <xref:System.Windows.Media.DrawingVisual> 고이를 사용 하 여 사각형을 그립니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-170">The following example retrieves a <xref:System.Windows.Media.DrawingContext> from a <xref:System.Windows.Media.DrawingVisual> and uses it to draw a rectangle.</span></span>  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
#### <a name="enumerating-drawing-content-at-the-visual-layer"></a><span data-ttu-id="4431e-171">시각적 계층에서 그리기 콘텐츠 열거</span><span class="sxs-lookup"><span data-stu-id="4431e-171">Enumerating Drawing Content at the Visual Layer</span></span>  
 <span data-ttu-id="4431e-172">개체는 다른 용도 외에 <xref:System.Windows.Media.Drawing> 도의 콘텐츠를 열거 하는 개체 모델을 제공 <xref:System.Windows.Media.Visual> 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-172">In addition to their other uses, <xref:System.Windows.Media.Drawing> objects also provide an object model for enumerating the contents of a <xref:System.Windows.Media.Visual>.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4431e-173">시각적 개체의 콘텐츠를 열거 하는 경우 개체를 검색 하 <xref:System.Windows.Media.Drawing> 고 렌더링 데이터의 기본 표현이 벡터 그래픽 명령 목록으로 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-173">When you are enumerating the contents of the visual, you are retrieving <xref:System.Windows.Media.Drawing> objects, and not the underlying representation of the render data as a vector graphics instruction list.</span></span>  
  
 <span data-ttu-id="4431e-174">다음 예제에서는 메서드를 사용 하 여 <xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A> 의 값을 검색 하 <xref:System.Windows.Media.DrawingGroup> <xref:System.Windows.Media.Visual> 고이를 열거 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-174">The following example uses the <xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A> method to retrieve the <xref:System.Windows.Media.DrawingGroup> value of a <xref:System.Windows.Media.Visual> and enumerate it.</span></span>  
  
 [!code-csharp[DrawingMiscSnippets_snip#GraphicsMMRetrieveDrawings](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingMiscSnippets_snip/CSharp/EnumerateDrawingsExample.xaml.cs#graphicsmmretrievedrawings)]  
  
<a name="how_visual_objects_are_used_to_build_controls"></a>
## <a name="how-visual-objects-are-used-to-build-controls"></a><span data-ttu-id="4431e-175">컨트롤 빌드에 시각적 개체를 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="4431e-175">How Visual Objects are Used to Build Controls</span></span>  
 <span data-ttu-id="4431e-176">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 많은 개체는 다른 시각적 개체로 구성됩니다. 즉, 다양한 하위 개체 계층 구조를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-176">Many of the objects in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects.</span></span> <span data-ttu-id="4431e-177">컨트롤과 같은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 많은 사용자 인터페이스 요소는 여러 다른 형식의 렌더링 요소를 나타내는 다양한 시각적 개체로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-177">Many of the user interface elements in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], such as controls, are composed of multiple visual objects, representing different types of rendering elements.</span></span> <span data-ttu-id="4431e-178">예를 <xref:System.Windows.Controls.Button> 들어 컨트롤에는, 및를 포함 한 여러 다른 개체가 포함 될 수 있습니다 <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> <xref:System.Windows.Controls.ContentPresenter> <xref:System.Windows.Controls.TextBlock> .</span><span class="sxs-lookup"><span data-stu-id="4431e-178">For example, the <xref:System.Windows.Controls.Button> control can contain a number of other objects, including <xref:Microsoft.Windows.Themes.ClassicBorderDecorator>, <xref:System.Windows.Controls.ContentPresenter>, and <xref:System.Windows.Controls.TextBlock>.</span></span>  
  
 <span data-ttu-id="4431e-179">다음 코드에서는 <xref:System.Windows.Controls.Button> 태그에 정의 된 컨트롤을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-179">The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet1)]  
  
 <span data-ttu-id="4431e-180">기본 컨트롤을 구성 하는 시각적 개체를 열거 하는 경우 <xref:System.Windows.Controls.Button> 아래에 표시 된 시각적 개체의 계층 구조를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-180">If you were to enumerate the visual objects that comprise the default <xref:System.Windows.Controls.Button> control, you would find the hierarchy of visual objects illustrated below:</span></span>  
  
 ![시각적 트리 계층 구조의 다이어그램](./media/wpf-graphics-rendering-overview/visual-object-diagram.gif)
  
 <span data-ttu-id="4431e-182">컨트롤에는 요소가 포함 되어 있습니다 .이 요소에는 <xref:System.Windows.Controls.Button> <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> 요소가 포함 되어 있습니다 <xref:System.Windows.Controls.ContentPresenter> .</span><span class="sxs-lookup"><span data-stu-id="4431e-182">The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="4431e-183">요소는의 <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> 테두리와 배경을 그리는 역할을 담당 합니다 <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="4431e-183">The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing a border and a background for the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="4431e-184"><xref:System.Windows.Controls.ContentPresenter>요소는의 내용을 표시 합니다 <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="4431e-184">The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="4431e-185">이 경우 텍스트를 표시 하기 때문에 <xref:System.Windows.Controls.ContentPresenter> 요소는 요소를 포함 합니다 <xref:System.Windows.Controls.TextBlock> .</span><span class="sxs-lookup"><span data-stu-id="4431e-185">In this case, since you are displaying text, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.TextBlock> element.</span></span> <span data-ttu-id="4431e-186"><xref:System.Windows.Controls.Button>컨트롤은를 사용 하 여 <xref:System.Windows.Controls.ContentPresenter> 와 같은 또는 기 하 도형 등의 다른 요소로 콘텐츠를 나타낼 수 있음을 의미 합니다 <xref:System.Windows.Controls.Image> <xref:System.Windows.Media.EllipseGeometry> .</span><span class="sxs-lookup"><span data-stu-id="4431e-186">The fact that the <xref:System.Windows.Controls.Button> control uses a <xref:System.Windows.Controls.ContentPresenter> means that the content could be represented by other elements, such as an <xref:System.Windows.Controls.Image> or a geometry, such as an <xref:System.Windows.Media.EllipseGeometry>.</span></span>  
  
### <a name="control-templates"></a><span data-ttu-id="4431e-187">컨트롤 템플릿</span><span class="sxs-lookup"><span data-stu-id="4431e-187">Control Templates</span></span>  
 <span data-ttu-id="4431e-188">컨트롤을 컨트롤의 계층으로 확장 하는 것은 <xref:System.Windows.Controls.ControlTemplate> 입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-188">The key to the expansion of a control into a hierarchy of controls is the <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="4431e-189">컨트롤 템플릿은 컨트롤에 대한 기본 시각적 개체 계층 구조를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-189">A control template specifies the default visual hierarchy for a control.</span></span> <span data-ttu-id="4431e-190">컨트롤을 명시적으로 참조할 때는 해당 시각적 개체 계층 구조를 암시적으로 참조하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-190">When you explicitly reference a control, you implicitly reference its visual hierarchy.</span></span> <span data-ttu-id="4431e-191">컨트롤 템플릿에 대한 기본값을 재정의하여 컨트롤의 사용자 지정된 시각적 모양을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-191">You can override the default values for a control template to create a customized visual appearance for a control.</span></span> <span data-ttu-id="4431e-192">예를 들어 <xref:System.Windows.Controls.Button> 단색 값 대신 선형 그라데이션 색 값을 사용 하도록 컨트롤의 배경색 값을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-192">For example, you could modify the background color value of the <xref:System.Windows.Controls.Button> control so that it uses a linear gradient color value instead of a solid color value.</span></span> <span data-ttu-id="4431e-193">자세한 내용은 [단추 스타일 및 템플릿](../controls/button-styles-and-templates.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-193">For more information, see [Button Styles and Templates](../controls/button-styles-and-templates.md).</span></span>  
  
 <span data-ttu-id="4431e-194">컨트롤과 같은 사용자 인터페이스 요소에는 <xref:System.Windows.Controls.Button> 컨트롤의 전체 렌더링 정의를 설명 하는 여러 벡터 그래픽 명령 목록이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-194">A user interface element, such as a <xref:System.Windows.Controls.Button> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control.</span></span> <span data-ttu-id="4431e-195">다음 코드에서는 <xref:System.Windows.Controls.Button> 태그에 정의 된 컨트롤을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-195">The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet2)]  
  
 <span data-ttu-id="4431e-196">컨트롤을 구성 하는 시각적 개체 및 벡터 그래픽 명령 목록을 열거 하는 경우 <xref:System.Windows.Controls.Button> 아래에 나와 있는 개체의 계층 구조를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-196">If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <xref:System.Windows.Controls.Button> control, you would find the hierarchy of objects illustrated below:</span></span>  
  
 ![시각적 트리 및 렌더링 데이터의 다이어그램](./media/wpf-graphics-rendering-overview/visual-tree-rendering-data.png)  
  
 <span data-ttu-id="4431e-198">컨트롤에는 요소가 포함 되어 있습니다 .이 요소에는 <xref:System.Windows.Controls.Button> <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> 요소가 포함 되어 있습니다 <xref:System.Windows.Controls.ContentPresenter> .</span><span class="sxs-lookup"><span data-stu-id="4431e-198">The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="4431e-199"><xref:Microsoft.Windows.Themes.ClassicBorderDecorator>요소는 단추의 테두리와 배경을 구성 하는 모든 불연속 그래픽 요소를 그리는 작업을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-199">The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button.</span></span> <span data-ttu-id="4431e-200"><xref:System.Windows.Controls.ContentPresenter>요소는의 내용을 표시 합니다 <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="4431e-200">The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="4431e-201">이 경우 이미지를 표시 하기 때문에 요소는 요소를 <xref:System.Windows.Controls.ContentPresenter> 포함 합니다 <xref:System.Windows.Controls.Image> .</span><span class="sxs-lookup"><span data-stu-id="4431e-201">In this case, since you are displaying an image, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.Image> element.</span></span>  
  
 <span data-ttu-id="4431e-202">시각적 개체 및 벡터 그래픽 명령 목록의 계층 구조에 대해 다음과 같은 사항을 명심해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-202">There are a number of points to note about the hierarchy of visual objects and vector graphics instruction lists:</span></span>  
  
- <span data-ttu-id="4431e-203">계층 구조의 순서는 그리기 정보의 렌더링 순서를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-203">The ordering in the hierarchy represents the rendering order of the drawing information.</span></span> <span data-ttu-id="4431e-204">루트 시각적 요소에서 자식 요소는 왼쪽에서 오른쪽, 위쪽에서 아래쪽으로 트래버스됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-204">From the root visual element, child elements are traversed, left to right, top to bottom.</span></span> <span data-ttu-id="4431e-205">요소에 시각적 자식 요소가 있으면 요소의 형제 요소보다 먼저 트래버스됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-205">If an element has visual child elements, they are traversed before the element’s siblings.</span></span>  
  
- <span data-ttu-id="4431e-206">계층 구조에 있는 리프가 아닌 노드 요소 (예: <xref:System.Windows.Controls.ContentPresenter> )는 자식 요소를 포함 하는 데 사용 되며 명령 목록을 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-206">Non-leaf node elements in the hierarchy, such as <xref:System.Windows.Controls.ContentPresenter>, are used to contain child elements—they do not contain instruction lists.</span></span>  
  
- <span data-ttu-id="4431e-207">시각적 요소가 벡터 그래픽 명령 목록과 시각적 자식 개체를 모두 포함하는 경우 시각적 자식 개체의 그리기 작업 전에 시각적 부모 요소의 명령 목록이 먼저 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-207">If a visual element contains both a vector graphics instruction list and visual children, the instruction list in the parent visual element is rendered before drawings in any of the visual child objects.</span></span>  
  
- <span data-ttu-id="4431e-208">벡터 그래픽 명령 목록에 있는 항목은 왼쪽에서 오른쪽으로 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-208">The items in the vector graphics instruction list are rendered left to right.</span></span>  
  
<a name="visual_tree"></a>
## <a name="visual-tree"></a><span data-ttu-id="4431e-209">표시 트리</span><span class="sxs-lookup"><span data-stu-id="4431e-209">Visual Tree</span></span>  
 <span data-ttu-id="4431e-210">시각적 트리에는 애플리케이션의 사용자 인터페이스에서 사용되는 모든 시각적 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-210">The visual tree contains all visual elements used in an application's user interface.</span></span> <span data-ttu-id="4431e-211">시각적 요소에는 지속형 그리기 정보가 포함되어 있으므로 시각적 트리를 디스플레이 디바이스에 대한 출력을 작성하는 데 필요한 모든 렌더링 정보를 포함하는 장면 그래프로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-211">Since a visual element contains persisted drawing information, you can think of the visual tree as a scene graph, containing all the rendering information needed to compose the output to the display device.</span></span> <span data-ttu-id="4431e-212">이 트리는 코드 또는 태그를 통해 애플리케이션에서 직접 만든 모든 시각적 요소가 누적된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-212">This tree is the accumulation of all visual elements created directly by the application, whether in code or in markup.</span></span> <span data-ttu-id="4431e-213">또한 시각적 트리는 컨트롤 및 데이터 개체와 같은 요소의 템플릿 확장을 통해 만들어진 모든 시각적 요소도 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-213">The visual tree also contains all visual elements created by the template expansion of elements such as controls and data objects.</span></span>  
  
 <span data-ttu-id="4431e-214">다음 코드에서는 <xref:System.Windows.Controls.StackPanel> 태그에 정의 된 요소를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-214">The following code shows a <xref:System.Windows.Controls.StackPanel> element defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet3)]  
  
 <span data-ttu-id="4431e-215">태그 예제의 요소를 구성 하는 시각적 개체를 열거 하는 경우 <xref:System.Windows.Controls.StackPanel> 아래에 표시 된 시각적 개체의 계층 구조를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-215">If you were to enumerate the visual objects that comprise the <xref:System.Windows.Controls.StackPanel> element in the markup example, you would find the hierarchy of visual objects illustrated below:</span></span>  
  
 ![시각적 트리 계층 구조의 다이어그램](./media/wpf-graphics-rendering-overview/visual-tree-hierarchy.gif)  
  
### <a name="rendering-order"></a><span data-ttu-id="4431e-217">렌더링 순서</span><span class="sxs-lookup"><span data-stu-id="4431e-217">Rendering Order</span></span>  
 <span data-ttu-id="4431e-218">시각적 트리는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 시각적 및 그리기 개체의 렌더링 순서를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-218">The visual tree determines the rendering order of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual and drawing objects.</span></span> <span data-ttu-id="4431e-219">트래버스 순서는 시각적 트리의 최상위 노드를 나타내는 루트 시각적 개체에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-219">The order of traversal starts with the root visual, which is the top-most node in the visual tree.</span></span> <span data-ttu-id="4431e-220">그런 후에 루트 시각적 개체의 자식이 왼쪽에서 오른쪽으로 트래버스됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-220">The root visual’s children are then traversed, left to right.</span></span> <span data-ttu-id="4431e-221">시각적 개체에 자식이 있으면 해당 자식은 시각적 요소의 형제보다 먼저 트래버스됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-221">If a visual has children, its children are traversed before the visual’s siblings.</span></span> <span data-ttu-id="4431e-222">즉, 시각적 자식 개체의 콘텐츠는 시각적 개체 자체의 콘텐츠보다 먼저 렌더링됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-222">This means that the content of a child visual is rendered in front of the visual's own content.</span></span>  
  
 ![시각적 트리 렌더링 순서의 다이어그램](./media/wpf-graphics-rendering-overview/visual-tree-rendering-order.gif)
  
### <a name="root-visual"></a><span data-ttu-id="4431e-224">루트 시각적 개체</span><span class="sxs-lookup"><span data-stu-id="4431e-224">Root Visual</span></span>  
 <span data-ttu-id="4431e-225">**루트 시각적 개체**는 시각적 트리 계층의 최상위 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-225">The **root visual** is the top-most element in a visual tree hierarchy.</span></span> <span data-ttu-id="4431e-226">대부분의 응용 프로그램에서 루트 시각적 개체의 기본 클래스는 <xref:System.Windows.Window> 또는 <xref:System.Windows.Navigation.NavigationWindow> 입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-226">In most applications, the base class of the root visual is either <xref:System.Windows.Window> or <xref:System.Windows.Navigation.NavigationWindow>.</span></span> <span data-ttu-id="4431e-227">그러나 Win32 애플리케이션에서 시각적 개체를 호스트한다면 루트 시각적 개체가 Win32 창에서 호스트한 최상위 시각적 개체가 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-227">However, if you were hosting visual objects in a Win32 application, the root visual would be the top-most visual you were hosting in the Win32 window.</span></span> <span data-ttu-id="4431e-228">자세한 내용은 [자습서: Win32 애플리케이션에서 시각적 개체 호스팅](tutorial-hosting-visual-objects-in-a-win32-application.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-228">For more information, see [Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md).</span></span>  
  
### <a name="relationship-to-the-logical-tree"></a><span data-ttu-id="4431e-229">논리적 트리와의 관계</span><span class="sxs-lookup"><span data-stu-id="4431e-229">Relationship to the Logical Tree</span></span>  
 <span data-ttu-id="4431e-230">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 논리적 트리는 런타임의 애플리케이션 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-230">The logical tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] represents the elements of an application at run time.</span></span> <span data-ttu-id="4431e-231">이 트리를 직접 조작하지는 않지만 애플리케이션의 이 보기는 속성 상속 및 이벤트 라우팅을 이해하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-231">Although you do not manipulate this tree directly, this view of the application is useful for understanding property inheritance and event routing.</span></span> <span data-ttu-id="4431e-232">시각적 트리와 달리 논리적 트리는와 같은 비시각적 데이터 개체를 나타낼 수 있습니다 <xref:System.Windows.Documents.ListItem> .</span><span class="sxs-lookup"><span data-stu-id="4431e-232">Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>.</span></span> <span data-ttu-id="4431e-233">대부분의 경우 논리적 트리는 애플리케이션의 태그 정의에 매우 밀접하게 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-233">In many cases, the logical tree maps very closely to an application's markup definitions.</span></span> <span data-ttu-id="4431e-234">다음 코드에서는 <xref:System.Windows.Controls.DockPanel> 태그에 정의 된 요소를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-234">The following code shows a <xref:System.Windows.Controls.DockPanel> element defined in markup.</span></span>  
  
 [!code-xaml[VisualsOverview#VisualsOverviewSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet5)]  
  
 <span data-ttu-id="4431e-235">태그 예제의 요소를 구성 하는 논리 개체를 열거 하는 경우 <xref:System.Windows.Controls.DockPanel> 아래에 나와 있는 논리 개체의 계층 구조를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-235">If you were to enumerate the logical objects that comprise the <xref:System.Windows.Controls.DockPanel> element in the markup example, you would find the hierarchy of logical objects illustrated below:</span></span>  
  
 <span data-ttu-id="4431e-236">![트리 다이어그램](./media/tree1-wcp.gif "Tree1_wcp")</span><span class="sxs-lookup"><span data-stu-id="4431e-236">![Tree diagram](./media/tree1-wcp.gif "Tree1_wcp")</span></span>  
<span data-ttu-id="4431e-237">논리적 트리 다이어그램</span><span class="sxs-lookup"><span data-stu-id="4431e-237">Diagram of logical tree</span></span>  
  
 <span data-ttu-id="4431e-238">시각적 트리와 논리적 트리 둘 다 현재의 애플리케이션 요소 집합과 동기화되므로 요소의 모든 추가, 삭제 또는 수정이 반영됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-238">Both the visual tree and logical tree are synchronized with the current set of application elements, reflecting any addition, deletion, or modification of elements.</span></span> <span data-ttu-id="4431e-239">그러나 트리는 애플리케이션의 여러 다른 보기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-239">However, the trees present different views of the application.</span></span> <span data-ttu-id="4431e-240">시각적 트리와 달리 논리적 트리는 컨트롤의 요소를 확장 하지 않습니다 <xref:System.Windows.Controls.ContentPresenter> .</span><span class="sxs-lookup"><span data-stu-id="4431e-240">Unlike the visual tree, the logical tree does not expand a control's <xref:System.Windows.Controls.ContentPresenter> element.</span></span> <span data-ttu-id="4431e-241">즉, 동일한 집합에 대한 논리적 트리와 시각적 트리 간에 직접적인 일대일 대응은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-241">This means there is not a direct one-to-one correspondence between a logical tree and a visual tree for the same set of objects.</span></span> <span data-ttu-id="4431e-242">실제로 **LogicalTreeHelper** 개체의 메서드를 호출 하 <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> 고 **VisualTreeHelper** <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> 매개 변수와 동일한 요소를 사용 하 여 VisualTreeHelper 개체의 메서드를 호출 하면 결과가 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-242">In fact, invoking the **LogicalTreeHelper** object's <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method and the **VisualTreeHelper** object's <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method using the same element as a parameter yields differing results.</span></span>  
  
 <span data-ttu-id="4431e-243">논리적 트리에 대한 자세한 내용은 [WPF의 트리](../advanced/trees-in-wpf.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-243">For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).</span></span>  
  
### <a name="viewing-the-visual-tree-with-xamlpad"></a><span data-ttu-id="4431e-244">XamlPad에서 시각적 트리 보기</span><span class="sxs-lookup"><span data-stu-id="4431e-244">Viewing the Visual Tree with XamlPad</span></span>  
 <span data-ttu-id="4431e-245">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XamlPad 도구는 현재 정의 된 XAML 콘텐츠에 해당 하는 시각적 트리를 보고 탐색 하는 옵션을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-245">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined XAML content.</span></span> <span data-ttu-id="4431e-246">메뉴 모음에서 **시각적 트리 표시** 단추를 클릭하여 시각적 트리를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-246">Click the **Show Visual Tree** button on the menu bar to display the visual tree.</span></span> <span data-ttu-id="4431e-247">다음은 XamlPad의 **시각적 트리 탐색기** 패널에서 XAML 콘텐츠를 시각적 트리 노드로 확장 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-247">The following illustrates the expansion of XAML content into visual tree nodes in the **Visual Tree Explorer** panel of XamlPad:</span></span>  
  
 ![XamlPad의 시각적 트리 탐색기 패널](./media/wpf-graphics-rendering-overview/visual-tree-explorer.png)  

 <span data-ttu-id="4431e-249"><xref:System.Windows.Controls.Label>, <xref:System.Windows.Controls.TextBox> 및 <xref:System.Windows.Controls.Button> 컨트롤이 XamlPad의 **시각적 트리 탐색기** 패널에서 개별 시각적 개체 계층 구조를 표시 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-249">Notice how the <xref:System.Windows.Controls.Label>, <xref:System.Windows.Controls.TextBox>, and <xref:System.Windows.Controls.Button> controls each display a separate visual object hierarchy in the **Visual Tree Explorer** panel of XamlPad.</span></span> <span data-ttu-id="4431e-250">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]컨트롤이 <xref:System.Windows.Controls.ControlTemplate> 해당 컨트롤의 시각적 트리를 포함 하는를 포함 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-250">This is because [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have a <xref:System.Windows.Controls.ControlTemplate> that contains the visual tree of that control.</span></span> <span data-ttu-id="4431e-251">컨트롤을 명시적으로 참조할 때는 해당 시각적 개체 계층 구조를 암시적으로 참조하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-251">When you explicitly reference a control, you implicitly reference its visual hierarchy.</span></span>  
  
### <a name="profiling-visual-performance"></a><span data-ttu-id="4431e-252">시각적 성능 프로파일링</span><span class="sxs-lookup"><span data-stu-id="4431e-252">Profiling Visual Performance</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4431e-253">에서는 애플리케이션의 런타임 동작을 분석할 수 있고 적용할 수 있는 성능 최적화 형식을 판별하는 성능 프로파일링 도구 제품군을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-253">provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply.</span></span> <span data-ttu-id="4431e-254">Visual Profiler 도구는 애플리케이션의 시각적 트리에 직접 매핑하여 성능 데이터의 다양한 그래픽 보기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-254">The Visual Profiler tool provides a rich, graphical view of performance data by mapping directly to the application's visual tree.</span></span> <span data-ttu-id="4431e-255">이 스크린 샷에서 Visual Profiler의 **CPU 사용량** 섹션에서는 렌더링 및 레이아웃과 같은 개체의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 서비스 사용을 정확히 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-255">In this screenshot, the **CPU Usage** section of the Visual Profiler gives you a precise breakdown of an object's use of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] services, such as rendering and layout.</span></span>  
  
 <span data-ttu-id="4431e-256">![Visual Profiler 표시 출력](./media/wpfperf-visualprofiler-04.png "WPFPerf_VisualProfiler_04")</span><span class="sxs-lookup"><span data-stu-id="4431e-256">![Visual Profiler display output](./media/wpfperf-visualprofiler-04.png "WPFPerf_VisualProfiler_04")</span></span>  
<span data-ttu-id="4431e-257">Visual Profiler 표시 출력</span><span class="sxs-lookup"><span data-stu-id="4431e-257">Visual Profiler display output</span></span>  
  
<a name="visual_rendering_behavior"></a>
## <a name="visual-rendering-behavior"></a><span data-ttu-id="4431e-258">시각적 개체 렌더링 동작</span><span class="sxs-lookup"><span data-stu-id="4431e-258">Visual Rendering Behavior</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4431e-259">에서는 시각적 개체의 렌더링 동작에 영향을 주는 여러 기능이 도입되었습니다. 여기에는 유지 모드 그래픽, 벡터 그래픽 및 디바이스 독립적 그래픽이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-259">introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics.</span></span>  
  
### <a name="retained-mode-graphics"></a><span data-ttu-id="4431e-260">유지 모드 그래픽</span><span class="sxs-lookup"><span data-stu-id="4431e-260">Retained Mode Graphics</span></span>  
 <span data-ttu-id="4431e-261">시각적 개체의 역할을 이해하기 위해서는 **직접 실행 모드**와 **유지 모드** 그래픽 시스템 간 차이를 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-261">One of the keys to understanding the role of the Visual object is to understand the difference between **immediate mode** and **retained mode** graphics systems.</span></span> <span data-ttu-id="4431e-262">GDI 또는 GDI+를 기준으로 하는 표준 Win32 애플리케이션은 직접 실행 모드 그래픽 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-262">A standard Win32 application based on GDI or GDI+ uses an immediate mode graphics system.</span></span> <span data-ttu-id="4431e-263">즉, 이 애플리케이션은 창의 크기 조정이나 개체의 시각적 모양 변경과 같은 동작으로 인해 무효화되는 클라이언트 영역의 부분을 다시 그립니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-263">This means that the application is responsible for repainting the portion of the client area that is invalidated, due to an action such as a window being resized, or an object changing its visual appearance.</span></span>  
  
 ![Win32 렌더링 시퀀스의 다이어그램](./media/wpf-graphics-rendering-overview/win32-rendering-squence.png)  
  
 <span data-ttu-id="4431e-265">반면, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서는 유지 모드 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-265">In contrast, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a retained mode system.</span></span> <span data-ttu-id="4431e-266">즉, 시각적 모양을 갖는 애플리케이션 개체는 serialize된 그리기 데이터 집합을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-266">This means application objects that have a visual appearance define a set of serialized drawing data.</span></span> <span data-ttu-id="4431e-267">그리기 데이터가 정의되면 시스템은 애플리케이션 개체 렌더링을 위한 모든 다시 그리기 요청에 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-267">Once the drawing data is defined, the system is responsible thereafter for responding to all repaint requests for rendering the application objects.</span></span> <span data-ttu-id="4431e-268">런타임에도 애플리케이션 개체를 수정하거나 만들 수 있으며 그리기 요청에 응답하기 위해 해당 시스템에 의존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-268">Even at run time, you can modify or create application objects, and still rely on the system for responding to paint requests.</span></span> <span data-ttu-id="4431e-269">유지 모드 그래픽 시스템의 강점은 그리기 정보가 항상 애플리케이션에서 serialize된 상태로 지속되지만 렌더링 책임은 시스템에 남아 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-269">The power in a retained mode graphics system is that drawing information is always persisted in a serialized state by the application, but rendering responsibility left to the system.</span></span> <span data-ttu-id="4431e-270">다음 다이어그램에서는 애플리케이션이 그리기 요청에 응답하기 위해 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에 의존하는 방식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-270">The following diagram shows how the application relies on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] for responding to paint requests.</span></span>  
  
 ![WPF 렌더링 시퀀스의 다이어그램](./media/wpf-graphics-rendering-overview/wpf-rendering-sequence.png)  

#### <a name="intelligent-redrawing"></a><span data-ttu-id="4431e-272">지능형 다시 그리기</span><span class="sxs-lookup"><span data-stu-id="4431e-272">Intelligent Redrawing</span></span>  
 <span data-ttu-id="4431e-273">유지 모드 그래픽을 사용할 때는 가장 큰 장점 중 하나는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]가 애플리케이션에서 다시 그려야 하는 항목을 효율적으로 최적화할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-273">One of the biggest benefits in using retained mode graphics is that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can efficiently optimize what needs to be redrawn in the application.</span></span> <span data-ttu-id="4431e-274">다양한 수준의 불투명도를 갖는 복잡한 장면이 있더라도 다시 그리기를 최적화하기 위해 특수한 용도의 코드를 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-274">Even if you have a complex scene with varying levels of opacity, you generally do not need to write special-purpose code to optimize redrawing.</span></span> <span data-ttu-id="4431e-275">이러한 특성을 업데이트 영역의 다시 그리기 작업량을 최소화하여 적은 노력으로 애플리케이션을 최적화할 수 있는 Win32 프로그래밍 작업과 비교해 보세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-275">Compare this with Win32 programming in which you can spend a great deal of effort in optimizing your application by minimizing the amount of redrawing in the update region.</span></span> <span data-ttu-id="4431e-276">Win32 애플리케이션의 다시 그리기 최적화와 관련된 복잡성 형식의 예제를 보려면 [업데이트 영역의 다시 그리기](/windows/desktop/gdi/redrawing-in-the-update-region)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-276">See [Redrawing in the Update Region](/windows/desktop/gdi/redrawing-in-the-update-region) for an example of the type of complexity involved in optimizing redrawing in Win32 applications.</span></span>  
  
### <a name="vector-graphics"></a><span data-ttu-id="4431e-277">벡터 그래픽</span><span class="sxs-lookup"><span data-stu-id="4431e-277">Vector Graphics</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4431e-278">에서는 **벡터 그래픽**을 해당 렌더링 데이터 형식으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-278">uses **vector graphics** as its rendering data format.</span></span> <span data-ttu-id="4431e-279">SVG(Scalable Vector Graphics), Windows 메타파일(.wmf) 및 트루타입 글꼴을 포함하는 벡터 그래픽은 렌더링 데이터를 저장하고 그래픽 기본형을 사용하여 이미지를 다시 만드는 방법을 설명하는 명령 목록으로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-279">Vector graphics—which include Scalable Vector Graphics (SVG), Windows metafiles (.wmf), and TrueType fonts—store rendering data and transmit it as a list of instructions that describe how to recreate an image using graphics primitives.</span></span> <span data-ttu-id="4431e-280">예를 들어 트루타입 글꼴은 픽셀 배열이 아니라, 선, 곡선 및 명령 집합을 설명하는 윤곽선 글꼴입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-280">For example, TrueType fonts are outline fonts that describe a set of lines, curves, and commands, rather than an array of pixels.</span></span> <span data-ttu-id="4431e-281">벡터 그래픽의 주요 이점 중 하나는 어떤 크기 및 해상도로도 조정이 가능하다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-281">One of the key benefits of vector graphics is the ability to scale to any size and resolution.</span></span>  
  
 <span data-ttu-id="4431e-282">벡터 그래픽과 달리, 비트맵 그래픽은 렌더링 데이터를 특정 해상도로 미리 렌더링된 이미지의 픽셀 단위 표현으로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-282">Unlike vector graphics, bitmap graphics store rendering data as a pixel-by-pixel representation of an image, pre-rendered for a specific resolution.</span></span> <span data-ttu-id="4431e-283">비트맵 그래픽과 벡터 그래픽 형식 간의 주요 차이점 중 하나에 원본 소스 이미지에 대한 충실도입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-283">One of the key differences between bitmap and vector graphic formats is fidelity to the original source image.</span></span> <span data-ttu-id="4431e-284">예를 들어 소스 이미지의 크기를 수정한 경우 비트맵 그래픽 시스템은 이미지를 늘이지만 벡터 그래픽 시스템은 이미지의 충실도를 보존하면서 이미지 배율을 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-284">For example, when the size of a source image is modified, bitmap graphics systems stretch the image, whereas vector graphics systems scale the image, preserving the image fidelity.</span></span>  
  
 <span data-ttu-id="4431e-285">다음 그림에서는 300%만큼 크기가 조정된 소스 이미지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-285">The following illustration shows a source image that has been resized by 300%.</span></span> <span data-ttu-id="4431e-286">소스 이미지가 벡터 그래픽 이미지처럼 배율이 조정되지 않고 비트맵 그래픽 이미지처럼 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-286">Notice the distortions that appear when the source image is stretched as a bitmap graphics image rather than scaled as a vector graphics image.</span></span>  
  
 ![래스터 그래픽과 벡터 그래프의 차이](./media/wpf-graphics-rendering-overview/raster-vector-differences.png)  
  
 <span data-ttu-id="4431e-288">다음 태그는 정의 된 두 개의 요소를 보여 줍니다 <xref:System.Windows.Shapes.Path> .</span><span class="sxs-lookup"><span data-stu-id="4431e-288">The following markup shows two <xref:System.Windows.Shapes.Path> elements defined.</span></span> <span data-ttu-id="4431e-289">두 번째 요소는를 사용 하 여 <xref:System.Windows.Media.ScaleTransform> 첫 번째 요소에 대 한 그리기 명령의 크기를 300%로 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-289">The second element uses a <xref:System.Windows.Media.ScaleTransform> to resize the drawing instructions of the first element by 300%.</span></span> <span data-ttu-id="4431e-290">요소의 그리기 명령은 <xref:System.Windows.Shapes.Path> 변경 되지 않은 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-290">Notice that the drawing instructions in the <xref:System.Windows.Shapes.Path> elements remain unchanged.</span></span>  
  
 [!code-xaml[VectorGraphicsSnippets#VectorGraphicsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VectorGraphicsSnippets/CS/PageOne.xaml#vectorgraphicssnippet1)]  
  
### <a name="about-resolution-and-device-independent-graphics"></a><span data-ttu-id="4431e-291">해상도 및 디바이스 독립적인 그래픽 정보</span><span class="sxs-lookup"><span data-stu-id="4431e-291">About Resolution and Device-Independent Graphics</span></span>  
 <span data-ttu-id="4431e-292">화면에서 텍스트 및 그래픽의 크기를 결정하는 두 시스템 요소는 바로 해상도와 DPI입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-292">There are two system factors that determine the size of text and graphics on your screen: resolution and DPI.</span></span> <span data-ttu-id="4431e-293">해상도는 화면에 표시되는 픽셀 수를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-293">Resolution describes the number of pixels that appear on the screen.</span></span> <span data-ttu-id="4431e-294">해상도가 더 높을수록 픽셀은 더 작아지므로 그래픽 및 텍스트가 더 작게 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-294">As the resolution gets higher, pixels get smaller, causing graphics and text to appear smaller.</span></span> <span data-ttu-id="4431e-295">1024 x 768로 설정된 모니터에 표시되는 그래픽은 해상도를 1600 x 1200으로 변경하면 훨씬 더 작게 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-295">A graphic displayed on a monitor set to 1024 x 768 will appear much smaller when the resolution is changed to 1600 x 1200.</span></span>  
  
 <span data-ttu-id="4431e-296">다른 시스템 설정인 DPI는 화면 인치 크기(픽셀)를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-296">The other system setting, DPI, describes the size of a screen inch in pixels.</span></span> <span data-ttu-id="4431e-297">대부분의 Windows 시스템에는 DPI 96가 있습니다. 즉, 화면 인치가 96 픽셀 임을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-297">Most Windows systems have a DPI of 96, which means a screen inch is 96 pixels.</span></span> <span data-ttu-id="4431e-298">DPI 설정을 늘리면 화면 인치가 더 커지고 DPI를 줄이면 화면 인치가 더 작아집니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-298">Increasing the DPI setting makes the screen inch larger; decreasing the DPI makes the screen inch smaller.</span></span> <span data-ttu-id="4431e-299">즉, 화면 인치가 실제 인치와 같지 않음을 의미합니다. 대부분의 시스템에서 같지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-299">This means that a screen inch isn't the same size as a real-world inch; on most systems, it's probably not.</span></span> <span data-ttu-id="4431e-300">DPI를 늘리면 화면 인치 크기도 늘어났을 것이므로 DPI 인식 그래픽 및 텍스트가 더 커집니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-300">As you increase the DPI, DPI-aware graphics and text become larger because you've increased the size of the screen inch.</span></span> <span data-ttu-id="4431e-301">특히 고해상도에서 DPI를 늘리면 텍스트 읽기가 훨씬 더 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-301">Increasing the DPI can make text easier to read, especially at high resolutions.</span></span>  
  
 <span data-ttu-id="4431e-302">모든 애플리케이션이 DPI를 인식하는 것은 아닙니다. 일부에서는 하드웨어 픽셀을 측정의 기본 단위로 사용합니다. 시스템 DPI를 변경해도 이러한 애플리케이션에는 영향이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-302">Not all applications are DPI-aware: some use hardware pixels as the primary unit of measurement; changing the system DPI has no effect on these applications.</span></span> <span data-ttu-id="4431e-303">많은 다른 애플리케이션에서 DPI 인식 단위를 사용하여 글꼴 크기를 설명하지만 다른 요소를 설명할 때는 픽셀을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-303">Many other applications use DPI-aware units to describe font sizes, but use pixels to describe everything else.</span></span> <span data-ttu-id="4431e-304">이러한 애플리케이션의 텍스트는 시스템의 DPI 설정에 따라 확장되지만 UI는 그렇지 않으므로 DPI를 너무 작거나 너무 크게 지정하면 이러한 애플리케이션에서 레이아웃 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-304">Making the DPI too small or too large can cause layout problems for these applications, because the applications' text scales with the system's DPI setting, but the applications' UI does not.</span></span> <span data-ttu-id="4431e-305">이 문제는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]를 사용하여 개발된 애플리케이션에서는 해결되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-305">This problem has been eliminated for applications developed using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4431e-306">에서는 하드웨어 픽셀이 아닌 디바이스 독립적 픽셀을 기본 측정 단위로 사용하여 자동 크기 조정을 지원합니다. 그래픽 및 텍스트는 애플리케이션 개발자의 추가 작업 없이 적절히 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-306">supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer.</span></span> <span data-ttu-id="4431e-307">다음 그림에는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 텍스트와 그래픽이 다른 DPI 설정으로 표시되는 방식의 예가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-307">The following illustration shows an example of how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] text and graphics are appear at different DPI settings.</span></span>  
  
 <span data-ttu-id="4431e-308">![서로 다른 DPI 설정에서의 그래픽과 텍스트](./media/graphicsmm-dpi-setting-examples.png "graphicsmm_dpi_setting_examples")</span><span class="sxs-lookup"><span data-stu-id="4431e-308">![Graphics and text at different DPI settings](./media/graphicsmm-dpi-setting-examples.png "graphicsmm_dpi_setting_examples")</span></span>  
<span data-ttu-id="4431e-309">서로 다른 DPI 설정에서의 그래픽과 텍스트</span><span class="sxs-lookup"><span data-stu-id="4431e-309">Graphics and text at different DPI settings</span></span>  
  
<a name="visualtreehelper_class"></a>
## <a name="visualtreehelper-class"></a><span data-ttu-id="4431e-310">VisualTreeHelper 클래스</span><span class="sxs-lookup"><span data-stu-id="4431e-310">VisualTreeHelper Class</span></span>  
 <span data-ttu-id="4431e-311"><xref:System.Windows.Media.VisualTreeHelper>클래스는 시각적 개체 수준에서 프로그래밍 하는 데 필요한 하위 수준 기능을 제공 하는 정적 도우미 클래스입니다 .이 클래스는 고성능 사용자 지정 컨트롤 개발과 같은 매우 특정 한 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-311">The <xref:System.Windows.Media.VisualTreeHelper> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls.</span></span> <span data-ttu-id="4431e-312">대부분의 경우 및와 같은 상위 수준 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프레임 워크 개체는 <xref:System.Windows.Controls.Canvas> <xref:System.Windows.Controls.TextBlock> 더 많은 유연성과 사용 편의성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-312">In most case, the higher-level [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework objects, such as <xref:System.Windows.Controls.Canvas> and <xref:System.Windows.Controls.TextBlock>, offer greater flexibility and ease of use.</span></span>  
  
### <a name="hit-testing"></a><span data-ttu-id="4431e-313">적중 테스트</span><span class="sxs-lookup"><span data-stu-id="4431e-313">Hit Testing</span></span>  
 <span data-ttu-id="4431e-314"><xref:System.Windows.Media.VisualTreeHelper>클래스는 기본 적중 테스트 지원이 사용자의 요구를 충족 하지 않는 경우 시각적 개체에 대 한 적중 테스트를 위한 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-314">The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs.</span></span> <span data-ttu-id="4431e-315"><xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>클래스의 메서드를 사용 하 여 <xref:System.Windows.Media.VisualTreeHelper> geometry 또는 point 좌표 값이 컨트롤이 나 그래픽 요소와 같은 지정 된 개체의 경계 내에 있는지 여부를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-315">You can use the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> methods in the <xref:System.Windows.Media.VisualTreeHelper> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element.</span></span> <span data-ttu-id="4431e-316">예를 들어 적중 테스트를 사용하여 개체의 경계 사각형 안을 마우스로 클릭할 때 원 기하 도형 내부를 클릭한 것인지 여부를 결정할 수 있습니다. 또한 적중 테스트의 기본 구현을 재정의하여 사용자 고유의 적중 테스트 계산을 사용자 지정하도록 선택할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-316">For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.</span></span>  
  
 <span data-ttu-id="4431e-317">적중 테스트에 대한 자세한 내용은 [시각적 계층에서 테스트 적중](hit-testing-in-the-visual-layer.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-317">For more information on hit testing, see [Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md).</span></span>  
  
### <a name="enumerating-the-visual-tree"></a><span data-ttu-id="4431e-318">시각적 트리 열거</span><span class="sxs-lookup"><span data-stu-id="4431e-318">Enumerating the Visual Tree</span></span>  
 <span data-ttu-id="4431e-319"><xref:System.Windows.Media.VisualTreeHelper>클래스는 시각적 트리의 멤버를 열거 하는 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-319">The <xref:System.Windows.Media.VisualTreeHelper> class provides functionality for enumerating the members of a visual tree.</span></span> <span data-ttu-id="4431e-320">부모를 검색 하려면 메서드를 호출 <xref:System.Windows.Media.VisualTreeHelper.GetParent%2A> 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-320">To retrieve a parent, call the <xref:System.Windows.Media.VisualTreeHelper.GetParent%2A> method.</span></span> <span data-ttu-id="4431e-321">시각적 개체의 자식 또는 직계 하위 항목을 검색 하려면 메서드를 호출 <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-321">To retrieve a child, or direct descendant, of a visual object, call the <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method.</span></span> <span data-ttu-id="4431e-322">이 메서드는 지정 된 <xref:System.Windows.Media.Visual> 인덱스에 있는 부모의 자식을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-322">This method returns a child <xref:System.Windows.Media.Visual> of the parent at the specified index.</span></span>  
  
 <span data-ttu-id="4431e-323">다음 예제에서는 시각적 개체의 모든 하위 항목을 열거하는 방법을 보여 줍니다. 이 방법은 시각적 개체 계층 구조의 모든 렌더링 정보를 serialize하려는 경우에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-323">The following example shows how to enumerate all the descendants of a visual object, which is a technique you might want to use if you were interested in serializing all the rendering information of a visual object hierarchy.</span></span>  
  
 [!code-csharp[VisualsOverview#101](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#101)]
 [!code-vb[VisualsOverview#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#101)]  
  
 <span data-ttu-id="4431e-324">대부분의 경우에서 논리적 트리는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션의 요소를 좀 더 유용하게 나타낸 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-324">In most cases, the logical tree is a more useful representation of the elements in a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.</span></span> <span data-ttu-id="4431e-325">논리적 트리를 직접 수정하지는 않지만 애플리케이션의 이 보기는 속성 상속 및 이벤트 라우팅을 이해하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-325">Although you do not modify the logical tree directly, this view of the application is useful for understanding property inheritance and event routing.</span></span> <span data-ttu-id="4431e-326">시각적 트리와 달리 논리적 트리는와 같은 비시각적 데이터 개체를 나타낼 수 있습니다 <xref:System.Windows.Documents.ListItem> .</span><span class="sxs-lookup"><span data-stu-id="4431e-326">Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>.</span></span> <span data-ttu-id="4431e-327">논리적 트리에 대한 자세한 내용은 [WPF의 트리](../advanced/trees-in-wpf.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4431e-327">For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="4431e-328"><xref:System.Windows.Media.VisualTreeHelper>클래스는 시각적 개체의 경계 사각형을 반환 하는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-328">The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for returning the bounding rectangle of visual objects.</span></span> <span data-ttu-id="4431e-329">을 호출 하 여 시각적 개체의 경계 사각형을 반환할 수 있습니다 <xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A> .</span><span class="sxs-lookup"><span data-stu-id="4431e-329">You can return the bounding rectangle of a visual object by calling <xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A>.</span></span> <span data-ttu-id="4431e-330">을 호출 하 여 시각적 개체 자체를 포함 하 여 시각적 개체의 모든 하위 항목에 대 한 경계 사각형을 반환할 수 있습니다 <xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A> .</span><span class="sxs-lookup"><span data-stu-id="4431e-330">You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A>.</span></span> <span data-ttu-id="4431e-331">다음 코드에서는 시각적 개체 및 모든 하위 개체의 경계 사각형을 계산하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4431e-331">The following code shows how you would calculate the bounding rectangle of a visual object and all its descendants.</span></span>  
  
 [!code-csharp[VisualsOverview#102](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#102)]
 [!code-vb[VisualsOverview#102](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#102)]  
  
## <a name="see-also"></a><span data-ttu-id="4431e-332">참조</span><span class="sxs-lookup"><span data-stu-id="4431e-332">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.Media.VisualTreeHelper>
- <xref:System.Windows.Media.DrawingVisual>
- [<span data-ttu-id="4431e-333">2D 그래픽 및 이미징</span><span class="sxs-lookup"><span data-stu-id="4431e-333">2D Graphics and Imaging</span></span>](../advanced/optimizing-performance-2d-graphics-and-imaging.md)
- [<span data-ttu-id="4431e-334">시각적 계층에서 적중 테스트</span><span class="sxs-lookup"><span data-stu-id="4431e-334">Hit Testing in the Visual Layer</span></span>](hit-testing-in-the-visual-layer.md)
- [<span data-ttu-id="4431e-335">DrawingVisual 개체 사용</span><span class="sxs-lookup"><span data-stu-id="4431e-335">Using DrawingVisual Objects</span></span>](using-drawingvisual-objects.md)
- [<span data-ttu-id="4431e-336">자습서: Win32 애플리케이션에서 시각적 개체 호스팅</span><span class="sxs-lookup"><span data-stu-id="4431e-336">Tutorial: Hosting Visual Objects in a Win32 Application</span></span>](tutorial-hosting-visual-objects-in-a-win32-application.md)
- [<span data-ttu-id="4431e-337">WPF 애플리케이션 성능 최적화</span><span class="sxs-lookup"><span data-stu-id="4431e-337">Optimizing WPF Application Performance</span></span>](../advanced/optimizing-wpf-application-performance.md)
