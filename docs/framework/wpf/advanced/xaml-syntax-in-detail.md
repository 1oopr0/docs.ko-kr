---
title: XAML 구문 정보
description: Windows Presentation Foundation 및 XAML을 사용 하는 다른 프레임 워크에 대 한 XAML 구문의 요소를 설명 하는 데 사용 되는 용어에 대해 알아봅니다.
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 6ef217a646b14f02c0b812f6316ec84f26d4b660
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168339"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="eb341-103">XAML 구문 정보</span><span class="sxs-lookup"><span data-stu-id="eb341-103">XAML Syntax In Detail</span></span>
<span data-ttu-id="eb341-104">이 항목에서는 XAML 구문의 요소를 설명 하는 데 사용 되는 용어를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-104">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="eb341-105">이러한 용어는이 설명서의 나머지 부분 전체에서 자주 사용 됩니다. WPF 설명서와 XAML을 사용 하는 다른 프레임 워크 또는 system.xaml 수준에서 XAML 언어 지원에 의해 설정 된 기본 XAML 개념에 대해 자주 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-105">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="eb341-106">이 항목에서는 [XAML 개요 (WPF)](../../../desktop-wpf/fundamentals/xaml.md)항목에서 소개 하는 기본 용어를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-106">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="eb341-107">XAML 언어 사양</span><span class="sxs-lookup"><span data-stu-id="eb341-107">The XAML Language Specification</span></span>  
 <span data-ttu-id="eb341-108">여기에 정의 된 XAML 구문 용어는 XAML 언어 사양 내 에서도 정의 되거나 참조 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-108">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="eb341-109">XAML은 XML을 기반으로 하는 언어 이며 XML 구조 규칙에 따라 다음을 수행 하거나 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-109">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="eb341-110">일부 용어는에서 공유 되거나 XML 언어 또는 XML 문서 개체 모델을 설명할 때 일반적으로 사용 되는 용어를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-110">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="eb341-111">XAML 언어 사양에 대 한 자세한 내용은 Microsoft 다운로드 센터에서 [ \[ MS \] -xaml](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) 을 다운로드 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-111">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="eb341-112">XAML 및 CLR</span><span class="sxs-lookup"><span data-stu-id="eb341-112">XAML and CLR</span></span>  
 <span data-ttu-id="eb341-113">XAML은 태그 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-113">XAML is a markup language.</span></span> <span data-ttu-id="eb341-114">이름으로 암시 된 CLR (공용 언어 런타임)은 런타임 실행을 가능 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-114">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="eb341-115">XAML은 CLR 런타임에서 직접 사용 하는 공용 언어 중 하나가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-115">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="eb341-116">대신 XAML을 자체 형식 시스템을 지 원하는 것으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-116">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="eb341-117">WPF에서 사용 되는 특정 XAML 구문 분석 시스템은 CLR 및 CLR 형식 시스템을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-117">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="eb341-118">WPF에 대 한 XAML이 구문 분석 될 때 런타임 표현을 인스턴스화하기 위해 XAML 형식이 CLR 형식에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-118">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="eb341-119">이러한 이유로이 문서의 구문에 대 한 나머지 부분에는 XAML 언어 사양의 동일한 구문 토론이 아닌 경우에도 CLR 형식 시스템에 대 한 참조가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-119">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="eb341-120">Xaml 언어 사양 수준에 따라 XAML 형식은 다른 형식 시스템에 매핑될 수 있습니다. CLR 일 필요는 없지만 다른 XAML 파서의 생성 및 사용이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-120">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="eb341-121">형식 및 클래스 상속의 멤버</span><span class="sxs-lookup"><span data-stu-id="eb341-121">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="eb341-122">형식의 XAML 멤버로 표시 되는 속성 및 이벤트 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 는 기본 형식에서 상속 되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-122">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="eb341-123">예를 들어 다음 예제를 참조 `<Button Background="Blue" .../>` 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-123">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="eb341-124"><xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Button> 클래스 정의, 리플렉션 결과 또는 설명서를 확인 하려는 경우 속성은 클래스의 바로 선언 된 속성이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-124">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="eb341-125">대신 <xref:System.Windows.Controls.Control.Background%2A> 는 기본 클래스에서 상속 됩니다 <xref:System.Windows.Controls.Control> .</span><span class="sxs-lookup"><span data-stu-id="eb341-125">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="eb341-126">XAML 요소의 클래스 상속 동작은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XML 태그의 스키마 적용 해석에서 상당한 출발입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-126">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="eb341-127">클래스 상속은 특히 중간 기본 클래스가 추상 이거나 인터페이스가 포함 된 경우 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-127">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="eb341-128">이는 DTD 또는 XSD 형식과 같이 일반적으로 XML 프로그래밍에 사용 되는 스키마 유형을 사용 하 여 XAML 요소 집합 및 허용 되는 특성을 정확 하 고 완전히 표현 하기 어려운 한 가지 이유입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-128">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="eb341-129">또 다른 이유는 XAML 언어 자체의 확장성 및 형식 매핑 기능에서 허용 되는 형식 및 멤버의 고정 표현의 완전성을 배제 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-129">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="eb341-130">개체 요소 구문</span><span class="sxs-lookup"><span data-stu-id="eb341-130">Object Element Syntax</span></span>  
 <span data-ttu-id="eb341-131">*개체 요소 구문은* XML 요소를 선언 하 여 CLR 클래스 또는 구조체를 인스턴스화하는 XAML 태그 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-131">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="eb341-132">이 구문은 HTML과 같은 다른 태그 언어의 요소 구문과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-132">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="eb341-133">개체 요소 구문은 왼쪽 꺾쇠 괄호 ()로 시작 \< 하 고 인스턴스화된 클래스 또는 구조체의 형식 이름 바로 뒤에 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-133">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="eb341-134">0 개 이상의 공백이 형식 이름 뒤에 올 수 있으며, 개체 요소에서 0 개 이상의 특성을 선언할 수 있으며 각 특성 이름 = "value" 쌍을 구분 하는 하나 이상의 공백이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-134">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="eb341-135">마지막으로 다음 중 하나를 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-135">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="eb341-136">요소와 태그는 슬래시 (/) 뒤에 오른쪽 꺾쇠 괄호 (>)로 즉시 닫혀야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-136">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="eb341-137">여는 태그는 오른쪽 꺾쇠 괄호 (>)로 완료 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-137">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="eb341-138">다른 개체 요소, 속성 요소 또는 내부 텍스트는 여는 태그 뒤에 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-138">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="eb341-139">여기에 포함 될 수 있는 콘텐츠는 일반적으로 요소의 개체 모델에 의해 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-139">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="eb341-140">개체 요소에 해당 하는 닫는 태그도 있어야 하며, 적절 한 중첩 및 다른 여는 태그 쌍과의 균형을 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-140">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="eb341-141">.NET에 의해 구현 되는 XAML에는 개체 요소를 형식, 특성에 속성 또는 이벤트에 매핑하는 규칙 집합, CLR 네임 스페이스와 어셈블리에 XAML 네임 스페이스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-141">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="eb341-142">WPF 및 .NET의 경우 XAML 개체 요소가 참조 된 어셈블리에 정의 된 .NET 형식에 매핑되고 특성은 해당 형식의 멤버에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-142">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="eb341-143">XAML에서 CLR 형식을 참조 하는 경우 해당 형식의 상속 된 멤버에도 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-143">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="eb341-144">예를 들어 다음 예제는 클래스의 새 인스턴스를 인스턴스화하는 개체 요소 구문이 며 특성 <xref:System.Windows.Controls.Button> <xref:System.Windows.FrameworkElement.Name%2A> 및 해당 특성에 대 한 값도 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-144">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="eb341-145">다음 예제는 XAML 콘텐츠 속성 구문도 포함 하는 개체 요소 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-145">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="eb341-146">내에 포함 된 내부 텍스트는 <xref:System.Windows.Controls.TextBox> XAML 콘텐츠 속성인를 설정 하는 데 사용 됩니다 <xref:System.Windows.Controls.TextBox.Text%2A> .</span><span class="sxs-lookup"><span data-stu-id="eb341-146">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="eb341-147">콘텐츠 모델</span><span class="sxs-lookup"><span data-stu-id="eb341-147">Content Models</span></span>  
 <span data-ttu-id="eb341-148">클래스는 구문을 사용 하 여 XAML 개체 요소로 사용을 지원할 수 있지만이 요소는 전체 콘텐츠 모델 또는 요소 트리의 예상 위치에 배치 된 경우에만 응용 프로그램 또는 페이지에서 제대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-148">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="eb341-149">예를 들어,은 <xref:System.Windows.Controls.MenuItem> 일반적으로 <xref:System.Windows.Controls.Primitives.MenuBase> 와 같은 파생 클래스의 자식 으로만 배치 되어야 합니다 <xref:System.Windows.Controls.Menu> .</span><span class="sxs-lookup"><span data-stu-id="eb341-149">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="eb341-150">특정 요소에 대 한 콘텐츠 모델은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 요소로 사용할 수 있는 컨트롤 및 기타 클래스에 대 한 클래스 페이지에 대 한 설명의 일부로 설명 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-150">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="eb341-151">개체 요소의 속성</span><span class="sxs-lookup"><span data-stu-id="eb341-151">Properties of Object Elements</span></span>  
 <span data-ttu-id="eb341-152">XAML의 속성은 가능한 여러 구문으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-152">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="eb341-153">특정 속성에 사용할 수 있는 구문은 설정 중인 속성의 기본 형식 시스템 특성에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-153">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="eb341-154">속성 값을 설정 하 여 런타임 개체 그래프에 있는 개체에 기능 또는 특징을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-154">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="eb341-155">개체 요소에서 만든 개체의 초기 상태는 매개 변수가 없는 생성자 동작을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-155">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="eb341-156">일반적으로 응용 프로그램은 지정 된 개체의 완전히 기본 인스턴스 이외의 다른 항목을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-156">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="eb341-157">특성 구문(속성)</span><span class="sxs-lookup"><span data-stu-id="eb341-157">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="eb341-158">특성 구문은 기존 개체 요소에 특성을 선언 하 여 속성에 대 한 값을 설정 하는 XAML 태그 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-158">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="eb341-159">특성 이름은 관련 개체 요소를 지 원하는 클래스의 속성에 대 한 CLR 멤버 이름과 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-159">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="eb341-160">특성 이름 다음에는 할당 연산자 (=)가 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-160">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="eb341-161">특성 값은 따옴표로 묶인 문자열 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-161">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="eb341-162">교대로 반복 되는 따옴표를 사용 하 여 특성 안에 리터럴 따옴표를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-162">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="eb341-163">예를 들어 큰따옴표를 사용 하 여 큰따옴표 문자를 포함 하는 문자열을 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-163">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="eb341-164">작은따옴표 또는 큰따옴표를 사용 하는 경우에는 일치 하는 쌍을 사용 하 여 특성 값 문자열을 열고 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-164">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="eb341-165">특정 XAML 구문에 적용 되는 문자 제한을 해결 하는 데 사용할 수 있는 이스케이프 시퀀스 또는 기타 기술도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-165">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="eb341-166">[XML 문자 엔터티 및 XAML을](../../../desktop-wpf/xaml-services/xml-character-entities.md)참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-166">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="eb341-167">특성 구문을 통해 설정 하려면 속성이 public 이어야 하며 쓰기 가능 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-167">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="eb341-168">지원 형식 시스템의 속성 값은 값 형식 이어야 하며, 관련 된 지원 형식에 액세스할 때 XAML 프로세서가 인스턴스화하거나 참조할 수 있는 참조 형식 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-168">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="eb341-169">WPF XAML 이벤트의 경우 특성 이름으로 참조 되는 이벤트는 public 이어야 하며 public 대리자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-169">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="eb341-170">속성이 나 이벤트는 포함 하는 개체 요소에 의해 인스턴스화된 클래스 또는 구조체의 멤버 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-170">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="eb341-171">특성 값 처리</span><span class="sxs-lookup"><span data-stu-id="eb341-171">Processing of Attribute Values</span></span>  
 <span data-ttu-id="eb341-172">여는 따옴표와 닫는 따옴표 안에 포함 된 문자열 값은 XAML 프로세서에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-172">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="eb341-173">속성의 경우 기본 처리 동작은 기본 CLR 속성의 형식에 따라 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-173">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="eb341-174">이 처리 순서를 사용 하 여 특성 값은 다음 중 하나로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-174">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="eb341-175">XAML 프로세서가 중괄호 또는에서 파생 되는 개체 요소를 발견 하면 <xref:System.Windows.Markup.MarkupExtension> 값을 문자열로 처리 하는 대신 참조 된 태그 확장이 먼저 평가 되 고 태그 확장에서 반환 된 개체가 값으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-175">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="eb341-176">대부분의 경우 태그 확장에서 반환 되는 개체는 기존 개체에 대 한 참조 또는 런타임까지 계산을 지연 하는 식이 며 새로 인스턴스화된 개체가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-176">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="eb341-177">속성이 특성을 사용 하 여 선언 <xref:System.ComponentModel.TypeConverter> 되거나 해당 속성의 값 형식이 특성을 사용 하 여 선언 된 경우에는 <xref:System.ComponentModel.TypeConverter> 특성의 문자열 값이 변환 입력으로 형식 변환기에 전송 되 고 변환기는 새 개체 인스턴스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-177">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="eb341-178">가 없으면 <xref:System.ComponentModel.TypeConverter> 속성 형식으로 직접 변환 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-178">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="eb341-179">이 최종 수준은 XAML 언어 기본 형식 사이의 파서 네이티브 값에서 직접 변환 하거나, 열거형의 명명 된 상수 이름을 확인 하는 것입니다. 파서는 일치 하는 값에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-179">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="eb341-180">열거 특성 값</span><span class="sxs-lookup"><span data-stu-id="eb341-180">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="eb341-181">XAML의 열거는 XAML 파서에서 내부적으로 처리 되며 열거형의 멤버는 열거형의 명명 된 상수 중 하나의 문자열 이름을 지정 하 여 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-181">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="eb341-182">플래그가 지정 되지 않은 열거형 값의 경우 기본 동작은 특성 값의 문자열을 처리 하 고 열거형 값 중 하나로 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-182">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="eb341-183">형식 *열거*에서 열거형을 지정 하지 않습니다. *값*입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-183">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="eb341-184">대신 *값*만 지정 하면 설정 하는 속성의 형식에 따라 *열거가* 유추 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-184">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="eb341-185">*열거형*의 특성을 지정 하는 경우 *값* 형식이 면 제대로 확인 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-185">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="eb341-186">플래그 열거형의 경우 동작은 메서드를 기반으로 합니다 <xref:System.Enum.Parse%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="eb341-186">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eb341-187">각 값을 쉼표로 구분 하 여 플래그 열거에 대 한 값을 여러 개 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-187">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="eb341-188">그러나 플래그가 아닌 열거형 값은 결합할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-188">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="eb341-189">예를 들어, 쉼표 구문을 사용 하 여 <xref:System.Windows.Trigger> nonflag 열거형의 여러 조건에 대해 작동 하는을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-189">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="eb341-190">XAML로 설정할 수 있는 특성을 지 원하는 플래그 열거형은 WPF에서 드물게 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-190">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="eb341-191">그러나 이러한 열거형 중 하나는 <xref:System.Windows.Media.StyleSimulations> 입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-191">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="eb341-192">예를 들어 쉼표로 구분 된 플래그 특성 구문을 사용 하 여 클래스에 대 한 설명에 제공 된 예제를 수정할 수 있습니다 <xref:System.Windows.Documents.Glyphs> `StyleSimulations = "BoldSimulation"` .가 될 수 있습니다 `StyleSimulations = "BoldSimulation,ItalicSimulation"` .</span><span class="sxs-lookup"><span data-stu-id="eb341-192">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="eb341-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>둘 이상의 열거형 값을 지정할 수 있는 또 다른 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="eb341-194">그러나 열거형에서 자체 형식 변환기를 지원 하기 때문에이 속성은 특별 한 경우에만 발생 <xref:System.Windows.Input.ModifierKeys> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-194">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="eb341-195">한정자에 대 한 형식 변환기는 쉼표 (,)가 아닌 더하기 기호 (+)를 구분 기호로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-195">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="eb341-196">이 변환은 "Ctrl + Alt"와 같이 Microsoft Windows 프로그래밍의 키 조합을 나타내는 보다 일반적인 구문을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-196">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="eb341-197">속성 및 이벤트 멤버 이름 참조</span><span class="sxs-lookup"><span data-stu-id="eb341-197">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="eb341-198">특성을 지정 하는 경우 포함 하는 개체 요소에 대해 인스턴스화한 CLR 형식의 멤버로 존재 하는 속성 또는 이벤트를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-198">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="eb341-199">또는 포함 하는 개체 요소와 관계 없이 연결 된 속성 또는 연결 된 이벤트를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-199">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="eb341-200">(연결 된 속성은 이후의 섹션에서 설명 합니다.)</span><span class="sxs-lookup"><span data-stu-id="eb341-200">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="eb341-201">또한 *typeName*을 사용 하 여 기본 네임 스페이스를 통해 액세스할 수 있는 모든 개체에서 이벤트의 이름을 지정할 수 있습니다. 부분적으로 정규화 된 *이벤트* 이름; 이 구문은 자식 요소에서 라우트된 이벤트를 처리 하기 위해 처리기를 사용 하는 라우트된 이벤트에 대 한 처리기를 연결 하는 것을 지원 하지만, 부모 요소의 members 테이블에도 해당 이벤트가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-201">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="eb341-202">이 구문은 연결 된 이벤트 구문과 유사 하지만 여기에 있는 이벤트는 진정한 연결 된 이벤트가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-202">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="eb341-203">대신 정규화 된 이름을 가진 이벤트를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-203">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="eb341-204">자세한 내용은 [라우트된 이벤트 개요](routed-events-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-204">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="eb341-205">일부 시나리오에서는 속성 이름이 특성 이름이 아니라 특성의 값으로 제공 되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-205">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="eb341-206">해당 속성 이름에는 *ownerType*형식으로 지정 된 속성과 같은 한정자도 포함 될 수 있습니다. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="eb341-206">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="eb341-207">이 시나리오는 XAML에서 스타일이 나 템플릿을 작성할 때 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-207">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="eb341-208">특성 값으로 제공 되는 속성 이름에 대 한 처리 규칙은 서로 다르며, 설정 되는 속성의 형식이 나 특정 WPF 하위 시스템의 동작에 의해 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-208">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="eb341-209">자세한 내용은 스타일 지정 [및 템플릿](../../../desktop-wpf/fundamentals/styles-templates-overview.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-209">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="eb341-210">속성 이름에 대 한 다른 용도는 특성 값이 속성 속성 관계를 설명 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-210">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="eb341-211">이 기능은 데이터 바인딩과 스토리 보드 대상에 사용 되며 <xref:System.Windows.PropertyPath> 클래스와 해당 형식 변환기로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-211">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="eb341-212">조회 의미 체계에 대 한 자세한 설명은 [PROPERTYPATH XAML 구문](propertypath-xaml-syntax.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-212">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="eb341-213">속성 요소 구문</span><span class="sxs-lookup"><span data-stu-id="eb341-213">Property Element Syntax</span></span>  
 <span data-ttu-id="eb341-214">*Property 요소 구문은* 요소에 대 한 기본 XML 구문 규칙에서 달라 지므로 하는 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-214">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="eb341-215">XML에서 특성의 값은 사실상 문자열이 며 문자열 인코딩 형식만 사용 되는 경우에만 가능한 변형입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-215">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="eb341-216">XAML에서 다른 개체 요소를 속성의 값으로 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-216">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="eb341-217">이 기능은 속성 요소 구문에 의해 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-217">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="eb341-218">요소 태그 내에서 특성으로 지정 되는 속성 대신 *Elementtypename*의 여는 요소 태그를 사용 하 여 속성을 지정 합니다. *propertyName* 폼, 속성 값이 내에서 지정 된 다음 property 요소가 닫혀 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-218">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="eb341-219">특히 구문은 왼쪽 꺾쇠 괄호 ()로 시작 \<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-219">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="eb341-220">특성 구문과 마찬가지로 해당 속성은 지정 된 형식의 선언 된 public 멤버 내에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="eb341-221">속성에 할당할 값은 property 요소에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="eb341-222">일반적으로이 값은 하나 이상의 개체 요소로 지정 됩니다. 개체를 값으로 지정 하는 시나리오는 속성 요소 구문이 처리할 시나리오 이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="eb341-223">마지막으로 동일한 *Elementtypename*을 지정 하는 상응 하는 닫는 태그입니다. *propertyName* 조합을 제공 해야 하며, 적절 한 중첩 및 다른 요소 태그와 균형을 맞추어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="eb341-224">예를 들어 다음은의 속성에 대 한 속성 요소 구문입니다 <xref:System.Windows.FrameworkElement.ContextMenu%2A> <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="eb341-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="eb341-225">속성 요소 내의 값은 지정 되는 속성 형식이와 같은 기본 값 형식 이거나 이름이 지정 된 열거형 인 경우에도 내부 텍스트로 제공 될 수 있습니다 <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="eb341-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="eb341-226">이러한 두 가지 사용은 일반적이 지 않습니다. 이러한 각 경우에는 보다 간단한 특성 구문을 사용할 수도 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="eb341-227">속성 요소를 문자열로 채우는 한 가지 시나리오는 XAML 콘텐츠 속성이 아니지만 UI 텍스트 표현에 사용 되는 속성에 대 한 것 이며, 줄 바꿈과 같은 특정 공백 요소가 해당 UI 텍스트에 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="eb341-228">특성 구문은 줄 바꿈을 유지할 수 없지만, 유효 공백 유지가 활성화 되어 있으면 속성 요소 구문이 가능 합니다. 자세한 내용은 [XAML의 공백 처리](../../../desktop-wpf/xaml-services/white-space-processing.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="eb341-229">또 다른 시나리오는 [X:Uid 지시문](../../../desktop-wpf/xaml-services/xuid-directive.md) 을 property 요소에 적용 하 여의 값을 WPF 출력 BAML 또는 다른 기술에서 지역화 해야 하는 값으로 표시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="eb341-230">속성 요소는 WPF 논리 트리에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="eb341-231">속성 요소는 속성을 설정 하기 위한 특정 구문 이지만 인스턴스 또는 개체를 지 원하는 요소는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="eb341-232">논리적 트리 개념에 대 한 자세한 내용은 [WPF의 트리](trees-in-wpf.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="eb341-233">특성과 속성 요소 구문이 모두 지원 되는 속성의 경우 두 구문은 일반적으로 동일한 결과를 가집니다. 단, 공백 처리와 같은 세부 사항은 구문 사이에서 약간 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="eb341-234">컬렉션 구문</span><span class="sxs-lookup"><span data-stu-id="eb341-234">Collection Syntax</span></span>  
 <span data-ttu-id="eb341-235">XAML 사양에서는 값 형식이 컬렉션인 속성을 식별 하기 위해 XAML 프로세서 구현이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="eb341-236">.NET의 일반적인 XAML 프로세서 구현은 관리 코드 및 CLR을 기반으로 하며 다음 중 하나를 통해 컬렉션 형식을 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="eb341-237">형식을 구현 <xref:System.Collections.IList> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="eb341-238">형식을 구현 <xref:System.Collections.IDictionary> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="eb341-239">형식이에서 파생 <xref:System.Array> 됩니다. XAML의 배열에 대 한 자세한 내용은 [X:Array 태그 확장](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="eb341-240">속성 형식이 컬렉션인 경우에는 유추 된 컬렉션 형식을 개체 요소로 태그에 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="eb341-241">대신 컬렉션의 항목으로 사용 되는 요소는 property 요소의 자식 요소로 하나 이상의 자식 요소로 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="eb341-242">이러한 각 항목은 로드 하는 동안 개체로 계산 된 후 `Add` 암시적 컬렉션의 메서드를 호출 하 여 컬렉션에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="eb341-243">예를 들어의 속성은을 구현 하는 <xref:System.Windows.Style.Triggers%2A> <xref:System.Windows.Style> 특수화 된 컬렉션 형식을 사용 합니다 <xref:System.Windows.TriggerCollection> <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="eb341-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="eb341-244">태그의 개체 요소를 인스턴스화할 필요는 없습니다 <xref:System.Windows.TriggerCollection> .</span><span class="sxs-lookup"><span data-stu-id="eb341-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="eb341-245">대신 속성 요소 내에서 하나 이상의 <xref:System.Windows.Trigger> 항목을 요소로 지정 합니다 `Style.Triggers` <xref:System.Windows.Trigger> . 여기서 (또는 파생 클래스)은 강력한 형식 및 암시적의 항목 형식으로 예상 되는 형식입니다 <xref:System.Windows.TriggerCollection> .</span><span class="sxs-lookup"><span data-stu-id="eb341-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="eb341-246">속성은이 항목의 다음 섹션에서 설명 하는 해당 형식 및 파생 형식에 대 한 컬렉션 형식 및 XAML 콘텐츠 속성 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="eb341-247">암시적 컬렉션 요소는 태그에 요소로 나타나지 않는 경우에도 논리적 트리 표현에서 멤버를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="eb341-248">일반적으로 부모 형식의 생성자는 해당 속성 중 하나인 컬렉션에 대해 인스턴스화를 수행 하 고 처음에는 빈 컬렉션이 개체 트리의 일부가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="eb341-249">제네릭 목록 및 사전 인터페이스 ( <xref:System.Collections.Generic.IList%601> 및 <xref:System.Collections.Generic.IDictionary%602> )는 컬렉션 검색에 대해 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="eb341-250">그러나 클래스는 직접 <xref:System.Collections.Generic.List%601> <xref:System.Collections.IList> 을 <xref:System.Collections.Generic.Dictionary%602> 구현 하기 때문에 클래스를 기본 클래스로 사용할 수 있습니다 <xref:System.Collections.IDictionary> .</span><span class="sxs-lookup"><span data-stu-id="eb341-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="eb341-251">컬렉션 형식에 대 한 .NET 참조 페이지에서 컬렉션에 대 한 개체 요소를 의도적으로 생략 하는이 구문은 XAML 구문 섹션에서 암시적 컬렉션 구문으로 표시 되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="eb341-252">Root 요소를 제외 하 고, 다른 요소의 자식 요소로 중첩 되는 XAML 파일의 모든 개체 요소는 사실상 부모 요소의 암시적 컬렉션 속성의 멤버 또는 부모 요소에 대 한 XAML 콘텐츠 속성의 값을 지정 하는 요소입니다. (XAML 콘텐츠 속성은 예정 된 섹션에서 설명 합니다.).</span><span class="sxs-lookup"><span data-stu-id="eb341-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="eb341-253">즉, 태그 페이지의 부모 요소와 자식 요소의 관계는 실질적으로 루트의 단일 개체 이며, 루트 아래의 모든 개체 요소는 부모의 속성 값을 제공 하는 단일 인스턴스이거나 부모의 컬렉션 형식 속성 값 이기도 한 컬렉션 내의 항목 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="eb341-254">이 단일 루트 개념은 XML에 공통적 이며와 같이 XAML을 로드 하는 Api의 동작에서 자주 강화 됩니다 <xref:System.Windows.Markup.XamlReader.Load%2A> .</span><span class="sxs-lookup"><span data-stu-id="eb341-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="eb341-255">다음 예제는 <xref:System.Windows.Media.GradientStopCollection> 명시적으로 지정 된 컬렉션에 대 한 개체 요소를 포함 하는 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="eb341-256">컬렉션을 명시적으로 선언 하는 것은 항상 가능 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="eb341-257">예를 들어, 이전에 <xref:System.Windows.TriggerCollection> 표시 된 예제에서를 명시적으로 선언 하려고 하면 <xref:System.Windows.Style.Triggers%2A> 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="eb341-258">컬렉션을 명시적으로 선언 하려면 컬렉션 클래스에서 매개 변수가 없는 생성자를 지원 해야 하 고 <xref:System.Windows.TriggerCollection> 매개 변수가 없는 생성자가 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="eb341-259">XAML 콘텐츠 속성</span><span class="sxs-lookup"><span data-stu-id="eb341-259">XAML Content Properties</span></span>  
 <span data-ttu-id="eb341-260">XAML 콘텐츠 구문은를 해당 클래스 선언의 일부로 지정 하는 클래스 에서만 사용할 수 있는 구문입니다 <xref:System.Windows.Markup.ContentPropertyAttribute> .</span><span class="sxs-lookup"><span data-stu-id="eb341-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="eb341-261">는 <xref:System.Windows.Markup.ContentPropertyAttribute> 파생 클래스를 포함 하 여 해당 요소 형식에 대 한 콘텐츠 속성인 속성 이름을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="eb341-262">XAML 프로세서에서 처리 하는 경우 개체 요소의 여는 태그와 닫는 태그 사이에 있는 모든 자식 요소나 내부 텍스트는 해당 개체에 대 한 XAML 콘텐츠 속성의 값으로 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="eb341-263">Content 속성에 대 한 명시적 속성 요소를 지정할 수 있지만이 사용은 일반적으로 .NET 참조의 XAML 구문 섹션에 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="eb341-264">명시적/자세한 기술 기술은 태그 명확성을 위해 또는 태그 스타일의 중요 한 값을 가지 지만, 일반적으로 콘텐츠 속성의 목적은 부모-자식과 직관적으로 관련 된 요소를 직접 중첩할 수 있도록 태그를 간소화 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="eb341-265">요소의 다른 속성에 대 한 속성 요소 태그는 엄격한 XAML 언어 정의에 따라 "내용"으로 할당 되지 않습니다. 이러한 작업은 이전에 XAML 파서의 처리 순서에서 처리 되며 "내용"으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="eb341-266">XAML 콘텐츠 속성 값은 연속적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="eb341-267">XAML 콘텐츠 속성의 값은 해당 개체 요소에 대 한 다른 속성 요소 보다 먼저 또는 완전히 뒤에 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="eb341-268">이는 XAML 콘텐츠 속성의 값이 문자열 또는 하나 이상의 개체로 지정 되는지 여부에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="eb341-269">예를 들어 다음 태그는 구문 분석 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="eb341-270">콘텐츠 속성의 속성 요소 구문을 사용 하 여이 구문을 명시적으로 만든 경우 content 속성을 두 번 설정 했기 때문에이는 기본적으로 유효 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="eb341-271">이와 유사한 잘못 된 예제는 content 속성이 컬렉션인 경우와 자식 요소가 속성 요소와 함께 사용 되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="eb341-272">콘텐츠 속성 및 컬렉션 구문 조합</span><span class="sxs-lookup"><span data-stu-id="eb341-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="eb341-273">단일 개체 요소를 콘텐츠로 허용 하려면 콘텐츠 속성의 형식이 특히 컬렉션 형식 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="eb341-274">컬렉션 형식에 대 한 속성 요소 구문과 마찬가지로 XAML 프로세서는 컬렉션 형식인 형식을 식별 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="eb341-275">요소에 XAML 콘텐츠 속성이 있고 XAML 콘텐츠 속성의 형식이 컬렉션인 경우에는 암시적 컬렉션 형식을 개체 요소로 태그에 지정할 필요가 없으며 XAML 콘텐츠 속성을 속성 요소로 지정할 필요가 없습니다 (예를 들어).</span><span class="sxs-lookup"><span data-stu-id="eb341-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="eb341-276">따라서 태그의 명백한 콘텐츠 모델에는 이제 내용으로 둘 이상의 자식 요소가 할당 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="eb341-277">다음은 파생 된 클래스에 대 한 내용 구문입니다 <xref:System.Windows.Controls.Panel> .</span><span class="sxs-lookup"><span data-stu-id="eb341-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="eb341-278">모든 <xref:System.Windows.Controls.Panel> 파생 클래스는 XAML 콘텐츠 속성을로 설정 합니다 .이 속성에는 <xref:System.Windows.Controls.Panel.Children%2A> 형식의 값이 필요 <xref:System.Windows.Controls.UIElementCollection> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="eb341-279">의 property 요소와의 요소는 <xref:System.Windows.Controls.Panel.Children%2A> <xref:System.Windows.Controls.UIElementCollection> 태그에 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="eb341-280">이는 XAML의 디자인 기능으로,을 정의 하는 재귀적으로 포함 된 요소가 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 중간 속성 요소 태그 또는 컬렉션 개체 없이 직계 부모-자식 요소 관계가 있는 중첩 된 요소의 트리로 보다 직관적으로 표현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="eb341-281">실제로는 <xref:System.Windows.Controls.UIElementCollection> 의도적으로 태그에서 개체 요소로 명시적으로 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="eb341-282">유일 하 게 사용 되는 것은 암시적 컬렉션 이므로는 <xref:System.Windows.Controls.UIElementCollection> 매개 변수가 없는 public 생성자를 노출 하지 않으므로 개체 요소로 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="eb341-283">콘텐츠 속성을 사용 하 여 개체에서 속성 요소 및 개체 요소 혼합</span><span class="sxs-lookup"><span data-stu-id="eb341-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="eb341-284">Xaml 사양에서는 XAML 프로세서가 개체 요소 내에서 XAML 콘텐츠 속성을 채우는 데 사용 되는 개체 요소를 연속 해야 하며 혼합할 수 없도록 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="eb341-285">속성 요소와 콘텐츠를 혼합 하는 이러한 제한은 XAML 프로세서에 의해 적용 됩니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="eb341-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="eb341-286">자식 개체 요소를 개체 요소 내의 첫 번째 직접 태그로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="eb341-287">그런 다음 속성 요소를 도입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-287">Then you can introduce property elements.</span></span> <span data-ttu-id="eb341-288">또는 하나 이상의 속성 요소, 콘텐츠, 추가 속성 요소를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="eb341-289">그러나 속성 요소가 콘텐츠 뒤에 오면 추가 콘텐츠를 도입할 수 없으며 속성 요소만 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="eb341-290">이 내용/속성 요소 순서 요구 사항은 콘텐츠로 사용 되는 내부 텍스트에 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="eb341-291">그러나 속성 요소가 내부 텍스트와 함께 사용 되는 경우 유효 공백은 태그에서 시각적으로 검색 하기가 어렵기 때문에 내부 텍스트를 연속 하 여 유지 하는 것은 여전히 좋은 태그 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="eb341-292">XAML 네임스페이스</span><span class="sxs-lookup"><span data-stu-id="eb341-292">XAML Namespaces</span></span>  
 <span data-ttu-id="eb341-293">이전 구문 예제에서 기본 XAML 네임 스페이스 이외의 XAML 네임 스페이스를 지정 하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="eb341-294">일반적인 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램에서 기본 XAML 네임 스페이스는 네임 스페이스로 지정 됩니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="eb341-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="eb341-295">기본 XAML 네임 스페이스 외에도 여전히 유사한 구문을 사용 하는 XAML 네임 스페이스를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="eb341-296">그러나 기본 XAML 네임 스페이스 내에서 액세스할 수 없는 클래스 이름이 지정 된 위치에 있는 경우 해당 클래스 이름 앞에는 해당 CLR 네임 스페이스에 매핑된 XAML 네임 스페이스의 접두사가와 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="eb341-297">예를 들어,는 `<custom:Example/>` 클래스의 인스턴스를 인스턴스화하는 개체 요소 구문입니다 `Example` . 여기에서 해당 클래스를 포함 하는 CLR 네임 스페이스와 지원 형식이 포함 된 외부 어셈블리 정보는 이전에 접두사에 매핑 되었습니다 `custom` .</span><span class="sxs-lookup"><span data-stu-id="eb341-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="eb341-298">XAML 네임 스페이스에 대 한 자세한 내용은 [WPF xaml을 위한 Xaml 네임 스페이스 및 네임 스페이스 매핑](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="eb341-299">태그 확장</span><span class="sxs-lookup"><span data-stu-id="eb341-299">Markup Extensions</span></span>  
 <span data-ttu-id="eb341-300">XAML은 문자열 특성 값 또는 개체 요소의 일반적인 XAML 프로세서 처리에서 이스케이프할 수 있도록 하 고 지원 클래스에 대 한 처리를 지연 하는 태그 확장 프로그래밍 엔터티를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="eb341-301">특성 구문을 사용 하는 경우 XAML 프로세서에 대 한 태그 확장을 식별 하는 문자는 여는 중괄호 ({)와 닫는 중괄호 (}) 이외의 모든 문자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="eb341-302">여는 중괄호 뒤의 첫 번째 문자열은 특정 확장 동작을 제공 하는 클래스를 참조 해야 합니다 .이 경우에는 해당 하위 문자열이 진정한 클래스 이름의 일부인 경우 참조에서 하위 문자열 "Extension"을 생략할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="eb341-303">이후에는 단일 공간이 나타날 수 있으며, 그 다음에 나오는 각 문자는 닫는 중괄호가 나타날 때까지 확장 구현에서 입력으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="eb341-304">.NET XAML 구현에서는 <xref:System.Windows.Markup.MarkupExtension> 에서 지 원하는 모든 태그 확장의 기반으로 추상 클래스를 사용 하 고 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 다른 프레임 워크 또는 기술도 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="eb341-305">특수 하 게 구현 되는 태그 확장은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 다른 기존 개체를 참조 하거나 런타임에 계산 될 개체에 대해 지연 된 참조를 만들 수 있는 수단을 제공 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="eb341-306">예를 들어 `{Binding}` 특정 속성에 일반적으로 사용 되는 값 대신 태그 확장을 지정 하 여 간단한 WPF 데이터 바인딩을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="eb341-307">대부분의 WPF 태그 확장은 특성 구문이 가능 하지 않은 속성에 대 한 특성 구문을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="eb341-308">예를 <xref:System.Windows.Style> 들어 개체는 중첩 된 일련의 개체 및 속성을 포함 하는 비교적 복잡 한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="eb341-309">WPF의 스타일은 일반적으로의 리소스로 정의 된 <xref:System.Windows.ResourceDictionary> 다음 리소스를 요청 하는 두 개의 WPF 태그 확장 중 하나를 통해 참조 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="eb341-310">태그 확장은 리소스 조회에 대 한 속성 값의 계산을 지연 하 고 <xref:System.Windows.FrameworkElement.Style%2A> <xref:System.Windows.Style> 다음 예제와 같이 특성 구문을 사용 하 여 속성 값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="eb341-311">여기서는 `StaticResource` <xref:System.Windows.StaticResourceExtension> 태그 확장 구현을 제공 하는 클래스를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="eb341-312">다음 문자열은 `MyStyle` 기본이 아닌 생성자의 입력으로 사용 됩니다 <xref:System.Windows.StaticResourceExtension> . 여기서 확장 문자열에서 가져온 매개 변수는 요청 된를 선언 합니다 <xref:System.Windows.ResourceKey> .</span><span class="sxs-lookup"><span data-stu-id="eb341-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="eb341-313">`MyStyle`는 리소스로 정의 된의 [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) 값 이어야 합니다 <xref:System.Windows.Style> .</span><span class="sxs-lookup"><span data-stu-id="eb341-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="eb341-314">[StaticResource 태그 확장](staticresource-markup-extension.md) 사용은 리소스를 <xref:System.Windows.Style> 로드 시 정적 리소스 조회 논리를 통해 속성 값을 제공 하는 데 사용 하도록 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="eb341-315">태그 확장에 대한 자세한 내용은 [XAML 태그 확장 및 WPF XAML](markup-extensions-and-wpf-xaml.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="eb341-316">일반 .NET XAML 구현에서 사용 되는 태그 확장 및 기타 XAML 프로그래밍 기능에 대 한 참조는 [Xaml 네임 스페이스 (x:)를 참조 하세요. 언어 기능](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="eb341-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="eb341-317">WPF 관련 태그 확장은 [WPF XAML 확장](wpf-xaml-extensions.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="eb341-318">연결된 속성</span><span class="sxs-lookup"><span data-stu-id="eb341-318">Attached Properties</span></span>  
 <span data-ttu-id="eb341-319">연결 된 속성은 특정 형식에서 속성을 소유 하 고 정의할 수 있지만 모든 요소에서 특성 또는 속성 요소로 설정할 수 있는 XAML로 도입 된 프로그래밍 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="eb341-320">연결 된 속성을 사용 하는 기본 시나리오는 모든 요소에 대해 광범위 한 공유 개체 모델을 요구 하지 않고도 태그 구조의 자식 요소가 부모 요소에 정보를 보고할 수 있도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="eb341-321">반대로, 연결 된 속성은 부모 요소에서 자식 요소에 대 한 정보를 보고 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="eb341-322">연결 된 속성의 목적과 연결 된 속성을 만드는 방법에 대 한 자세한 내용은 [연결 된 속성 개요](attached-properties-overview.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="eb341-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="eb341-323">연결 된 속성은 *typeName*도 지정 한다는 표면적 속성 요소 구문과 유사한 구문을 사용 합니다. *propertyName* 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="eb341-324">다음과 같은 두 가지 중요한 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="eb341-325">*TypeName*을 사용할 수 있습니다. 특성 구문을 통해 연결 된 속성을 설정 하는 경우에도 *propertyName* 조합이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="eb341-326">연결 된 속성은 속성 이름을 정규화 하는 경우에만 특성 구문의 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="eb341-327">연결 된 속성에 대해 속성 요소 구문을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="eb341-328">그러나 일반적인 속성 요소 구문의 경우 지정 하는 *typeName* 은 property 요소를 포함 하는 개체 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="eb341-329">연결 된 속성을 참조 하는 경우 *typeName* 은 포함 하는 개체 요소가 아니라 연결 된 속성을 정의 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="eb341-330">연결된 이벤트</span><span class="sxs-lookup"><span data-stu-id="eb341-330">Attached Events</span></span>  
 <span data-ttu-id="eb341-331">연결 된 이벤트는 특정 형식으로 이벤트를 정의할 수 있지만 모든 개체 요소에 대 한 처리기가 연결 될 수 있는 XAML에서 도입 된 다른 프로그래밍 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="eb341-332">WOF 구현에서 연결 된 이벤트를 정의 하는 형식은 서비스를 정의 하는 정적 형식이 고, 경우에 따라 연결 된 이벤트는 서비스를 노출 하는 형식의 라우트된 이벤트 별칭에 의해 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="eb341-333">연결 된 이벤트에 대 한 처리기는 특성 구문을 통해 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="eb341-334">연결 된 이벤트와 마찬가지로 특성 구문은 연결 된 이벤트에 대해 확장 되어 *typeName*을 허용 합니다. *eventname* 사용. 여기서 *typeName* 은 `Add` 연결 된 `Remove` 이벤트 인프라에 대해 및 이벤트 처리기 접근자를 제공 하는 클래스이 고 *eventName* 은 이벤트 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="eb341-335">XAML 루트 요소 분석</span><span class="sxs-lookup"><span data-stu-id="eb341-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="eb341-336">다음 표에서는 일반적인 XAML 루트 요소를 세분화 하 여 루트 요소의 특정 특성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="eb341-337">Root 요소의 개체 요소를 여는 중</span><span class="sxs-lookup"><span data-stu-id="eb341-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="eb341-338">Default ( [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ) XAML 네임 스페이스</span><span class="sxs-lookup"><span data-stu-id="eb341-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="eb341-339">XAML 언어 XAML 네임 스페이스</span><span class="sxs-lookup"><span data-stu-id="eb341-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="eb341-340">Partial 클래스에 대해 정의 된 코드 숨김으로 태그를 연결 하는 partial 클래스 선언입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="eb341-341">루트에 대 한 개체 요소의 끝입니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-341">End of object element for the root.</span></span> <span data-ttu-id="eb341-342">요소가 자식 요소를 포함 하기 때문에 개체가 아직 닫혀 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="eb341-343">선택적 및 권장 되지 않는 XAML 용도</span><span class="sxs-lookup"><span data-stu-id="eb341-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="eb341-344">다음 섹션에서는 xaml 프로세서에서 기술적으로 지원 되지만 xaml 소스를 포함 하는 응용 프로그램을 개발할 때 사용자가 읽을 수 있는 XAML 파일을 방해 하는 자세한 정보 표시 또는 기타 미적 문제를 생성 하는 XAML 사용에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="eb341-345">선택적 속성 요소 사용</span><span class="sxs-lookup"><span data-stu-id="eb341-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="eb341-346">선택적 속성 요소 사용에는 XAML 프로세서에서 암시적으로 고려 하는 요소 콘텐츠 속성을 명시적으로 작성 하는 작업이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="eb341-347">예를 들어의 콘텐츠를 선언 하는 경우의 <xref:System.Windows.Controls.Menu> 컬렉션을 속성 요소 태그로 명시적으로 선언 하 <xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.Menu> `<Menu.Items>` 고 <xref:System.Windows.Controls.MenuItem> `<Menu.Items>` ,의 모든 자식 요소가 <xref:System.Windows.Controls.Menu> 이어야 하 <xref:System.Windows.Controls.MenuItem> 고 컬렉션에 배치 되어야 하는 암시적 XAML 프로세서 동작을 사용 <xref:System.Windows.Controls.ItemsControl.Items%2A> 하는 대신 각에 배치 하는 것을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="eb341-348">경우에 따라 선택적 사용을 사용 하면 태그에 표시 된 개체 구조를 시각적으로 명확 하 게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="eb341-349">또는 명시적 속성 요소를 사용 하는 경우에는 기술적으로 작동 하지만 시각적으로 혼동 되는 태그를 방지할 수 있습니다 (예: 특성 값 내 중첩 된 태그 확장).</span><span class="sxs-lookup"><span data-stu-id="eb341-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="eb341-350">전체 typeName. memberName 정규화 된 특성</span><span class="sxs-lookup"><span data-stu-id="eb341-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="eb341-351">형식 *이름*입니다. 특성에 대 한 *memberName* 폼은 실제로 라우트된 이벤트 사례 보다 훨씬 더 일반적으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="eb341-352">그러나 형식이 불필요 하 고 태그 스타일 및 가독성을 위해 필요한 경우에만이를 방지 해야 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="eb341-353">다음 예제에서 특성에 대 한 세 개의 참조는 <xref:System.Windows.Controls.Control.Background%2A> 모두 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="eb341-354">`Button.Background`에서 해당 속성에 대 한 정규화 된 조회가 <xref:System.Windows.Controls.Button> 성공 하 <xref:System.Windows.Controls.Control.Background%2A> 고 (컨트롤에서 상속 됨) <xref:System.Windows.Controls.Button> 개체 요소의 클래스 또는 기본 클래스 이기 때문에 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="eb341-355">`Control.Background`<xref:System.Windows.Controls.Control>클래스는 실제로 <xref:System.Windows.Controls.Control.Background%2A> 을 정의 하 고 <xref:System.Windows.Controls.Control> 기본 클래스 이기 때문에 작동 <xref:System.Windows.Controls.Button> 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="eb341-356">그러나 다음 형식 *이름*입니다. *memberName* form 예제는 작동 하지 않으므로 주석으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="eb341-357"><xref:System.Windows.Controls.Label>는의 다른 파생 클래스 이며, <xref:System.Windows.Controls.Control> `Label.Background` 개체 요소 내에서를 지정한 경우 <xref:System.Windows.Controls.Label> 이 사용이 정상적으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="eb341-358">그러나 <xref:System.Windows.Controls.Label> 는의 클래스 또는 기본 클래스가 아니므로 <xref:System.Windows.Controls.Button> 지정 된 XAML 프로세서 동작은를 연결 된 속성으로 처리 하는 것입니다 `Label.Background` .</span><span class="sxs-lookup"><span data-stu-id="eb341-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="eb341-359">`Label.Background`는 사용 가능한 연결 된 속성이 아니므로이 사용이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="eb341-360">baseTypeName. memberName 속성 요소</span><span class="sxs-lookup"><span data-stu-id="eb341-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="eb341-361">*TypeName*과 비슷한 방법으로 *memberName* Form은 *basetypename*특성 구문에 대해 작동 합니다. *memberName* 구문은 속성 요소 구문에 대해 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="eb341-362">예를 들어 다음 구문은 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="eb341-363">여기서 property 요소는에 포함 되어 있는 경우에도로 지정 되었습니다 `Control.Background` `Button` .</span><span class="sxs-lookup"><span data-stu-id="eb341-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="eb341-364">하지만 *typeName*과 동일 합니다. *memberName* 특성에 대 한 형식 *basetypename*. *memberName* 가 태그에서 잘못 된 스타일 이므로이를 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eb341-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eb341-365">참조</span><span class="sxs-lookup"><span data-stu-id="eb341-365">See also</span></span>

- [<span data-ttu-id="eb341-366">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="eb341-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="eb341-367">XAML Namespace(x:) 언어 기능</span><span class="sxs-lookup"><span data-stu-id="eb341-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="eb341-368">WPF XAML 확장</span><span class="sxs-lookup"><span data-stu-id="eb341-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="eb341-369">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="eb341-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="eb341-370">TypeConverter 및 XAML</span><span class="sxs-lookup"><span data-stu-id="eb341-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="eb341-371">WPF에 대한 XAML 및 사용자 지정 클래스</span><span class="sxs-lookup"><span data-stu-id="eb341-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
