---
title: 라우트된 이벤트 개요
description: 요소 트리를 통해 라우팅되는 방법 및 사용자 지정 라우트된 이벤트를 만드는 방법을 비롯 하 여 Windows Presentation Foundation에서 라우트된 이벤트에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
ms.openlocfilehash: d18b511a4886c68922cccac14942eb54e5735a71
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87164814"
---
# <a name="routed-events-overview"></a><span data-ttu-id="d413a-103">라우트된 이벤트 개요</span><span class="sxs-lookup"><span data-stu-id="d413a-103">Routed Events Overview</span></span>

<span data-ttu-id="d413a-104">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]에서 라우트된 이벤트의 개념을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-104">This topic describes the concept of routed events in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="d413a-105">이 항목에서는 라우트된 이벤트 용어를 정의하고, 라우트된 이벤트가 요소 트리를 통해 라우트되는 방식을 설명하고, 라우트된 이벤트를 처리하는 방법을 요약하고, 자체 사용자 지정 라우트된 이벤트를 만드는 방법을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-105">The topic defines routed events terminology, describes how routed events are routed through a tree of elements, summarizes how you handle routed events, and introduces how to create your own custom routed events.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="d413a-106">필수 구성 요소</span><span class="sxs-lookup"><span data-stu-id="d413a-106">Prerequisites</span></span>

<span data-ttu-id="d413a-107">이 항목에서는 CLR (공용 언어 런타임) 및 개체 지향 프로그래밍에 대 한 기본 지식이 있다고 가정 하 고 요소 간의 관계를 트리로 개념화 하는 방법에 대 한 개념을 설명 합니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d413a-107">This topic assumes that you have basic knowledge of the common language runtime (CLR) and object-oriented programming, as well as the concept of how the relationships between [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements can be conceptualized as a tree.</span></span> <span data-ttu-id="d413a-108">이 항목의 예제를 따르려면 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]을 이해하고 매우 기본적인 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션 또는 페이지를 작성하는 방법을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-108">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write very basic [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications or pages.</span></span> <span data-ttu-id="d413a-109">자세한 내용은 [연습: 내 첫 wpf 데스크톱 응용 프로그램](../getting-started/walkthrough-my-first-wpf-desktop-application.md) 및 [XAML 개요 (WPF)](../../../desktop-wpf/fundamentals/xaml.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-109">For more information, see [Walkthrough: My first WPF desktop application](../getting-started/walkthrough-my-first-wpf-desktop-application.md) and [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>

<a name="routing"></a>

## <a name="what-is-a-routed-event"></a><span data-ttu-id="d413a-110">라우트된 이벤트란?</span><span class="sxs-lookup"><span data-stu-id="d413a-110">What Is a Routed Event?</span></span>

<span data-ttu-id="d413a-111">기능 또는 구현 측면에서 라우트된 이벤트를 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-111">You can think about routed events either from a functional or implementation perspective.</span></span> <span data-ttu-id="d413a-112">사용자마다 더 유용하다고 생각하는 정의가 다르므로 여기에서는 두 가지 정의를 모두 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-112">Both definitions are presented here, because some people find one or the other definition more useful.</span></span>

<span data-ttu-id="d413a-113">기능 정의: 라우트된 이벤트는 이벤트를 일으킨 개체에서만이 아니라 요소 트리의 여러 수신기에서 처리기를 호출할 수 있는 이벤트 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-113">Functional definition: A routed event is a type of event that can invoke handlers on multiple listeners in an element tree, rather than just on the object that raised the event.</span></span>

<span data-ttu-id="d413a-114">구현 정의: 라우트된 이벤트는 클래스의 인스턴스에서 지원 되 <xref:System.Windows.RoutedEvent> 고 이벤트 시스템에서 처리 되는 CLR 이벤트입니다 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d413a-114">Implementation definition: A routed event is a CLR event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and is processed by the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] event system.</span></span>

<span data-ttu-id="d413a-115">일반적인 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션에는 많은 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-115">A typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application contains many elements.</span></span> <span data-ttu-id="d413a-116">코드로 만들어지든지, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에 선언되든지 관계없이 이러한 요소는 서로에 대한 요소 트리 관계로 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-116">Whether created in code or declared in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], these elements exist in an element tree relationship to each other.</span></span> <span data-ttu-id="d413a-117">이벤트 경로는 이벤트 정의에 따라 두 방향 중 하나로 이동할 수 있지만, 일반적으로 경로는 소스 요소부터 이동하여 요소 트리 루트(일반적으로 페이지 또는 창)에 도달할 때까지 요소 트리를 통해 위쪽으로 "버블링"됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-117">The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window).</span></span> <span data-ttu-id="d413a-118">이전에 DHTML 개체 모델을 사용했다면 이 버블링 개념이 익숙할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-118">This bubbling concept might be familiar to you if you have worked with the DHTML object model previously.</span></span>

<span data-ttu-id="d413a-119">다음 간단한 요소 트리를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-119">Consider the following simple element tree:</span></span>

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

<span data-ttu-id="d413a-120">이 요소 트리는 다음과 같은 항목을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-120">This element tree produces something like the following:</span></span>

<span data-ttu-id="d413a-121">![예, 아니요 및 취소 단추](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span><span class="sxs-lookup"><span data-stu-id="d413a-121">![Yes, No, and Cancel buttons](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span></span>

<span data-ttu-id="d413a-122">이 간소화 된 요소 트리에서 이벤트의 소스는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 요소 중 하나 이며 클릭 한 <xref:System.Windows.Controls.Button> 것은 이벤트를 <xref:System.Windows.Controls.Button> 처리할 수 있는 첫 번째 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-122">In this simplified element tree, the source of a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is one of the <xref:System.Windows.Controls.Button> elements, and whichever <xref:System.Windows.Controls.Button> was clicked is the first element that has the opportunity to handle the event.</span></span> <span data-ttu-id="d413a-123">그러나에 연결 된 처리기가 <xref:System.Windows.Controls.Button> 이벤트에 대해 작동 하지 않는 경우이 이벤트는 <xref:System.Windows.Controls.Button> 요소 트리의 부모 ()로 위쪽으로 버블링 됩니다 <xref:System.Windows.Controls.StackPanel> .</span><span class="sxs-lookup"><span data-stu-id="d413a-123">But if no handler attached to the <xref:System.Windows.Controls.Button> acts on the event, then the event will bubble upwards to the <xref:System.Windows.Controls.Button> parent in the element tree, which is the <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="d413a-124">잠재적으로 이벤트는로 버블링 된 <xref:System.Windows.Controls.Border> 다음 요소 트리의 페이지 루트 (표시 되지 않음)로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-124">Potentially, the event bubbles to <xref:System.Windows.Controls.Border>, and then beyond to the page root of the element tree (not shown).</span></span>

<span data-ttu-id="d413a-125">즉,이 이벤트에 대 한 이벤트 경로는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-125">In other words, the event route for this <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is:</span></span>

<span data-ttu-id="d413a-126">Button-->StackPanel-->Border-->...</span><span class="sxs-lookup"><span data-stu-id="d413a-126">Button-->StackPanel-->Border-->...</span></span>

### <a name="top-level-scenarios-for-routed-events"></a><span data-ttu-id="d413a-127">라우트된 이벤트에 대한 최상위 시나리오</span><span class="sxs-lookup"><span data-stu-id="d413a-127">Top-level Scenarios for Routed Events</span></span>

<span data-ttu-id="d413a-128">다음은 라우트된 이벤트 개념에 대해 동기를 받은 시나리오와 일반적인 CLR 이벤트가 이러한 시나리오에 적합 하지 않은 이유에 대 한 간략 한 요약입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-128">The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical CLR event was not adequate for these scenarios:</span></span>

<span data-ttu-id="d413a-129">**컨트롤 컴퍼지션 및 캡슐화:**[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 다양한 컨트롤에는 서식 있는 콘텐츠 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-129">**Control composition and encapsulation:** Various controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have a rich content model.</span></span> <span data-ttu-id="d413a-130">예를 들어, <xref:System.Windows.Controls.Button> 단추의 시각적 트리를 효과적으로 확장 하는의 내에 이미지를 놓을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-130">For example, you can place an image inside of a <xref:System.Windows.Controls.Button>, which effectively extends the visual tree of the button.</span></span> <span data-ttu-id="d413a-131">그러나 추가 된 이미지는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 사용자가 기술적으로 이미지의 일부인 픽셀을 클릭 하더라도 단추가 해당 콘텐츠의에 응답 하 게 하는 적중 테스트 동작을 중단 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-131">However, the added image must not break the hit-testing behavior that causes a button to respond to a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> of its content, even if the user clicks on pixels that are technically part of the image.</span></span>

<span data-ttu-id="d413a-132">**단일 처리기 첨부 파일 위치:** Windows Forms 여러 요소에서 발생할 수 있는 이벤트를 처리 하기 위해 동일한 처리기를 여러 번 연결 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-132">**Singular handler attachment points:** In Windows Forms, you would have to attach the same handler multiple times to process events that could be raised from multiple elements.</span></span> <span data-ttu-id="d413a-133">라우트된 이벤트를 사용하면 이전 예제에서 살펴본 것처럼 해당 처리기를 한 번만 연결하고 처리기 논리를 사용하여 필요한 경우 이벤트가 발생한 위치를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-133">Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary.</span></span> <span data-ttu-id="d413a-134">예를 들어 이것은 이전에 표시된 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에 대한 처리기일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-134">For instance, this might be the handler for the previously shown [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]:</span></span>

[!code-csharp[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
[!code-vb[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]

<span data-ttu-id="d413a-135">**클래스 처리:** 라우트된 이벤트는 클래스를 통해 정의된 정적 처리기를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-135">**Class handling:** Routed events permit a static handler that is defined by the class.</span></span> <span data-ttu-id="d413a-136">이 클래스 처리기는 연결된 인스턴스 처리기보다 먼저 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-136">This class handler has the opportunity to handle an event before any attached instance handlers can.</span></span>

<span data-ttu-id="d413a-137">**리플렉션 없이 이벤트 참조:** 특정 코드 및 태그 기술에는 특정 이벤트를 식별하는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-137">**Referencing an event without reflection:** Certain code and markup techniques require a way to identify a specific event.</span></span> <span data-ttu-id="d413a-138">라우트된 이벤트는 필드를 <xref:System.Windows.RoutedEvent> 식별자로 만들며,이를 통해 정적 또는 런타임 리플렉션이 필요 하지 않은 강력한 이벤트 식별 기법을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-138">A routed event creates a <xref:System.Windows.RoutedEvent> field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.</span></span>

### <a name="how-routed-events-are-implemented"></a><span data-ttu-id="d413a-139">라우트된 이벤트를 구현하는 방법</span><span class="sxs-lookup"><span data-stu-id="d413a-139">How Routed Events Are Implemented</span></span>

<span data-ttu-id="d413a-140">라우트된 이벤트는 클래스의 인스턴스에서 지원 되 <xref:System.Windows.RoutedEvent> 고 이벤트 시스템에 등록 된 CLR 이벤트입니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d413a-140">A routed event is a CLR event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="d413a-141"><xref:System.Windows.RoutedEvent>등록에서 가져온 인스턴스는 일반적으로 `public` `static` `readonly` 라우트된 이벤트를 등록 하 고 "소유" 하는 클래스의 필드 멤버로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-141">The <xref:System.Windows.RoutedEvent> instance obtained from registration is typically retained as a `public` `static` `readonly` field member of the class that registers and thus "owns" the routed event.</span></span> <span data-ttu-id="d413a-142">동일 하 게 명명 된 CLR 이벤트 ("래퍼" 이벤트 라고도 함)에 `add` `remove` 대 한 연결은 CLR 이벤트에 대 한 및 구현을 재정의 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-142">The connection to the identically named CLR event (which is sometimes termed the "wrapper" event) is accomplished by overriding the `add` and `remove` implementations for the CLR event.</span></span> <span data-ttu-id="d413a-143">일반적으로 `add` 및 `remove`는 해당 이벤트의 처리기를 추가 및 제거하기 위한 적절한 언어별 이벤트 구문을 사용하는 암시적 기본값으로 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-143">Ordinarily, the `add` and `remove` are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event.</span></span> <span data-ttu-id="d413a-144">라우트된 이벤트 지원 및 연결 메커니즘은 개념적으로 종속성 속성이 클래스에서 지원 되 <xref:System.Windows.DependencyProperty> 고 속성 시스템에 등록 된 CLR 속성인 것과 비슷합니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d413a-144">The routed event backing and connection mechanism is conceptually similar to how a dependency property is a CLR property that is backed by the <xref:System.Windows.DependencyProperty> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span>

<span data-ttu-id="d413a-145">다음 예제에서는 `Tap` 식별자 필드의 등록과 노출 및 <xref:System.Windows.RoutedEvent> `add` `remove` CLR 이벤트에 대 한 및 구현을 포함 하 여 사용자 지정 라우트된 이벤트에 대 한 선언을 보여 줍니다 `Tap` .</span><span class="sxs-lookup"><span data-stu-id="d413a-145">The following example shows the declaration for a custom `Tap` routed event, including the registration and exposure of the <xref:System.Windows.RoutedEvent> identifier field and the `add` and `remove` implementations for the `Tap` CLR event.</span></span>

[!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
[!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]

### <a name="routed-event-handlers-and-xaml"></a><span data-ttu-id="d413a-146">라우트된 이벤트 처리기 및 XAML</span><span class="sxs-lookup"><span data-stu-id="d413a-146">Routed Event Handlers and XAML</span></span>

<span data-ttu-id="d413a-147">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 사용하여 이벤트 처리기를 추가하려면 이벤트 이름을 이벤트 수신기인 요소의 특성으로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-147">To add a handler for an event using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you declare the event name as an attribute on the element that is an event listener.</span></span> <span data-ttu-id="d413a-148">특성 값은 구현된 처리기 메서드의 이름으로, 코드 숨김 파일의 partial 클래스에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-148">The value of the attribute is the name of your implemented handler method, which must exist in the partial class of the code-behind file.</span></span>

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

<span data-ttu-id="d413a-149">라우트된 이벤트 처리기를 추가 하기 위한 구문은 라우트된 이벤트 처리기를 추가 하는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 것과 같습니다. 여기에는 라우트된 이벤트 구현을 포함 하는 clr 이벤트 래퍼에 처리기를 추가 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-149">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax for adding standard CLR event handlers is the same for adding routed event handlers, because you are really adding handlers to the CLR event wrapper, which has a routed event implementation underneath.</span></span> <span data-ttu-id="d413a-150">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]의 이벤트 처리기 추가에 대한 자세한 내용은 [XAML 개요(WPF)](../../../desktop-wpf/fundamentals/xaml.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-150">For more information about adding event handlers in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>

<a name="routing_strategies"></a>

## <a name="routing-strategies"></a><span data-ttu-id="d413a-151">라우트 전략</span><span class="sxs-lookup"><span data-stu-id="d413a-151">Routing Strategies</span></span>

<span data-ttu-id="d413a-152">라우트된 이벤트는 다음 세 가지 라우트 전략 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-152">Routed events use one of three routing strategies:</span></span>

- <span data-ttu-id="d413a-153">**버블링:** 이벤트 소스에서 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-153">**Bubbling:** Event handlers on the event source are invoked.</span></span> <span data-ttu-id="d413a-154">라우트된 이벤트는 요소 트리 루트에 도달할 때까지 다음 부모 요소로 라우트됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-154">The routed event then routes to successive parent elements until reaching the element tree root.</span></span> <span data-ttu-id="d413a-155">대부분의 라우트된 이벤트는 버블링 라우트 전략을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-155">Most routed events use the bubbling routing strategy.</span></span> <span data-ttu-id="d413a-156">버블링 라우트된 이벤트는 일반적으로 개별 컨트롤 또는 기타 UI 요소에서 입력 또는 상태 변경을 보고하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-156">Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.</span></span>

- <span data-ttu-id="d413a-157">**직접:** 소스 요소 자체만 응답으로 처리기를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-157">**Direct:** Only the source element itself is given the opportunity to invoke handlers in response.</span></span> <span data-ttu-id="d413a-158">이는 Windows Forms 이벤트에 사용 하는 "라우팅"과 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-158">This is analogous to the "routing" that Windows Forms uses for events.</span></span> <span data-ttu-id="d413a-159">그러나 표준 CLR 이벤트와는 달리 직접 라우트된 이벤트는 클래스 처리를 지원 합니다. 클래스 처리는 이후 섹션에서 설명 하 고 및에서 사용할 수 있습니다 <xref:System.Windows.EventSetter> <xref:System.Windows.EventTrigger> .</span><span class="sxs-lookup"><span data-stu-id="d413a-159">However, unlike a standard CLR event, direct routed events support class handling (class handling is explained in an upcoming section) and can be used by <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger>.</span></span>

- <span data-ttu-id="d413a-160">**터널링:** 처음에 요소 트리 루트에 있는 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-160">**Tunneling:** Initially, event handlers at the element tree root are invoked.</span></span> <span data-ttu-id="d413a-161">그 다음에 라우트된 이벤트는 경로를 따라 있는 다음 자식 요소를 통해 경로를 이동하여 라우트된 이벤트 소스인 노드 요소(라우트된 이벤트를 발생시킨 요소)를 향합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-161">The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event).</span></span> <span data-ttu-id="d413a-162">터널링 라우트된 이벤트는 보통 컨트롤 합치기의 일부로 사용 또는 처리되므로 복합 부분의 이벤트가 의도적으로 전체 컨트롤에 관련된 이벤트에 의해 억제되거나 대체될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-162">Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control.</span></span> <span data-ttu-id="d413a-163">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 제공된 입력 이벤트는 터널링/버블링 쌍으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-163">Input events provided in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] often come implemented as a tunneling/bubbling pair.</span></span> <span data-ttu-id="d413a-164">쌍에 사용되는 명명 규칙 때문에 터널링 이벤트를 미리 보기 이벤트라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-164">Tunneling events are also sometimes referred to as Preview events, because of a naming convention that is used for the pairs.</span></span>

<a name="why_use"></a>

## <a name="why-use-routed-events"></a><span data-ttu-id="d413a-165">라우트된 이벤트를 사용하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="d413a-165">Why Use Routed Events?</span></span>

<span data-ttu-id="d413a-166">애플리케이션 개발자가 항상 처리 중인 이벤트가 라우트된 이벤트로 구현되는지 알거나 주의할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-166">As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event.</span></span> <span data-ttu-id="d413a-167">라우트된 이벤트에는 특별한 동작이 있지만 이벤트가 발생한 요소에서 해당 이벤트를 처리할 경우 이 동작은 대체로 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-167">Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.</span></span>

<span data-ttu-id="d413a-168">공통 루트에서 공통 처리기 정의, 자체 컨트롤 합치기 또는 자체 사용자 지정 컨트롤 클래스 정의와 같은 제안된 시나리오를 사용할 경우 라우트된 이벤트가 강력해집니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-168">Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.</span></span>

<span data-ttu-id="d413a-169">라우트된 이벤트 수신기와 라우트된 이벤트 소스는 계층 구조에서 공통 이벤트를 공유할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-169">Routed event listeners and routed event sources do not need to share a common event in their hierarchy.</span></span> <span data-ttu-id="d413a-170">모든 <xref:System.Windows.UIElement> 또는는 모든 <xref:System.Windows.ContentElement> 라우트된 이벤트에 대 한 이벤트 수신기 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-170">Any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> can be an event listener for any routed event.</span></span> <span data-ttu-id="d413a-171">따라서 작업 API 집합 전체에서 사용할 수 있는 전체 라우트된 이벤트 집합을 응용 프로그램의 서로 다른 요소가 이벤트 정보를 교환할 수 있는 개념 "인터페이스"로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-171">Therefore, you can use the full set of routed events available throughout the working API set as a conceptual "interface" whereby disparate elements in the application can exchange event information.</span></span> <span data-ttu-id="d413a-172">라우트된 이벤트에 대한 이 “인터페이스” 개념은 특히 입력 이벤트에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-172">This "interface" concept for routed events is particularly applicable for input events.</span></span>

<span data-ttu-id="d413a-173">이벤트에 대한 이벤트 데이터는 경로의 각 요소에 대해 지속되기 때문에 라우트된 이벤트는 요소 트리를 통해 통신하는 데도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-173">Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route.</span></span> <span data-ttu-id="d413a-174">하나의 요소가 이벤트 데이터의 무엇인가를 변경할 수 있고 해당 변경은 경로의 다음 요소에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-174">One element could change something in the event data, and that change would be available to the next element in the route.</span></span>

<span data-ttu-id="d413a-175">라우팅 측면 외에도 지정 된 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트를 표준 CLR 이벤트 대신 라우트된 이벤트로 구현할 수 있는 두 가지 다른 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-175">Other than the routing aspect, there are two other reasons that any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event might be implemented as a routed event instead of a standard CLR event.</span></span> <span data-ttu-id="d413a-176">자체 이벤트를 구현할 경우 다음 원칙을 고려할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-176">If you are implementing your own events, you might also consider these principles:</span></span>

- <span data-ttu-id="d413a-177">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]및와 같은 특정 스타일 지정 및 템플릿 기능을 통해 <xref:System.Windows.EventSetter> <xref:System.Windows.EventTrigger> 참조 되는 이벤트를 라우트된 이벤트로 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-177">Certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] styling and templating features such as <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger> require the referenced event to be a routed event.</span></span> <span data-ttu-id="d413a-178">이는 앞에서 언급한 이벤트 식별자 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-178">This is the event identifier scenario mentioned earlier.</span></span>

- <span data-ttu-id="d413a-179">라우트된 이벤트는 등록된 인스턴스 처리기가 라우트된 이벤트에 액세스하기 전에 클래스가 라우트된 이벤트를 처리할 기회를 가지는 정적 메서드를 지정하는 데 사용될 수 있는 클래스 처리 메커니즘을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-179">Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them.</span></span> <span data-ttu-id="d413a-180">이 메커니즘은 컨트롤 디자인에서 매우 유용합니다. 클래스는 이벤트가 인스턴스에서 처리되어 실수로 억제될 수 있는 이벤트 기반 클래스 동작을 강제 실행할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-180">This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.</span></span>

<span data-ttu-id="d413a-181">위 고려 사항은 각각 이 항목의 개별 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-181">Each of the above considerations is discussed in a separate section of this topic.</span></span>

<a name="event_handing"></a>

## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a><span data-ttu-id="d413a-182">라우트된 이벤트에 대한 이벤트 처리기 추가 및 구현</span><span class="sxs-lookup"><span data-stu-id="d413a-182">Adding and Implementing an Event Handler for a Routed Event</span></span>

<span data-ttu-id="d413a-183">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에서 이벤트 처리기를 추가하려면 이벤트 이름을 요소에 특성으로 추가하고 특성 값을 다음 예제와 같이 적절한 대리자를 구현하는 이벤트 처리기의 이름으로 설정하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-183">To add an event handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.</span></span>

[!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]

<span data-ttu-id="d413a-184">`b1SetColor`이벤트를 처리 하는 코드를 포함 하는 구현 된 처리기의 이름입니다 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> .</span><span class="sxs-lookup"><span data-stu-id="d413a-184">`b1SetColor` is the name of the implemented handler that contains the code that handles the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="d413a-185">`b1SetColor`는 <xref:System.Windows.RoutedEventHandler> 이벤트에 대 한 이벤트 처리기 대리자 인 대리자와 동일한 시그니처를 가져야 합니다 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> .</span><span class="sxs-lookup"><span data-stu-id="d413a-185">`b1SetColor` must have the same signature as the <xref:System.Windows.RoutedEventHandler> delegate, which is the event handler delegate for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="d413a-186">모든 라우트된 이벤트 처리기 대리자의 첫 번째 매개 변수는 이벤트 처리기가 추가되는 요소를 지정하고 두 번째 매개 변수는 이벤트에 대한 데이터를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-186">The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.</span></span>

[!code-csharp[EventOvwSupport#SimpleHandlerA](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]

<span data-ttu-id="d413a-187"><xref:System.Windows.RoutedEventHandler>는 기본 라우트된 이벤트 처리기 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-187"><xref:System.Windows.RoutedEventHandler> is the basic routed event handler delegate.</span></span> <span data-ttu-id="d413a-188">특정 컨트롤 또는 시나리오에 특수화된 라우트된 이벤트의 경우 라우트된 이벤트 처리기에 사용할 대리자는 더 특수화되어 특수화된 이벤트 데이터를 전송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-188">For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data.</span></span> <span data-ttu-id="d413a-189">예를 들어 일반적인 입력 시나리오에서 라우트된 이벤트를 처리할 수 있습니다 <xref:System.Windows.UIElement.DragEnter> .</span><span class="sxs-lookup"><span data-stu-id="d413a-189">For instance, in a common input scenario, you might handle a <xref:System.Windows.UIElement.DragEnter> routed event.</span></span> <span data-ttu-id="d413a-190">처리기에서 대리자를 구현 해야 합니다 <xref:System.Windows.DragEventHandler> .</span><span class="sxs-lookup"><span data-stu-id="d413a-190">Your handler should implement the <xref:System.Windows.DragEventHandler> delegate.</span></span> <span data-ttu-id="d413a-191">가장 구체적인 대리자를 사용 하 여 처리기에서를 처리 <xref:System.Windows.DragEventArgs> 하 고 <xref:System.Windows.DragEventArgs.Data%2A> 끌기 작업의 클립보드 페이로드를 포함 하는 속성을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-191">By using the most specific delegate, you can process the <xref:System.Windows.DragEventArgs> in the handler and read the <xref:System.Windows.DragEventArgs.Data%2A> property, which contains the clipboard payload of the drag operation.</span></span>

<span data-ttu-id="d413a-192">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 사용하여 이벤트 처리기를 요소에 추가하는 방법의 전체 예제를 보려면 [라우트된 이벤트 처리](how-to-handle-a-routed-event.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-192">For a complete example of how to add an event handler to an element using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [Handle a Routed Event](how-to-handle-a-routed-event.md).</span></span>

<span data-ttu-id="d413a-193">코드로 만들어진 애플리케이션에 라우트된 이벤트에 대한 처리기를 추가하는 방법은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-193">Adding a handler for a routed event in an application that is created in code is straightforward.</span></span> <span data-ttu-id="d413a-194">라우트된 이벤트 처리기는 항상 <xref:System.Windows.UIElement.AddHandler%2A> 기존 백업에서 호출 하는 것과 동일한 메서드인 도우미 메서드를 통해 추가할 수 있습니다 `add` . 그러나 기존 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 라우트된 이벤트에는 일반적으로 라우트된 이벤트 `add` `remove` 에 대 한 처리기가 도우미 메서드보다 더 직관적인 구문으로 사용 되는 언어별 이벤트 구문에 의해 추가 될 수 있도록 하는 및 논리의 지원 구현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-194">Routed event handlers can always be added through a helper method <xref:System.Windows.UIElement.AddHandler%2A> (which is the same method that the existing backing calls for `add`.) However, existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events generally have backing implementations of `add` and `remove` logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method.</span></span> <span data-ttu-id="d413a-195">도우미 메서드 사용 예제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-195">The following is an example usage of the helper method:</span></span>

[!code-csharp[EventOvwSupport#AddHandlerCode](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
[!code-vb[EventOvwSupport#AddHandlerCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]

<span data-ttu-id="d413a-196">다음 예제에서는 c # 연산자 Visual Basic 구문을 보여 줍니다. 역참조를 처리 하기 때문에 연산자 구문이 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-196">The next example shows the C# operator syntax (Visual Basic has slightly different operator syntax because of its handling of dereferencing):</span></span>

[!code-csharp[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
[!code-vb[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]

<span data-ttu-id="d413a-197">이벤트 처리기를 코드에 추가하는 방법의 예제를 보려면 [코드를 사용하여 이벤트 처리기 추가](how-to-add-an-event-handler-using-code.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-197">For an example of how to add an event handler in code, see [Add an Event Handler Using Code](how-to-add-an-event-handler-using-code.md).</span></span>

<span data-ttu-id="d413a-198">Visual Basic를 사용 하는 경우 키워드를 사용 하 여 `Handles` 처리기를 처리기 선언의 일부로 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-198">If you are using Visual Basic, you can also use the `Handles` keyword to add handlers as part of the handler declarations.</span></span> <span data-ttu-id="d413a-199">자세한 내용은 [Visual Basic 및 WPF 이벤트 처리](visual-basic-and-wpf-event-handling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-199">For more information, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>

<a name="concept_handled"></a>

### <a name="the-concept-of-handled"></a><span data-ttu-id="d413a-200">Handled 개념</span><span class="sxs-lookup"><span data-stu-id="d413a-200">The Concept of Handled</span></span>

<span data-ttu-id="d413a-201">모든 라우트된 이벤트는 공용 이벤트 데이터 기본 클래스인을 공유 <xref:System.Windows.RoutedEventArgs> 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-201">All routed events share a common event data base class, <xref:System.Windows.RoutedEventArgs>.</span></span> <span data-ttu-id="d413a-202"><xref:System.Windows.RoutedEventArgs><xref:System.Windows.RoutedEventArgs.Handled%2A>부울 값을 사용 하는 속성을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-202"><xref:System.Windows.RoutedEventArgs> defines the <xref:System.Windows.RoutedEventArgs.Handled%2A> property, which takes a Boolean value.</span></span> <span data-ttu-id="d413a-203">속성의 목적은 <xref:System.Windows.RoutedEventArgs.Handled%2A> 의 값을로 설정 하 여 경로를 따라 라우트된 이벤트를 *처리*된 것으로 표시 하는 이벤트 처리기를 사용 하도록 설정 하는 것입니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` .</span><span class="sxs-lookup"><span data-stu-id="d413a-203">The purpose of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is to enable any event handler along the route to mark the routed event as *handled*, by setting the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="d413a-204">경로를 따라 있는 한 요소에 있는 처리기에서 처리된 후 공유된 이벤트 데이터는 다시 경로를 따라 있는 각 수신기에 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-204">After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.</span></span>

<span data-ttu-id="d413a-205">값은 <xref:System.Windows.RoutedEventArgs.Handled%2A> 경로를 따라 추가로 이동할 때 라우트된 이벤트를 보고 하거나 처리 하는 방법에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-205">The value of <xref:System.Windows.RoutedEventArgs.Handled%2A> affects how a routed event is reported or processed as it travels further along the route.</span></span> <span data-ttu-id="d413a-206"><xref:System.Windows.RoutedEventArgs.Handled%2A>가 `true` 라우트된 이벤트에 대 한 이벤트 데이터에 있으면 다른 요소에서 해당 라우트된 이벤트를 수신 하는 처리기는 일반적으로 해당 특정 이벤트 인스턴스에 대해 더 이상 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-206">If <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance.</span></span> <span data-ttu-id="d413a-207">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에서 연결된 처리기 및 `+=` 또는 `Handles`와 같은 언어별 이벤트 처리기 연결 구문을 통해 추가된 처리기에도 이 내용이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-207">This is true both for handlers attached in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and for handlers added by language-specific event handler attachment syntaxes such as `+=` or `Handles`.</span></span> <span data-ttu-id="d413a-208">대부분의 일반적인 처리기 시나리오에서을로 설정 하 여 이벤트를 처리 된 것으로 표시 하면 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` 터널링 경로 또는 버블링 경로에 대 한 라우팅을 "중지" 하 고 클래스 처리기에 의해 경로의 지점에서 처리 되는 모든 이벤트에 대해 "중지" 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-208">For most common handler scenarios, marking an event as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.</span></span>

<span data-ttu-id="d413a-209">그러나 수신기가 <xref:System.Windows.RoutedEventArgs.Handled%2A> 이벤트 데이터에 있는 라우트된 이벤트에 대 한 응답으로 처리기를 계속 실행할 수 있는 "handledEventsToo" 메커니즘이 있습니다 `true` .</span><span class="sxs-lookup"><span data-stu-id="d413a-209">However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data.</span></span> <span data-ttu-id="d413a-210">즉, 이벤트 데이터를 처리됨으로 표시해도 실제로 이벤트 경로는 중지되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-210">In other words, the event route is not truly stopped by marking the event data as handled.</span></span> <span data-ttu-id="d413a-211">코드 또는에서 handledEventsToo 메커니즘도 사용할 수 있습니다 <xref:System.Windows.EventSetter> .</span><span class="sxs-lookup"><span data-stu-id="d413a-211">You can only use the handledEventsToo mechanism in code, or in an <xref:System.Windows.EventSetter>:</span></span>

- <span data-ttu-id="d413a-212">코드에서 일반적인 CLR 이벤트에 대해 작동 하는 언어별 이벤트 구문을 사용 하는 대신 메서드를 호출 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 하 여 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 처리기를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-212">In code, instead of using a language-specific event syntax that works for general CLR events, call the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] method <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> to add your handler.</span></span> <span data-ttu-id="d413a-213">`handledEventsToo` 값을 `true`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-213">Specify the value of `handledEventsToo` as `true`.</span></span>

- <span data-ttu-id="d413a-214">에서 <xref:System.Windows.EventSetter> 특성을로 설정 <xref:System.Windows.EventSetter.HandledEventsToo%2A> `true` 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-214">In an <xref:System.Windows.EventSetter>, set the <xref:System.Windows.EventSetter.HandledEventsToo%2A> attribute to be `true`.</span></span>

<span data-ttu-id="d413a-215"><xref:System.Windows.RoutedEventArgs.Handled%2A>의 개념은 라우트된 이벤트에서 상태가 생성 하는 동작 외에도 <xref:System.Windows.RoutedEventArgs.Handled%2A> 응용 프로그램을 디자인 하 고 이벤트 처리기 코드를 작성 하는 방법에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-215">In addition to the behavior that <xref:System.Windows.RoutedEventArgs.Handled%2A> state produces in routed events, the concept of <xref:System.Windows.RoutedEventArgs.Handled%2A> has implications for how you should design your application and write the event handler code.</span></span> <span data-ttu-id="d413a-216"><xref:System.Windows.RoutedEventArgs.Handled%2A>라우트된 이벤트에 의해 노출 되는 단순한 프로토콜로 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-216">You can conceptualize <xref:System.Windows.RoutedEventArgs.Handled%2A> as being a simple protocol that is exposed by routed events.</span></span> <span data-ttu-id="d413a-217">이 프로토콜을 사용 하는 정확한 방법은 사용자에 게 적합 하지만의 값을 사용 하는 방법에 대 한 개념 디자인은 다음과 같습니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> .</span><span class="sxs-lookup"><span data-stu-id="d413a-217">Exactly how you use this protocol is up to you, but the conceptual design for how the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> is intended to be used is as follows:</span></span>

- <span data-ttu-id="d413a-218">라우트된 이벤트가 처리됨으로 표시되면 해당 경로를 따라 있는 다른 요소가 해당 라우트된 이벤트를 다시 처리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-218">If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.</span></span>

- <span data-ttu-id="d413a-219">라우트된 이벤트가 처리 된 것으로 표시 되지 않은 경우 경로를 따라 이전에 있던 다른 수신기가 처리기를 등록 하지 않거나 등록 된 처리기가 이벤트 데이터를 조작 하 고로 설정 하지 않도록 선택 했습니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` .</span><span class="sxs-lookup"><span data-stu-id="d413a-219">If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="d413a-220">또는 현재 수신기가 경로의 첫 번째 지점이 될 수도 있습니다. 현재 수신기의 처리기에는 다음과 같은 세 가지 가능한 작업 강좌가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-220">(Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action:</span></span>

  - <span data-ttu-id="d413a-221">아무 작업도 수행하지 않습니다. 이벤트는 처리되지 않고 다음 수신기로 라우트됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-221">Take no action at all; the event remains unhandled, and the event routes to the next listener.</span></span>

  - <span data-ttu-id="d413a-222">이벤트에 대한 응답으로 코드를 실행하지만 수행된 작업이 이벤트를 처리됨으로 표시하도록 보장할 만큼 충분히 효과적인지에 대한 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-222">Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled.</span></span> <span data-ttu-id="d413a-223">이벤트는 다음 수신기로 라우트됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-223">The event routes to the next listener.</span></span>

  - <span data-ttu-id="d413a-224">이벤트에 대한 응답으로 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-224">Execute code in response to the event.</span></span> <span data-ttu-id="d413a-225">처리기에 전달된 이벤트 데이터에서 이벤트를 처리됨으로 표시합니다. 이는 수행된 작업이 처리됨으로 표시하도록 보장할 만큼 충분히 효과적이라고 생각되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-225">Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled.</span></span> <span data-ttu-id="d413a-226">이벤트는 계속 해 서 다음 수신기로 라우트 하지만 이벤트 데이터에서를 사용 하 여 <xref:System.Windows.RoutedEventArgs.Handled%2A> = `true` `handledEventsToo` 수신기만 추가 처리기를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-226">The event still routes to the next listener, but with <xref:System.Windows.RoutedEventArgs.Handled%2A>=`true` in its event data, so only `handledEventsToo` listeners have the opportunity to invoke further handlers.</span></span>

<span data-ttu-id="d413a-227">이 개념 디자인은 앞에서 언급 한 라우팅 동작에 의해 강화 됩니다. 경로를 따르는 이전 처리기가 이미로 설정 되어 있는 경우에도 호출 되는 라우트된 이벤트에 대 한 처리기를 연결 하는 것이 더 어렵거나 (코드 또는 스타일 에서도 가능 합니다.) <xref:System.Windows.RoutedEventArgs.Handled%2A> `true`</span><span class="sxs-lookup"><span data-stu-id="d413a-227">This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span>

<span data-ttu-id="d413a-228">에 대 한 자세한 내용, 라우트된 이벤트 <xref:System.Windows.RoutedEventArgs.Handled%2A> 의 클래스 처리 및 라우트된 이벤트를로 표시 하는 것이 적절 한 경우에 대 한 권장 사항은 <xref:System.Windows.RoutedEventArgs.Handled%2A> [라우트된 이벤트를 처리 된 것으로 표시 및 클래스 처리](marking-routed-events-as-handled-and-class-handling.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-228">For more information about <xref:System.Windows.RoutedEventArgs.Handled%2A>, class handling of routed events, and recommendations about when it is appropriate to mark a routed event as <xref:System.Windows.RoutedEventArgs.Handled%2A>, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="d413a-229">애플리케이션에서는 일반적으로 버블링 라우트된 이벤트를 발생시킨 개체에서 이 이벤트를 처리하며 이벤트의 라우트 특징은 전혀 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-229">In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all.</span></span> <span data-ttu-id="d413a-230">하지만 요소 트리에서 더 위쪽에 있는 요소에 같은 라우트된 이벤트에 대한 연결된 처리기가 있는 경우 예기치 않은 부작용을 방지하기 위해 이벤트 데이터에서는 라우트된 이벤트를 처리됨으로 표시하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-230">However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.</span></span>

<a name="class_handlers"></a>

## <a name="class-handlers"></a><span data-ttu-id="d413a-231">클래스 처리기</span><span class="sxs-lookup"><span data-stu-id="d413a-231">Class Handlers</span></span>

<span data-ttu-id="d413a-232">에서 파생 되는 클래스를 정의 하는 경우 <xref:System.Windows.DependencyObject> 클래스의 선언 되거나 상속 된 이벤트 멤버인 라우트된 이벤트에 대 한 클래스 처리기를 정의 하 고 연결할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-232">If you are defining a class that derives in some way from <xref:System.Windows.DependencyObject>, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class.</span></span> <span data-ttu-id="d413a-233">라우트된 이벤트가 경로의 요소 인스턴스에 도달할 때마다 클래스 처리기는 해당 클래스의 인스턴스에 연결된 인스턴스 수신기 처리기보다 먼저 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-233">Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.</span></span>

<span data-ttu-id="d413a-234">일부 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 컨트롤에는 특정 라우트된 이벤트에 대한 고유 클래스 처리 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-234">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have inherent class handling for certain routed events.</span></span> <span data-ttu-id="d413a-235">이 기능을 사용하면 표면적으로는 라우트된 이벤트가 발생하지 않은 것처럼 보이지만 실제로는 클래스가 처리되는 것이고 특정 기술을 사용하면 라우트된 이벤트가 인스턴스 처리기에서 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-235">This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques.</span></span> <span data-ttu-id="d413a-236">또한 많은 기본 클래스 및 컨트롤이 클래스 처리 동작을 재정의하는 데 사용될 수 있는 가상 메서드를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-236">Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.</span></span> <span data-ttu-id="d413a-237">원하지 않는 클래스 처리를 해결하는 방법 및 사용자 지정 클래스에서 자체 클래스 처리를 정의하는 방법에 대한 자세한 내용은 [라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리](marking-routed-events-as-handled-and-class-handling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-237">For more information both on how to work around undesired class handling and on defining your own class handling in a custom class, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<a name="attached_events"></a>

## <a name="attached-events-in-wpf"></a><span data-ttu-id="d413a-238">WPF의 연결된 이벤트</span><span class="sxs-lookup"><span data-stu-id="d413a-238">Attached Events in WPF</span></span>

<span data-ttu-id="d413a-239">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 언어는 *연결된 이벤트*라는 특수 이벤트 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-239">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] language also defines a special type of event called an *attached event*.</span></span> <span data-ttu-id="d413a-240">연결된 이벤트를 사용하여 특정 이벤트에 대한 처리기를 임의 요소에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-240">An attached event enables you to add a handler for a particular event to an arbitrary element.</span></span> <span data-ttu-id="d413a-241">이벤트를 처리하는 요소는 연결된 이벤트를 정의하거나 상속할 필요가 없고 이벤트를 발생시키는 개체 및 인스턴스를 처리하는 대상은 모두 해당 이벤트를 클래스 멤버로 정의하거나 소유하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-241">The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.</span></span>

<span data-ttu-id="d413a-242">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 입력 시스템은 연결된 이벤트를 광범위하게 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-242">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input system uses attached events extensively.</span></span> <span data-ttu-id="d413a-243">하지만 이러한 연결된 이벤트는 거의 모두 기본 요소를 통해 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-243">However, nearly all of these attached events are forwarded through base elements.</span></span> <span data-ttu-id="d413a-244">그 다음에 입력 이벤트는 기본 요소 클래스의 멤버인 해당하는 연결되지 않은 라우트된 이벤트로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-244">The input events then appear as equivalent non-attached routed events that are members of the base element class.</span></span> <span data-ttu-id="d413a-245">예를 들어 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> <xref:System.Windows.UIElement> <xref:System.Windows.UIElement.MouseDown> <xref:System.Windows.UIElement> 또는 코드에서 연결 된 이벤트 구문을 처리 하는 대신를 사용 하 여 지정 된에서 기본 연결 된 이벤트를 보다 쉽게 처리할 수 있습니다 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d413a-245">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="d413a-246">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 연결된 이벤트에 대한 자세한 내용은 [연결된 이벤트 개요](attached-events-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-246">For more information about attached events in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Attached Events Overview](attached-events-overview.md).</span></span>

<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>

## <a name="qualified-event-names-in-xaml"></a><span data-ttu-id="d413a-247">XAML의 정규화된 이벤트 이름</span><span class="sxs-lookup"><span data-stu-id="d413a-247">Qualified Event Names in XAML</span></span>

<span data-ttu-id="d413a-248">*typename*.*eventname* 연결된 이벤트 구문과 비슷하지만 엄격히 말하면 연결된 이벤트 사용이 아닌 또 다른 구문 사용은 자식 요소에서 발생한 라우트된 이벤트에 대한 처리기를 연결하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-248">Another syntax usage that resembles *typename*.*eventname* attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements.</span></span> <span data-ttu-id="d413a-249">공통 부모에 관련 라우트된 이벤트가 멤버로 포함되지 않더라도 처리기를 공통 부모에 연결하면 이벤트 라우트를 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-249">You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member.</span></span> <span data-ttu-id="d413a-250">이 예제를 다시 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-250">Consider this example again:</span></span>

[!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]

<span data-ttu-id="d413a-251">여기서 처리기가 추가 되는 부모 요소 수신기는 <xref:System.Windows.Controls.StackPanel> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-251">Here, the parent element listener where the handler is added is a <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="d413a-252">그러나 선언 되었으며 클래스에서 발생 하는 라우트된 이벤트에 대 한 처리기를 추가 하는 것입니다 <xref:System.Windows.Controls.Button> ( <xref:System.Windows.Controls.Primitives.ButtonBase> 실제로는 이지만 상속을 통해 사용 가능 <xref:System.Windows.Controls.Button> ).</span><span class="sxs-lookup"><span data-stu-id="d413a-252">However, it is adding a handler for a routed event that was declared and will be raised by the <xref:System.Windows.Controls.Button> class (<xref:System.Windows.Controls.Primitives.ButtonBase> actually, but available to <xref:System.Windows.Controls.Button> through inheritance).</span></span> <span data-ttu-id="d413a-253"><xref:System.Windows.Controls.Button>이벤트를 "소유" 하지만 라우트된 이벤트 시스템은 라우트된 모든 이벤트에 대 한 처리기를 <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> CLR (공용 언어 런타임) 이벤트에 대 한 수신기를 연결할 수 있는 모든 또는 인스턴스 수신기에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-253"><xref:System.Windows.Controls.Button> "owns" the event, but the routed event system permits handlers for any routed event to be attached to any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> instance listener that could otherwise attach listeners for a common language runtime (CLR) event.</span></span> <span data-ttu-id="d413a-254">일반적으로 이러한 정규화된 이벤트 특성 이름에 대한 기본 xmlns 네임스페이스는 기본 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns 네임스페이스이지만 사용자 지정 라우트된 이벤트에 대한 접두사가 추가된 네임스페이스를 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-254">The default xmlns namespace for these qualified event attribute names is typically the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns namespace, but you can also specify prefixed namespaces for custom routed events.</span></span> <span data-ttu-id="d413a-255">xmlns에 대한 자세한 내용은 [WPF XAML을 위한 XAML 네임스페이스 및 네임스페이스 매핑](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-255">For more information about xmlns, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>

<a name="how_event_processing_works"></a>

## <a name="wpf-input-events"></a><span data-ttu-id="d413a-256">WPF 입력 이벤트</span><span class="sxs-lookup"><span data-stu-id="d413a-256">WPF Input Events</span></span>

<span data-ttu-id="d413a-257">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 플랫폼 내에서 라우트된 이벤트가 자주 사용되는 한 가지 애플리케이션은 입력 이벤트와 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-257">One frequent application of routed events within the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] platform is for input events.</span></span> <span data-ttu-id="d413a-258">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 터널링 라우트된 이벤트에는 규칙에 따라 "Preview"라는 단어가 접두사로 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-258">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], tunneling routed events names are prefixed with the word "Preview" by convention.</span></span> <span data-ttu-id="d413a-259">입력 이벤트는 보통 쌍으로 제공되고, 쌍 중 하나는 버블링 이벤트가 되고 다른 하나는 터널링 이벤트가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-259">Input events often come in pairs, with one being the bubbling event and the other being the tunneling event.</span></span> <span data-ttu-id="d413a-260">예를 들어 <xref:System.Windows.ContentElement.KeyDown> 이벤트와 이벤트는 <xref:System.Windows.ContentElement.PreviewKeyDown> 동일한 서명을 가지 며, 이전에는 버블링 입력 이벤트로, 후자는 터널링 입력 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-260">For example, the <xref:System.Windows.ContentElement.KeyDown> event and the <xref:System.Windows.ContentElement.PreviewKeyDown> event have the same signature, with the former being the bubbling input event and the latter being the tunneling input event.</span></span> <span data-ttu-id="d413a-261">입력 이벤트에 버블링 버전만 포함되거나 직접 라우트된 버전만 포함되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-261">Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.</span></span> <span data-ttu-id="d413a-262">문서의 라우트된 이벤트 항목에서는 라우트된 이벤트가 있는 경우 대체 라우트 전략을 통해 비슷한 라우트된 이벤트를 상호 참조하고 관리되는 참조 페이지의 섹션에서는 각 라우트된 이벤트의 라우트 전략을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-262">In the documentation, routed event topics cross-reference similar routed events with alternative routing strategies if such routed events exist, and sections in the managed reference pages clarify the routing strategy of each routed event.</span></span>

<span data-ttu-id="d413a-263">쌍으로 제공되는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 입력 이벤트는 마우스 단추 누르기와 같은 입력의 단일 사용자 작업이 해당 쌍의 라우트된 이벤트를 둘 다 순차적으로 발생시키도록 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-263">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence.</span></span> <span data-ttu-id="d413a-264">먼저 터널링 이벤트가 발생하고 경로를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-264">First, the tunneling event is raised and travels its route.</span></span> <span data-ttu-id="d413a-265">그 다음에 버블링 이벤트가 발생하고 경로를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-265">Then the bubbling event is raised and travels its route.</span></span> <span data-ttu-id="d413a-266"><xref:System.Windows.UIElement.RaiseEvent%2A>버블링 이벤트를 발생 시키는 구현 클래스의 메서드 호출은 터널링 이벤트에서 이벤트 데이터를 수신 하 고 새 발생 이벤트에서 다시 사용할 수 있기 때문에 두 이벤트는 동일한 이벤트 데이터 인스턴스를 그대로 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-266">The two events literally share the same event data instance, because the <xref:System.Windows.UIElement.RaiseEvent%2A> method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event.</span></span> <span data-ttu-id="d413a-267">터널링 이벤트에 대한 처리기가 있는 수신기는 우선적으로 라우트된 이벤트를 처리됨으로 표시할 수 있습니다(클래스 처리기 우선, 그 다음에 인스턴스 처리기).</span><span class="sxs-lookup"><span data-stu-id="d413a-267">Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers).</span></span> <span data-ttu-id="d413a-268">터널링 경로에 따라 있는 요소가 라우트된 이벤트를 처리됨으로 표시한 경우 버블링 이벤트에 대한 이미 처리된 이벤트 데이터가 전송되고 해당하는 버블링 입력 이벤트에 대한 일반 연결된 처리기는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-268">If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked.</span></span> <span data-ttu-id="d413a-269">표면적으로는 처리된 버블링 이벤트가 발생하지 않은 경우처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-269">To outward appearances it will be as if the handled bubbling event has not even been raised.</span></span> <span data-ttu-id="d413a-270">이 처리 동작은 컨트롤 합치기에 유용합니다. 이 경우 모든 적중 테스트 기반 입력 이벤트나 포커스 기반 입력 이벤트를 복합 부분이 아닌 최종 컨트롤이 보고하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-270">This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts.</span></span> <span data-ttu-id="d413a-271">최종 컨트롤 요소는 합치기에서 루트에 더 근접하므로 터널링 이벤트를 먼저 클래스에서 처리하고 라우트된 이벤트를 컨트롤에 대한 관련성이 더 높은 이벤트(컨트롤 클래스를 지원하는 코드의 일부)로 “대체”할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-271">The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.</span></span>

<span data-ttu-id="d413a-272">입력 이벤트 처리가 적용되는 방식에 대한 그림으로 다음 입력 이벤트 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-272">As an illustration of how input event processing works, consider the following input event example.</span></span> <span data-ttu-id="d413a-273">다음 트리 그림에서는 `leaf element #2` 와 이벤트의 소스입니다 `PreviewMouseDown` `MouseDown` .</span><span class="sxs-lookup"><span data-stu-id="d413a-273">In the following tree illustration, `leaf element #2` is the source of both a `PreviewMouseDown` and then a `MouseDown` event:</span></span>

![이벤트 라우팅 다이어그램](./media/routed-events-overview/input-event-routing.png)

<span data-ttu-id="d413a-275">이벤트 처리 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-275">The order of event processing is as follows:</span></span>

1. <span data-ttu-id="d413a-276">루트 요소의 `PreviewMouseDown`(터널링).</span><span class="sxs-lookup"><span data-stu-id="d413a-276">`PreviewMouseDown` (tunnel) on root element.</span></span>

2. <span data-ttu-id="d413a-277">중간 요소 #1의 `PreviewMouseDown`(터널링).</span><span class="sxs-lookup"><span data-stu-id="d413a-277">`PreviewMouseDown` (tunnel) on intermediate element #1.</span></span>

3. <span data-ttu-id="d413a-278">소스 요소 #2의 `PreviewMouseDown`(터널링).</span><span class="sxs-lookup"><span data-stu-id="d413a-278">`PreviewMouseDown` (tunnel) on source element #2.</span></span>

4. <span data-ttu-id="d413a-279">소스 요소 #2의 `MouseDown`(버블링).</span><span class="sxs-lookup"><span data-stu-id="d413a-279">`MouseDown` (bubble) on source element #2.</span></span>

5. <span data-ttu-id="d413a-280">중간 요소 #1의 `MouseDown`(버블링).</span><span class="sxs-lookup"><span data-stu-id="d413a-280">`MouseDown` (bubble) on intermediate element #1.</span></span>

6. <span data-ttu-id="d413a-281">루트 요소의 `MouseDown`(버블링).</span><span class="sxs-lookup"><span data-stu-id="d413a-281">`MouseDown` (bubble) on root element.</span></span>

<span data-ttu-id="d413a-282">라우트된 이벤트 처리기 대리자는 두 개체인, 이벤트를 발생시킨 개체 및 처리기가 호출된 개체에 대한 참조를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-282">A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked.</span></span> <span data-ttu-id="d413a-283">처리기가 호출된 개체는 `sender` 매개 변수를 통해 보고된 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-283">The object where the handler was invoked is the object reported by the `sender` parameter.</span></span> <span data-ttu-id="d413a-284">이벤트가 처음 발생 한 개체는 <xref:System.Windows.RoutedEventArgs.Source%2A> 이벤트 데이터의 속성에 의해 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-284">The object where the event was first raised is reported by the <xref:System.Windows.RoutedEventArgs.Source%2A> property in the event data.</span></span> <span data-ttu-id="d413a-285">라우트된 이벤트는 같은 개체에서 계속 발생 하 고 처리할 수 있습니다 `sender` <xref:System.Windows.RoutedEventArgs.Source%2A> .이 경우 및는 동일 합니다 (이벤트 처리 예제 목록에서 3 단계 및 4 단계를 사용 하는 경우).</span><span class="sxs-lookup"><span data-stu-id="d413a-285">A routed event can still be raised and handled by the same object, in which case `sender` and <xref:System.Windows.RoutedEventArgs.Source%2A> are identical (this is the case with Steps 3 and 4 in the event processing example list).</span></span>

<span data-ttu-id="d413a-286">터널링 및 버블링으로 인해 부모 요소는 <xref:System.Windows.RoutedEventArgs.Source%2A> 이 자식 요소 중 하나인 입력 이벤트를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-286">Because of tunneling and bubbling, parent elements receive input events where the <xref:System.Windows.RoutedEventArgs.Source%2A> is one of their child elements.</span></span> <span data-ttu-id="d413a-287">원본 요소를 파악 하는 것이 중요 한 경우 속성에 액세스 하 여 원본 요소를 식별할 수 있습니다 <xref:System.Windows.RoutedEventArgs.Source%2A> .</span><span class="sxs-lookup"><span data-stu-id="d413a-287">When it is important to know what the source element is, you can identify the source element by accessing the <xref:System.Windows.RoutedEventArgs.Source%2A> property.</span></span>

<span data-ttu-id="d413a-288">일반적으로 입력 이벤트가 표시 되 면 <xref:System.Windows.RoutedEventArgs.Handled%2A> 추가 처리기가 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-288">Usually, once the input event is marked <xref:System.Windows.RoutedEventArgs.Handled%2A>, further handlers are not invoked.</span></span> <span data-ttu-id="d413a-289">보통은 입력 이벤트의 의미에 대한 애플리케이션별 논리 처리를 해결하는 처리기가 호출된 후 바로 입력 이벤트를 처리됨으로 표시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-289">Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.</span></span>

<span data-ttu-id="d413a-290">상태에 대 한이 일반적인 문의 예외는 <xref:System.Windows.RoutedEventArgs.Handled%2A> 이벤트 데이터의 상태를 의도적으로 무시 하도록 등록 된 입력 이벤트 처리기가 <xref:System.Windows.RoutedEventArgs.Handled%2A> 경로를 따라 계속 호출 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-290">The exception to this general statement about <xref:System.Windows.RoutedEventArgs.Handled%2A> state is that input event handlers that are registered to deliberately ignore <xref:System.Windows.RoutedEventArgs.Handled%2A> state of the event data would still be invoked along either route.</span></span> <span data-ttu-id="d413a-291">자세한 내용은 [미리 보기 이벤트](preview-events.md) 또는 [라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리](marking-routed-events-as-handled-and-class-handling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-291">For more information, see [Preview Events](preview-events.md) or [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="d413a-292">터널링 이벤트와 버블링 이벤트 간에 공유된 이벤트 데이터 모델과 터널링 이벤트 다음에 버블링 이벤트가 발생하는 순차적 발생은 일반적으로 모든 라우트된 이벤트에 적용되는 개념이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-292">The shared event data model between tunneling and bubbling events, and the sequential raising of first tunneling then bubbling events, is not a concept that is generally true for all routed events.</span></span> <span data-ttu-id="d413a-293">이 동작은 특별히 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 입력 디바이스가 입력 이벤트 쌍을 발생시키고 연결하도록 선택하는 방법을 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-293">That behavior is specifically implemented by how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input devices choose to raise and connect the input event pairs.</span></span> <span data-ttu-id="d413a-294">자체 입력 이벤트를 구현하는 것은 고급 시나리오이지만 자체 입력 이벤트에 대해 해당 모델을 따르도록 선택할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-294">Implementing your own input events is an advanced scenario, but you might choose to follow that model for your own input events also.</span></span>

<span data-ttu-id="d413a-295">특정 클래스는 대개 특정 사용자 기반 입력 이벤트가 해당 컨트롤 내에서 가지는 의미를 다시 정의하고 새 이벤트를 발생시키기 위해 특정 입력 이벤트를 클래스에서 처리하도록 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-295">Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.</span></span> <span data-ttu-id="d413a-296">자세한 내용은 [라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리](marking-routed-events-as-handled-and-class-handling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-296">For more information, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>

<span data-ttu-id="d413a-297">입력 및 입력과 이벤트가 일반적인 애플리케이션 시나리오에서 상호 작용하는 방식에 대한 자세한 내용은 [입력 개요](input-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-297">For more information on input and how input and events interact in typical application scenarios, see [Input Overview](input-overview.md).</span></span>

<a name="events_styles"></a>

## <a name="eventsetters-and-eventtriggers"></a><span data-ttu-id="d413a-298">EventSetter 및 EventTrigger</span><span class="sxs-lookup"><span data-stu-id="d413a-298">EventSetters and EventTriggers</span></span>

<span data-ttu-id="d413a-299">스타일에서를 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 사용 하 여 태그에 미리 선언 된 이벤트 처리 구문을 포함할 수 있습니다 <xref:System.Windows.EventSetter> .</span><span class="sxs-lookup"><span data-stu-id="d413a-299">In styles, you can include some pre-declared [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] event handling syntax in the markup by using an <xref:System.Windows.EventSetter>.</span></span> <span data-ttu-id="d413a-300">스타일이 적용되면 참조된 처리기가 스타일 지정된 인스턴스에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-300">When the style is applied, the referenced handler is added to the styled instance.</span></span> <span data-ttu-id="d413a-301">라우트된 이벤트에 대해서만를 선언할 수 있습니다 <xref:System.Windows.EventSetter> .</span><span class="sxs-lookup"><span data-stu-id="d413a-301">You can declare an <xref:System.Windows.EventSetter> only for a routed event.</span></span> <span data-ttu-id="d413a-302">다음은 이에 대한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-302">The following is an example.</span></span> <span data-ttu-id="d413a-303">여기서 참조되는 `b1SetColor` 메서드는 코드 숨김 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-303">Note that the `b1SetColor` method referenced here is in a code-behind file.</span></span>

[!code-xaml[EventOvwSupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]

<span data-ttu-id="d413a-304">여기에서 얻을 수 있는 이점은 응용 프로그램의 모든 단추에 적용 될 수 있는 다양 한 정보를 스타일에 포함할 수 있고 해당 <xref:System.Windows.EventSetter> 스타일의 일부가 되도록 하면 태그 수준 에서도 코드 재사용을 촉진 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-304">The advantage gained here is that the style is likely to contain a great deal of other information that could apply to any button in your application, and having the <xref:System.Windows.EventSetter> be part of that style promotes code reuse even at the markup level.</span></span> <span data-ttu-id="d413a-305">또한 <xref:System.Windows.EventSetter> 처리기에 대 한 메서드 이름이 일반 응용 프로그램 및 페이지 태그에서 한 단계 더 멀리 떨어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-305">Also, an <xref:System.Windows.EventSetter> abstracts method names for handlers one step further away from the general application and page markup.</span></span>

<span data-ttu-id="d413a-306">의 라우트된 이벤트와 애니메이션 기능을 결합 하는 또 다른 특수화 된 구문은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.EventTrigger> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-306">Another specialized syntax that combines the routed event and animation features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="d413a-307">와 마찬가지로 <xref:System.Windows.EventSetter> 라우트된 이벤트만에 사용 될 수 있습니다 <xref:System.Windows.EventTrigger> .</span><span class="sxs-lookup"><span data-stu-id="d413a-307">As with <xref:System.Windows.EventSetter>, only routed events may be used for an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="d413a-308">일반적으로는 <xref:System.Windows.EventTrigger> 스타일의 일부로 선언 되지만는 <xref:System.Windows.EventTrigger> 페이지 수준 요소에 대해 컬렉션의 일부로 선언 하거나에서 선언할 수도 있습니다 <xref:System.Windows.FrameworkElement.Triggers%2A> <xref:System.Windows.Controls.ControlTemplate> .</span><span class="sxs-lookup"><span data-stu-id="d413a-308">Typically, an <xref:System.Windows.EventTrigger> is declared as part of a style, but an <xref:System.Windows.EventTrigger> can also be declared on page-level elements as part of the <xref:System.Windows.FrameworkElement.Triggers%2A> collection, or in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="d413a-309">를 <xref:System.Windows.EventTrigger> 사용 하면 <xref:System.Windows.Media.Animation.Storyboard> 라우트된 이벤트가 해당 이벤트에 대해를 선언 하는 해당 경로에 있는 요소에 도달할 때마다 실행 되는를 지정할 수 있습니다 <xref:System.Windows.EventTrigger> .</span><span class="sxs-lookup"><span data-stu-id="d413a-309">An <xref:System.Windows.EventTrigger> enables you to specify a <xref:System.Windows.Media.Animation.Storyboard> that runs whenever a routed event reaches an element in its route that declares an <xref:System.Windows.EventTrigger> for that event.</span></span> <span data-ttu-id="d413a-310">는 <xref:System.Windows.EventTrigger> 이벤트를 처리 하 고 기존 storyboard를 시작 하도록 하는 것에 비해는 <xref:System.Windows.EventTrigger> 스토리 보드 및 해당 런타임 동작에 대 한 보다 효율적인 제어를 제공 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-310">The advantage of an <xref:System.Windows.EventTrigger> over just handling the event and causing it to start an existing storyboard is that an <xref:System.Windows.EventTrigger> provides better control over the storyboard and its run-time behavior.</span></span> <span data-ttu-id="d413a-311">자세한 내용은 [Storyboard를 시작한 후 이벤트 트리거를 사용하여 제어](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-311">For more information, see [Use Event Triggers to Control a Storyboard After It Starts](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).</span></span>

<a name="more_about"></a>

## <a name="more-about-routed-events"></a><span data-ttu-id="d413a-312">라우트된 이벤트에 대한 추가 정보</span><span class="sxs-lookup"><span data-stu-id="d413a-312">More About Routed Events</span></span>

<span data-ttu-id="d413a-313">이 항목에서는 기본 개념을 설명하고 다양한 기본 요소 및 컨트롤에 이미 있는 라우트된 이벤트에 응답하는 방법 및 시점에 대한 지침을 제공하는 관점에서 주로 라우트된 이벤트를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-313">This topic mainly discusses routed events from the perspective of describing the basic concepts and offering guidance on how and when to respond to the routed events that are already present in the various base elements and controls.</span></span> <span data-ttu-id="d413a-314">하지만 특수화된 이벤트 데이터 클래스 및 대리자와 같은 모든 필요한 지원과 함께 사용자 지정 클래스에서 자체 라우트된 이벤트를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-314">However, you can create your own routed event on your custom class along with all the necessary support, such as specialized event data classes and delegates.</span></span> <span data-ttu-id="d413a-315">라우트된 이벤트 소유자는 모든 클래스가 될 수 있지만, 라우트된 이벤트는에 의해 발생 하 고 또는 파생 클래스에 의해 처리 되어야 <xref:System.Windows.UIElement> <xref:System.Windows.ContentElement> 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d413a-315">The routed event owner can be any class, but routed events must be raised by and handled by <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> derived classes in order to be useful.</span></span> <span data-ttu-id="d413a-316">사용자 지정 이벤트에 대한 자세한 내용은 [사용자 지정 라우트된 이벤트 만들기](how-to-create-a-custom-routed-event.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d413a-316">For more information about custom events, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d413a-317">참고 항목</span><span class="sxs-lookup"><span data-stu-id="d413a-317">See also</span></span>

- <xref:System.Windows.EventManager>
- <xref:System.Windows.RoutedEvent>
- <xref:System.Windows.RoutedEventArgs>
- [<span data-ttu-id="d413a-318">라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리</span><span class="sxs-lookup"><span data-stu-id="d413a-318">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="d413a-319">입력 개요</span><span class="sxs-lookup"><span data-stu-id="d413a-319">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="d413a-320">명령 개요</span><span class="sxs-lookup"><span data-stu-id="d413a-320">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="d413a-321">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d413a-321">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="d413a-322">WPF의 트리</span><span class="sxs-lookup"><span data-stu-id="d413a-322">Trees in WPF</span></span>](trees-in-wpf.md)
- [<span data-ttu-id="d413a-323">약한 이벤트 패턴</span><span class="sxs-lookup"><span data-stu-id="d413a-323">Weak Event Patterns</span></span>](weak-event-patterns.md)
