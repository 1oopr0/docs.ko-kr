---
title: 스레딩 모델
description: Windows Presentation Foundation 응용 프로그램에서 여러 스레드가 필요할 수 있는 상황에 대해 알아봅니다. 단일 스레드 솔루션을 선호 합니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9b67b6ea2896e9e6fec57dee8d1013d54fab03fc
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87166379"
---
# <a name="threading-model"></a><span data-ttu-id="75352-104">스레딩 모델</span><span class="sxs-lookup"><span data-stu-id="75352-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="75352-105">는 개발자가 스레딩의 어려움을 해결하도록 디자인되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="75352-106">결과적으로 대부분의 개발자는 둘 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이상의 스레드를 사용 하는 인터페이스를 작성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="75352-107">다중 스레드 프로그램은 복잡하고 디버그하기 어려우므로 단일 스레드 솔루션이 있을 경우 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="75352-108">그러나 아키텍처는 잘 설계 된 방법에 관계 없이 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 모든 종류의 문제에 대해 단일 스레드 솔루션을 제공할 수 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="75352-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="75352-109">는 가까이 있지만 여러 스레드가 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 응답성 또는 응용 프로그램 성능을 향상 시키는 경우는 여전히 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="75352-110">일부 배경 자료를 설명한 후 이 문서에서는 이러한 상황 중 일부를 살펴보고 몇몇 하위 수준 세부 정보에 대한 설명으로 마무리 짓습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="75352-111">이 항목에서는 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 비동기 호출에 대 한 메서드를 사용 하 여 스레딩을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="75352-112"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> <xref:System.Action> 또는를 매개 변수로 사용 하는 메서드를 호출 하 여 비동기 호출을 수행할 수도 있습니다 <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="75352-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="75352-113"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>메서드는 <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperation%601> 속성을 포함 하는 또는를 반환 합니다 <xref:System.Windows.Threading.DispatcherOperation.Task%2A> .</span><span class="sxs-lookup"><span data-stu-id="75352-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="75352-114">`await`키워드는 또는 연결 된와 함께 사용할 수 있습니다 <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="75352-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="75352-115">또는에서 반환 된에 대해 동기적으로 대기 해야 하는 경우 <xref:System.Threading.Tasks.Task> <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperation%601> 확장 메서드를 호출 <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="75352-116"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>를 호출 하면 교착 상태가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="75352-117">를 사용 하 여 비동기 작업을 수행 하는 방법에 대 한 자세한 내용은 <xref:System.Threading.Tasks.Task> 작업 병렬 처리를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="75352-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="75352-118"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>또한 메서드는 <xref:System.Action> 또는를 매개 변수로 사용 하는 오버 로드를 포함 합니다 <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="75352-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="75352-119">메서드를 사용 하 여 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 대리자를 전달 하거나를 전달 하 여 동기 호출을 수행할 수 있습니다 <xref:System.Action> <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="75352-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="75352-120">개요 및 디스패처</span><span class="sxs-lookup"><span data-stu-id="75352-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="75352-121">일반적으로 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램은 두 개의 스레드로 시작 합니다. 하나는 렌더링을 처리 하 고 다른 하나는를 관리 하기 위한 것 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="75352-122">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]스레드가 입력을 수신 하 고, 이벤트를 처리 하 고, 화면을 칠하고, 응용 프로그램 코드를 실행 하는 동안 렌더링 스레드가 효과적으로 백그라운드에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="75352-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="75352-123">대부분의 응용 프로그램은 단일 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드를 사용 하지만 일부 경우에는 여러 가지 상황에서 사용 하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="75352-124">나중에 예제를 통해 이를 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="75352-125">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]스레드는 라는 개체 내에서 작업 항목을 큐에 대기 시킵니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-125">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="75352-126"><xref:System.Windows.Threading.Dispatcher>는 우선 순위에 따라 작업 항목을 선택하고 각 작업 항목을 완료할 때까지 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="75352-127">모든 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드에는가 하나 이상 있어야 <xref:System.Windows.Threading.Dispatcher> 하 고, 각 스레드에는 <xref:System.Windows.Threading.Dispatcher> 정확히 하나의 스레드에서 작업 항목을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-127">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="75352-128">응답성이 뛰어난 사용자에 게 친숙 한 응용 프로그램을 작성 하는 방법은 <xref:System.Windows.Threading.Dispatcher> 작업 항목을 작게 유지 하 여 처리량을 최대화 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="75352-129">이러한 방식으로 항목이 처리를 대기 하는 동안에는 부실 하지 않습니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="75352-130">입력과 응답 간의 인식할 수 있는 지연으로 인해 사용자가 불편해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="75352-131">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]응용 프로그램에서 큰 작업을 처리 하는 방법은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="75352-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="75352-132">코드에 큰 계산을 포함하거나 몇몇 원격 서버에서 데이터베이스를 쿼리해야 하면 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="75352-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="75352-133">일반적으로는 별도의 스레드에서 큰 작업을 처리 하는 것이 좋습니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] . 스레드는 큐에 있는 항목을 사용 하지 않는 상태로 유지 됩니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="75352-134">큰 작업이 완료 되 면 표시를 위해 결과를 다시 스레드에 보고할 수 있습니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="75352-135">지금까지 Windows는 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 요소를 만든 스레드에서만 요소에 액세스할 수 있도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="75352-136">즉, 일부 장기 실행 작업을 처리하는 백그라운드 스레드는 작업이 완료될 때 입력란을 업데이트할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="75352-137">Windows에서는 구성 요소의 무결성을 보장 하기 위해이를 수행 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="75352-138">목록 상자의 콘텐츠가 그리는 동안 백그라운드 스레드를 통해 업데이트되면 목록 상자가 이상하게 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="75352-139">에는 이 조정을 적용하는 기본 제공 상호 배제 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="75352-140">의 대부분 클래스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 에서 파생 <xref:System.Windows.Threading.DispatcherObject> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="75352-141">생성 시는 <xref:System.Windows.Threading.DispatcherObject> <xref:System.Windows.Threading.Dispatcher> 현재 실행 중인 스레드에 연결 된에 대 한 참조를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="75352-142">실제로는이를 <xref:System.Windows.Threading.DispatcherObject> 만드는 스레드와 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="75352-143">프로그램을 실행 하는 동안은 <xref:System.Windows.Threading.DispatcherObject> 해당 공용 메서드를 호출할 수 있습니다 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> .</span><span class="sxs-lookup"><span data-stu-id="75352-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="75352-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>현재 스레드와 연결 된를 검사 하 <xref:System.Windows.Threading.Dispatcher> 고이를 생성 중에 저장 된 참조와 비교 합니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="75352-145">일치 하지 않으면에서 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="75352-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>는에 속한 모든 메서드의 시작 부분에서 호출 됩니다 <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="75352-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="75352-147">한 스레드만를 수정할 수 있는 경우 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 백그라운드 스레드는 사용자와 상호 작용 하는 방법은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="75352-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="75352-148">백그라운드 스레드는 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드를 대신 하 여 작업을 수행 하도록 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="75352-149">작업 항목을 스레드의로 등록 하 여이 작업을 수행 <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-150"><xref:System.Windows.Threading.Dispatcher>클래스는 작업 항목을 등록 하는 두 가지 메서드인 및를 제공 합니다 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> .</span><span class="sxs-lookup"><span data-stu-id="75352-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="75352-151">메서드는 둘 다 대리자 실행을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="75352-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>는 동기 호출입니다. 즉, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드가 실제로 대리자 실행을 완료할 때까지 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="75352-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>는 비동기 이며 즉시 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="75352-154">는 해당 <xref:System.Windows.Threading.Dispatcher> 큐의 요소를 우선 순위에 따라 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="75352-155">큐에 요소를 추가할 때 지정할 수 있는 10 개의 수준이 있습니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="75352-156">이러한 우선 순위는 열거에서 유지 관리 됩니다 <xref:System.Windows.Threading.DispatcherPriority> .</span><span class="sxs-lookup"><span data-stu-id="75352-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="75352-157">수준에 대 한 자세한 내용은 <xref:System.Windows.Threading.DispatcherPriority> Windows SDK 설명서에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="75352-158">사용 중인 스레드: 샘플</span><span class="sxs-lookup"><span data-stu-id="75352-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="75352-159">장기 실행 계산이 포함된 단일 스레드 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="75352-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="75352-160">대부분의 Gui (그래픽 사용자 인터페이스)는 사용자 상호 작용에 대 한 응답으로 생성 되는 이벤트를 기다리는 동안 유휴 시간의 상당 부분을 차지 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="75352-161">신중한 프로그래밍을 통해의 응답성에 영향을 주지 않고이 유휴 시간을 constructively 사용할 수 있습니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="75352-162">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]스레딩 모델에서는 입력이 스레드에서 발생 하는 작업을 중단 하는 것을 허용 하지 않습니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-162">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-163">즉, <xref:System.Windows.Threading.Dispatcher> 보류 중인 입력 이벤트를 주기적으로 처리 하 여 부실 하 게 하려면로 돌아가야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="75352-164">다음과 같은 예제를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="75352-164">Consider the following example:</span></span>

 ![소수 스레딩을 보여 주는 스크린샷](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="75352-166">이 간단한 애플리케이션은 3부터 위쪽으로 계산하여 소수를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="75352-167">사용자가 **시작** 단추를 클릭 하면 검색이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="75352-168">프로그램이 소수를 찾으면 검색 결과로 사용자 인터페이스를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="75352-169">이때 사용자가 검색을 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="75352-170">간단한 방법이지만 소수 검색이 영원히 계속될 수 있는 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="75352-171">단추의 click 이벤트 처리기 내에서 전체 검색을 처리 하는 경우 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드에 다른 이벤트를 처리할 수 있는 기회가 제공 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="75352-172">는 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 입력에 응답 하거나 메시지를 처리할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-172">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="75352-173">다시 표시되지 않으며 단추 클릭에 응답하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="75352-174">소수 검색을 별도의 스레드에서 수행할 수 있지만 이 경우 동기화 문제를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="75352-175">단일 스레드 방법을 통해 발견된 가장 큰 소수를 나열하는 레이블을 직접 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="75352-176">계산 작업을 관리 하기 쉬운 청크로 분할 하는 경우 주기적으로 및 프로세스 이벤트로 돌아갈 수 있습니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="75352-177">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]입력을 다시 표시 하 고 처리할 수 있는 기회를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="75352-178">계산 및 이벤트 처리 간에 처리 시간을 분할 하는 가장 좋은 방법은에서 계산을 관리 하는 것입니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="75352-179">메서드를 사용 하 여 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 이벤트를 그리는 동일한 큐에서 소수 검사를 예약할 수 있습니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="75352-180">예제에서는 단일 소수 검사를 한 번만 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="75352-181">소수 검사가 완료된 후 즉시 다음 검사를 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="75352-182">이 검사는 보류 중인 이벤트가 처리 된 후에만 진행 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![디스패처 큐를 보여 주는 스크린샷](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="75352-184">Microsoft Word는이 메커니즘을 사용 하 여 맞춤법 검사를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="75352-185">맞춤법 검사는 스레드의 유휴 시간을 사용 하 여 백그라운드에서 수행 됩니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-186">코드를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="75352-187">다음 예제에서는 사용자 인터페이스를 만드는 XAML을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75352-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="75352-188">다음 예제에서는 코드 숨김을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75352-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="75352-189">다음 예제에서는에 대 한 이벤트 처리기를 보여 줍니다 <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="75352-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="75352-190">에서 텍스트를 업데이트 하는 것 외에도 <xref:System.Windows.Controls.Button> 이 처리기는 큐에 대리자를 추가 하 여 첫 번째 소수 검사를 예약 해야 합니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="75352-191">이 이벤트 처리기가 작업을 완료 한 후에는에서 <xref:System.Windows.Threading.Dispatcher> 실행을 위해이 대리자를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="75352-192">앞에서 설명한 것 처럼 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 는 <xref:System.Windows.Threading.Dispatcher> 실행을 위해 대리자를 예약 하는 데 사용 되는 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="75352-193">이 경우 <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> 우선 순위를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="75352-194">는 <xref:System.Windows.Threading.Dispatcher> 처리할 중요 한 이벤트가 없는 경우에만이 대리자를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="75352-195">응답성이 숫자 검사보다 더 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-195">responsiveness is more important than number checking.</span></span> <span data-ttu-id="75352-196">또한 숫자 검사 루틴을 표현하는 새 대리자를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="75352-197">이 메서드는 다음 홀수가 소수인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="75352-198">소수 인 경우 메서드는 `bigPrime` <xref:System.Windows.Controls.TextBlock> 검색을 반영 하도록를 직접 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="75352-199">구성 요소를 만드는 데 사용된 같은 스레드에서 계산이 수행되므로 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="75352-200">계산을 위해 별도의 스레드를 사용 하도록 선택 했으므로 더 복잡 한 동기화 메커니즘을 사용 하 고 스레드에서 업데이트를 실행 해야 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-201">이 상황은 다음에 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="75352-202">이 샘플에 대 한 전체 소스 코드는 [장기 실행 계산이 포함 된 단일 스레드 응용 프로그램 샘플](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="75352-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="75352-203">백그라운드 스레드를 사용하여 차단 작업 처리</span><span class="sxs-lookup"><span data-stu-id="75352-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="75352-204">그래픽 애플리케이션에서 차단 작업을 처리하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="75352-205">애플리케이션이 고정된 것처럼 보이므로 이벤트 처리기에서 차단 메서드를 호출하려고 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="75352-206">개별 스레드를 사용 하 여 이러한 작업을 처리할 수 있지만, 작업을 완료 하면 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 작업자 스레드에서 GUI를 직접 수정할 수 없으므로 스레드와 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="75352-207"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>또는 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 를 사용 하 여 스레드의에 대리자를 삽입할 수 있습니다 <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-208">결과적으로 이러한 대리자는 요소를 수정할 수 있는 권한을 사용 하 여 실행 됩니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="75352-209">이 예제에서는 날씨 예보를 검색하는 원격 프로시저 호출을 모방합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="75352-210">별도의 작업자 스레드를 사용 하 여이 호출을 실행 하 고, <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 완료 되 면 스레드의에서 업데이트 메서드를 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![날씨 UI를 보여 주는 스크린샷](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="75352-212">다음은 주의할 몇 가지 세부 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="75352-213">단추 처리기 만들기</span><span class="sxs-lookup"><span data-stu-id="75352-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="75352-214">단추가 클릭되면 시계 그림을 표시하고 애니메이션 효과를 주기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="75352-215">단추를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-215">We disable the button.</span></span> <span data-ttu-id="75352-216">`FetchWeatherFromServer`새 스레드에서 메서드를 호출한 다음을 반환 하 여 <xref:System.Windows.Threading.Dispatcher> 날씨 예측을 수집 하기 위해 대기 하는 동안에서 이벤트를 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="75352-217">날씨 페치</span><span class="sxs-lookup"><span data-stu-id="75352-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="75352-218">예제를 간단하게 유지하기 위해 이 예제에는 실제로 네트워킹 코드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="75352-219">대신에 4초 동안 새 스레드를 절전 모드로 전환하여 네트워크 액세스 지연을 시뮬레이트합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="75352-220">이번에는 원래 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드가 계속 실행 중 이며 이벤트에 응답 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="75352-221">이 상황을 표시하기 위해 애니메이션을 계속 실행하고 [최소화] 및 [최대화] 단추도 계속 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="75352-222">지연이 완료 되 고 일기 예보를 임의로 선택 하 고 나면 스레드에 다시 보고 하는 시간입니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-223">스레드의를 `UpdateUserInterface` 사용 하 여 스레드에서에 대 한 호출을 예약 하 여이 작업을 수행 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <xref:System.Windows.Threading.Dispatcher> 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="75352-224">날씨를 설명하는 문자열을 예약된 메서드 호출에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="75352-225">업데이트[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="75352-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="75352-226">스레드의에 <xref:System.Windows.Threading.Dispatcher> 시간이 있으면 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 에 대 한 예약 된 호출을 실행 `UpdateUserInterface` 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="75352-227">이 메서드는 시계 애니메이션을 중지하고 날씨를 설명할 이미지를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="75352-228">이 이미지를 표시하고 "예보 페치" 단추를 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="75352-229">여러 Windows, 여러 스레드</span><span class="sxs-lookup"><span data-stu-id="75352-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="75352-230">일부 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램에는 여러 개의 최상위 창이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-230">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="75352-231">한 스레드/ <xref:System.Windows.Threading.Dispatcher> 조합에서 여러 windows를 관리 하는 것은 완벽 하 게 허용 되지만 때로는 여러 스레드가 더 나은 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="75352-232">특히 창 중 하나가 스레드를 독점할 가능성이 있는 경우 여러 스레드를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="75352-233">Windows 탐색기는 이런 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="75352-234">새로운 각 탐색기 창은 원래 프로세스에 속하지만 독립 스레드의 제어를 기반으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="75352-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="75352-235">컨트롤을 사용 하 여 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> 웹 페이지를 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="75352-236">간단한 Internet Explorer 대체를 쉽게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="75352-237">새 탐색기 창을 여는 중요한 기능으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="75352-238">사용자가 “새 창” 단추를 클릭하면 창 복사본을 별도의 스레드에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="75352-239">이렇게 하면 창 중 하나에 있는 장기 실행 또는 차단 작업으로 인해 모든 다른 창이 잠기지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="75352-240">실제로 웹 브라우저 모델에는 복잡한 자체 스레딩 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="75352-241">대부분의 독자에게 친숙해야 하므로 이를 선택했습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="75352-242">다음 예제에서는 코드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75352-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="75352-243">이 코드의 다음 스레딩 세그먼트는 이 컨텍스트에서 가장 흥미로운 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="75352-244">이 메서드는 “새 창” 단추가 클릭될 때 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="75352-245">이 메서드는 새 스레드를 만들고 비동기적으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="75352-246">이 메서드는 새 스레드의 시작점입니다.</span><span class="sxs-lookup"><span data-stu-id="75352-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="75352-247">이 스레드의 제어를 기반으로 새 창을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="75352-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="75352-248">새 스레드를 관리 하는 새을 자동으로 만듭니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="75352-249">창을 작동 시키려면를 시작 해야 합니다 <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="75352-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="75352-250">기술 세부 정보 및 주의 사항</span><span class="sxs-lookup"><span data-stu-id="75352-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="75352-251">스레딩을 사용하여 구성 요소 작성</span><span class="sxs-lookup"><span data-stu-id="75352-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="75352-252">Microsoft .NET Framework 개발자 가이드에서는 구성 요소가 비동기 동작을 클라이언트에 노출 하는 방법에 대 한 패턴을 설명 합니다 ( [이벤트 기반 비동기 패턴 개요](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)참조).</span><span class="sxs-lookup"><span data-stu-id="75352-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="75352-253">예를 들어, `FetchWeatherFromServer` 다시 사용할 수 있는 그래픽이 아닌 구성 요소에 메서드를 패키징하 려 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="75352-254">표준 Microsoft .NET Framework 패턴을 따라 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="75352-255">`GetWeatherAsync`는 백그라운드 스레드 만들기와 같이 앞에서 설명한 기술 중 하나를 사용하여 호출 스레드를 잠그지 않고 비동기적으로 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="75352-256">이 패턴의 가장 중요 한 부분 중 하나는 *MethodName* `Completed` *methodname* 메서드를 호출한 동일한 스레드에서 methodname 메서드를 호출 하 여 시작 하는 것입니다 `Async` .</span><span class="sxs-lookup"><span data-stu-id="75352-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="75352-257">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]을 (를) 저장 하 여 매우 쉽게 사용할 수 <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> 있지만 그래픽이 아닌 구성 요소는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Windows Forms 또는 ASP.NET 프로그램이 아닌 응용 프로그램 에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="75352-258"><xref:System.Windows.Threading.DispatcherSynchronizationContext>클래스는이 요구 사항을 해결 <xref:System.Windows.Threading.Dispatcher> 합니다 .이는 다른 프레임 워크와 함께 작동 하는의 단순화 된 버전으로 간주 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="75352-259">중첩 펌핑</span><span class="sxs-lookup"><span data-stu-id="75352-259">Nested Pumping</span></span>
 <span data-ttu-id="75352-260">경우에 따라 스레드를 완전히 잠그는 것은 불가능 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-261"><xref:System.Windows.MessageBox.Show%2A>클래스의 메서드를 살펴보겠습니다 <xref:System.Windows.MessageBox> .</span><span class="sxs-lookup"><span data-stu-id="75352-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="75352-262"><xref:System.Windows.MessageBox.Show%2A>사용자가 확인 단추를 클릭할 때까지 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="75352-263">하지만 상호 작용하기 위해 메시지 루프를 포함해야 하는 창을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="75352-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="75352-264">사용자가 [확인]을 클릭할 때까지 기다리고 있는 동안 원래 애플리케이션 창은 사용자 입력에 반응하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="75352-265">하지만 이 창은 그리기 메시지를 계속 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="75352-266">원래 창은 숨겨졌다 표시될 때 자동으로 재배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-266">The original window redraws itself when covered and revealed.</span></span>

 ![확인 단추를 사용 하 여 MessageBox를 표시 하는 스크린샷](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="75352-268">일부 스레드는 메시지 상자 창을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="75352-269">에서는 메시지 상자 창인 경우에만 새 스레드를 만들 수 있지만 이 스레드는 원래 창에서 사용되지 않는 요소를 그릴 수 없습니다(상호 배제에 대한 이전 설명 참조).</span><span class="sxs-lookup"><span data-stu-id="75352-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="75352-270">대신에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 중첩 된 메시지 처리 시스템을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="75352-271">클래스에는 <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 응용 프로그램의 현재 실행 지점을 저장 하 고 새 메시지 루프를 시작 하는 라는 특수 메서드가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="75352-272">중첩 된 메시지 루프가 완료 되 면 원래 호출 후에 실행이 다시 시작 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="75352-273">이 경우는 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 에 대 한 호출에서 프로그램 컨텍스트를 유지 관리 하 <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> 고 새 메시지 루프를 시작 하 여 백그라운드 창을 다시 그리고 메시지 상자 창에 대 한 입력을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="75352-274">사용자가 [확인]을 클릭 하 고 팝업 창을 지우면 중첩 루프가 종료 되 고를 호출한 후 제어가 다시 시작 <xref:System.Windows.MessageBox.Show%2A> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="75352-275">부실 라우트된 이벤트</span><span class="sxs-lookup"><span data-stu-id="75352-275">Stale Routed Events</span></span>
 <span data-ttu-id="75352-276">에서 라우트된 이벤트 시스템은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트가 발생할 때 전체 트리를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="75352-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="75352-277">줄임표 위에서 마우스 왼쪽 단추를 누르면 `handler2` 이 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="75352-278">`handler2`이 완료 되 면 이벤트는를 사용 하 여 <xref:System.Windows.Controls.Canvas> 처리 하는 개체에 전달 됩니다 `handler1` .</span><span class="sxs-lookup"><span data-stu-id="75352-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="75352-279">이는 `handler2` 가 이벤트 개체를 처리 된 것으로 명시적으로 표시 하지 않는 경우에만 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="75352-280">`handler2`이 이벤트를 처리 하는 데 상당한 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="75352-281">`handler2`<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>는 시간에 대해 반환 되지 않는 중첩 된 메시지 루프를 시작 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="75352-282">`handler2`이 메시지 루프가 완료 될 때에서 이벤트를 처리 된 것으로 표시 하지 않으면 이벤트는 매우 오래 된 경우에도 트리 위로 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75352-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="75352-283">재입력 및 잠금</span><span class="sxs-lookup"><span data-stu-id="75352-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="75352-284">CLR (공용 언어 런타임)의 잠금 메커니즘은 짐작할 수 있는 것과 동일 하 게 동작 하지 않습니다. 잠금을 요청할 때 스레드가 작업을 완전히 중단 하는 것으로 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="75352-285">실제로 스레드는 우선 순위가 높은 메시지를 계속 수신하고 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="75352-286">이를 통해 교착 상태를 방지하고 인터페이스가 최소한으로 응답할 수 있지만 미묘한 버그가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="75352-287">대부분의 경우에 대 한 정보를 알 필요가 없지만 드문 경우 (일반적으로 Win32 창 메시지 또는 COM STA 구성 요소와 관련 됨)에는이 작업을 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="75352-288">개발자는가 둘 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 이상의 스레드에서 액세스할 수 없다고 가정 하 여 대부분의 인터페이스는 스레드 보안을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="75352-289">이 경우 단일 스레드는 예기치 않은 시간에 환경 변경을 수행 하 여 <xref:System.Windows.Threading.DispatcherObject> 상호 배제 메커니즘이 해결 될 것으로 예상 하는 효과를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="75352-290">다음 의사 코드를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="75352-291">![스레딩 재진입을 보여 주는 다이어그램입니다.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="75352-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="75352-292">가장 중요 한 것은 아니지만 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 예기치 않은 재진입으로 인해 문제가 발생 하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="75352-293">따라서 특정 키 시간에는를 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 호출 하 여 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 일반적인 CLR 잠금 대신 재진입 해제 잠금을 사용 하도록 해당 스레드에 대 한 잠금 명령을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="75352-294">따라서 CLR 팀에서이 동작을 선택 하는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="75352-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="75352-295">이 팀은 COM STA 개체 및 종료 스레드를 사용해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="75352-296">개체가 가비지 수집 되는 경우 해당 `Finalize` 메서드는 스레드가 아니라 전용 종료자 스레드에서 실행 됩니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-297">스레드에 생성 된 COM STA 개체는 스레드에서만 삭제할 수 있기 때문에 문제가 발생 합니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="75352-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="75352-298">CLR은와 동일 합니다 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (이 경우 Win32's 사용 `SendMessage` ).</span><span class="sxs-lookup"><span data-stu-id="75352-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="75352-299">그러나 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 스레드가 사용 중인 경우 종료자 스레드가 중단 되 고 COM STA 개체를 삭제할 수 없으므로 심각한 메모리 누수가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="75352-299">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="75352-300">따라서 CLR 팀은 잠금이 작동 하는 방식에 대 한 어려운 호출을 수행 했습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="75352-301">의 작업은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 메모리 누수를 재 도입 하지 않고 예기치 않은 재진입을 방지 하는 것입니다 .이 경우에는 모든 위치에서 재진입을 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="75352-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="75352-302">참고 항목</span><span class="sxs-lookup"><span data-stu-id="75352-302">See also</span></span>

- [<span data-ttu-id="75352-303">장기 실행 계산이 포함된 단일 스레드 애플리케이션 샘플</span><span class="sxs-lookup"><span data-stu-id="75352-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
