---
title: 사용자 지정 종속성 속성
description: Windows Presentation Foundation에서 속성을 구현 하는 단계 및 속성의 성능, 유용성 또는 다양성을 개선 하는 옵션에 대해 알아봅니다.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: b082340afb8b1a814fc5923126aa58183d43bc01
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168155"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="d4f41-103">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d4f41-103">Custom Dependency Properties</span></span>

<span data-ttu-id="d4f41-104">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 애플리케이션 개발자와 구성 요소 작성자가 사용자 지정 종속성 속성을 만들려고 하는 이유와 구현 단계 및 속성의 성능, 유용성 또는 유연성을 향상시킬 수 있는 일부 구현 옵션에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-104">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="d4f41-105">사전 요구 사항</span><span class="sxs-lookup"><span data-stu-id="d4f41-105">Prerequisites</span></span>

<span data-ttu-id="d4f41-106">이 항목에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스의 기존 종속성 속성의 소비자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](dependency-properties-overview.md) 항목을 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="d4f41-107">이 항목의 예제를 따르려면 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]를 이해하고 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션을 작성하는 방법도 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="d4f41-108">종속성 속성이란?</span><span class="sxs-lookup"><span data-stu-id="d4f41-108">What Is a Dependency Property?</span></span>

<span data-ttu-id="d4f41-109">스타일 지정, 데이터 바인딩, 상속, 애니메이션 및 기본값을 종속성 속성으로 구현 하 여 지원 하기 위해 CLR (공용 언어 런타임) 속성을 사용 하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-109">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="d4f41-110">종속성 속성은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 메서드 (또는)를 호출 하 여 속성 시스템에 등록 되 <xref:System.Windows.DependencyProperty.Register%2A> <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 고 식별자 필드에 의해 지원 되는 속성입니다 <xref:System.Windows.DependencyProperty> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-110">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="d4f41-111">종속성 속성은 형식 에서만 사용할 수 <xref:System.Windows.DependencyObject> 있지만 <xref:System.Windows.DependencyObject> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스 계층 구조에서 매우 높아서에서 사용할 수 있는 대부분의 클래스는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 종속성 속성을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-111">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="d4f41-112">종속성 속성 및이 SDK에서 해당 속성을 설명 하는 데 사용 되는 용어 및 규칙에 대 한 자세한 내용은 [종속성 속성 개요](dependency-properties-overview.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-112">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="d4f41-113">종속성 속성의 예</span><span class="sxs-lookup"><span data-stu-id="d4f41-113">Examples of Dependency Properties</span></span>

<span data-ttu-id="d4f41-114">클래스에서 구현 되는 종속성 속성의 예로는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Control.Background%2A> 속성, <xref:System.Windows.FrameworkElement.Width%2A> 속성 및 속성 등 <xref:System.Windows.Controls.TextBox.Text%2A> 이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-114">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="d4f41-115">클래스에 의해 노출 되는 각 종속성 속성에 <xref:System.Windows.DependencyProperty> 는 동일한 클래스에서 노출 되는 형식의 해당 public 정적 필드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-115">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="d4f41-116">이는 종속성 속성의 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-116">This is the identifier for the dependency property.</span></span> <span data-ttu-id="d4f41-117">식별자는 규칙을 사용하여 이름이 지정됩니다. 종속성 속성의 이름에는 문자열 `Property`가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-117">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="d4f41-118">예를 들어 속성에 해당 하는 <xref:System.Windows.DependencyProperty> 식별자 필드는 <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control.BackgroundProperty> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-118">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="d4f41-119">식별자는 등록 된 종속성 속성에 대 한 정보를 저장 하 고, 나중에 호출 등 종속성 속성을 포함 하는 다른 작업에 대해 식별자를 사용 <xref:System.Windows.DependencyObject.SetValue%2A> 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-119">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="d4f41-120">[종속성 속성 개요](dependency-properties-overview.md)에 설명 된 대로 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (대부분의 연결 된 속성 제외)의 모든 종속성 속성은 "래퍼" 구현 때문에 CLR 속성 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-120">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="d4f41-121">따라서 코드에서 다른 CLR 속성을 사용 하는 것과 동일한 방식으로 래퍼를 정의 하는 CLR 접근자를 호출 하 여 종속성 속성을 가져오거나 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-121">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="d4f41-122">설정 된 종속성 속성의 소비자는 일반적으로 <xref:System.Windows.DependencyObject> <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> 기본 속성 시스템에 대 한 연결 지점인 및 메서드를 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-122">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="d4f41-123">대신, CLR 속성의 기존 구현에서는 <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> `get` `set` 식별자 필드를 적절 하 게 사용 하 여 속성의 및 래퍼 구현 내에서 및를 이미 호출 했습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-123">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="d4f41-124">사용자 지정 종속성 속성을 직접 구현하는 경우 유사한 방법으로 래퍼를 정의하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-124">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="d4f41-125">종속성 속성의 구현 시기</span><span class="sxs-lookup"><span data-stu-id="d4f41-125">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="d4f41-126">클래스에 대 한 속성을 구현 하는 경우 클래스가에서 파생 되는 한 <xref:System.Windows.DependencyObject> 속성을 식별자로 백업 하 여 해당 속성을 종속성 속성으로 만드는 옵션을 사용할 수 있습니다 <xref:System.Windows.DependencyProperty> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-126">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="d4f41-127">속성을 종속성 속성으로 만드는 것이 항상 필요하거나 적절한 것은 아니며 시나리오 요구에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-127">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="d4f41-128">때로는 개인 필드로 속성을 지원하는 일반적인 기술이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-128">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="d4f41-129">그러나 속성에서 다음 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 기능 중 하나 이상을 지원하기를 원할 때마다 속성을 종속성 속성으로 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-129">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="d4f41-130">스타일에 속성을 설정하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-130">You want your property to be settable in a style.</span></span> <span data-ttu-id="d4f41-131">자세한 내용은 [스타일 지정 및 템플릿](../../../desktop-wpf/fundamentals/styles-templates-overview.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-131">For more information, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

- <span data-ttu-id="d4f41-132">속성에서 데이터 바인딩을 지원하게 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-132">You want your property to support data binding.</span></span> <span data-ttu-id="d4f41-133">데이터 바인딩 종속성 속성에 대한 자세한 내용은 [두 컨트롤의 속성 바인딩](../data/how-to-bind-the-properties-of-two-controls.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-133">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="d4f41-134">동적 리소스 참조를 사용하여 속성을 설정하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-134">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="d4f41-135">자세한 내용은 [XAML 리소스](../../../desktop-wpf/fundamentals/xaml-resources-define.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-135">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="d4f41-136">요소 트리의 부모 요소에서 속성 값을 자동으로 상속받도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-136">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="d4f41-137">이 경우 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> CLR 액세스를 위한 속성 래퍼도 만드는 경우에도 메서드에를 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-137">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="d4f41-138">자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-138">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="d4f41-139">속성에 애니메이션 효과를 주려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-139">You want your property to be animatable.</span></span> <span data-ttu-id="d4f41-140">자세한 내용은 [애니메이션 개요](../graphics-multimedia/animation-overview.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-140">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="d4f41-141">속성 시스템, 환경 또는 사용자가 수행한 작업을 통해 또는 스타일을 읽고 사용하여 이전 속성 값이 변경되었을 때 속성 시스템에서 보고하도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-141">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="d4f41-142">속성 메타데이터를 사용하여 속성 시스템에서 속성 값이 명확하게 변경되었다는 것을 확인할 때마다 호출되는 콜백 메서드를 속성이 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-142">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="d4f41-143">관련 개념은 속성 값 강제 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-143">A related concept is property value coercion.</span></span> <span data-ttu-id="d4f41-144">자세한 내용은 [종속성 속성 콜백 및 유효성 검사](dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-144">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="d4f41-145">속성 값 변경 시 레이아웃 시스템에서 요소의 시각적 개체를 재구성해야 하는지 여부를 보고하는 것과 같이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프로세스에서도 사용되는 설정된 메타데이터 규칙을 사용하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-145">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="d4f41-146">또는 파생 클래스가 기본값과 같은 메타데이터 기반 특성을 변경할 수 있도록 메타데이터 재정의를 사용할 수 있도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-146">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="d4f41-147">사용자 지정 컨트롤의 속성을 통해 **속성** 창 편집과 같은 VISUAL Studio WPF 디자이너 지원을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-147">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="d4f41-148">자세한 내용은 [컨트롤 제작 개요](../controls/control-authoring-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-148">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="d4f41-149">이러한 시나리오를 검토할 때는 완전히 새로운 속성을 구현하는 대신 기존 종속성 속성의 메타데이터를 재정의하여 시나리오를 얻을 수 있는지 여부도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-149">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="d4f41-150">메타데이터 재정의가 실용적인지 여부는 시나리오 유형과 해당 시나리오가 기존 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 종속성 속성 및 클래스의 구현과 얼마나 유사한지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-150">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="d4f41-151">기존 속성에서 메타데이터 재정의에 대한 자세한 내용은 [종속성 속성 메타데이터](dependency-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-151">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="d4f41-152">종속성 속성 정의를 위한 검사 목록</span><span class="sxs-lookup"><span data-stu-id="d4f41-152">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="d4f41-153">종속성 속성 정의는 4가지 고유한 개념으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-153">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="d4f41-154">이러한 개념은 반드시 엄격한 절차적 단계는 아니며, 그중 일부는 구현 시 단일 코드 줄로 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-154">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="d4f41-155">(선택 사항) 종속성 속성의 속성 메타데이터를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-155">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="d4f41-156">속성 시스템에 속성 이름을 등록하여 소유자 유형과 속성 값의 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-156">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="d4f41-157">또한 사용되는 경우 속성 메타데이터를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-157">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="d4f41-158">식별자를 <xref:System.Windows.DependencyProperty> `public` `static` `readonly` 소유자 형식의 필드로 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-158">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="d4f41-159">종속성 속성의 이름과 일치 하는 이름이 있는 CLR "래퍼" 속성을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-159">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="d4f41-160">CLR "래퍼" 속성의 및 접근자를 구현 하 여 해당 속성을 `get` `set` 백업 하는 종속성 속성에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-160">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="d4f41-161">속성 시스템에 속성 등록</span><span class="sxs-lookup"><span data-stu-id="d4f41-161">Registering the Property with the Property System</span></span>

<span data-ttu-id="d4f41-162">속성이 종속성 속성이 되게 하려면 속성 시스템에서 유지하는 테이블에 해당 속성을 등록한 다음 나중에 속성 시스템 작업의 한정자로 사용되는 고유 식별자를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-162">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="d4f41-163">이러한 작업은 내부 작업 일 수도 있고 속성 시스템 Api를 호출 하는 사용자 고유의 코드 일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-163">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="d4f41-164">속성을 등록 하려면 클래스 <xref:System.Windows.DependencyProperty.Register%2A> 의 본문 내에서 메서드를 호출 합니다 (클래스 내에서는 멤버 정의 외부).</span><span class="sxs-lookup"><span data-stu-id="d4f41-164">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="d4f41-165">또한 식별자 필드는 <xref:System.Windows.DependencyProperty.Register%2A> 메서드 호출에서 반환 값으로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-165">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="d4f41-166"><xref:System.Windows.DependencyProperty.Register%2A>다른 멤버 정의 외부에서 호출을 수행 하는 이유는이 반환 값을 사용 하 여 `public` `static` `readonly` <xref:System.Windows.DependencyProperty> 클래스의 일부로 형식의 필드를 할당 하 고 만드는 것 이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-166">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="d4f41-167">이 필드는 종속성 속성의 식별자가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-167">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="d4f41-168">종속성 속성 이름 규칙</span><span class="sxs-lookup"><span data-stu-id="d4f41-168">Dependency Property Name Conventions</span></span>

<span data-ttu-id="d4f41-169">예외적인 상황을 제외하고 모든 상황에서 따라야 하는 종속성 속성과 관련하여 설정된 명명 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-169">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="d4f41-170">종속성 속성 자체에는의 첫 번째 매개 변수로 제공 되는이 예제와 같이 기본 이름인 "AquariumGraphic"가 있습니다 <xref:System.Windows.DependencyProperty.Register%2A> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-170">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="d4f41-171">그 이름은 각 등록 형식 내에서 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-171">That name must be unique within each registering type.</span></span> <span data-ttu-id="d4f41-172">기본 형식을 통해 상속된 종속성 속성은 이미 등록 형식의 일부로 간주되어 상속된 속성의 이름을 다시 등록할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-172">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="d4f41-173">그러나 종속성 속성이 상속되지 않는 경우에도 클래스를 종속성 속성의 소유자로 추가하는 기술이 있습니다. 자세한 내용은 [종속성 속성 메타데이터](dependency-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-173">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="d4f41-174">식별자 필드를 만들 때 이 필드의 이름을 등록할 때의 속성 이름과 접미사 `Property`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-174">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="d4f41-175">이 필드는 종속성 속성에 대 한 식별자 이며 나중에 래퍼에서 수행할 및 호출에 대 한 입력으로 사용 되며, 사용자가 직접 만든 코드에 의해 <xref:System.Windows.DependencyObject.SetValue%2A> <xref:System.Windows.DependencyObject.GetValue%2A> 속성에 액세스 하는 다른 코드, 속성 시스템 및 프로세서에 의해 허용 되는 외부 코드 액세스에 의해 래퍼에서 수행할 및 호출에 대 한 입력으로 사용 됩니다 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="d4f41-175">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="d4f41-176">클래스 본문에서 종속성 속성을 정의하는 것이 일반적인 구현이지만 클래스 정적 생성자에서 종속성 속성을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-176">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="d4f41-177">이 접근 방식은 종속성 속성을 초기화하기 위해 두 줄 이상의 코드가 필요한 경우에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-177">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="d4f41-178">"래퍼" 구현</span><span class="sxs-lookup"><span data-stu-id="d4f41-178">Implementing the "Wrapper"</span></span>

<span data-ttu-id="d4f41-179">래퍼 구현은 구현에서를 호출 하 고 구현에서를 호출 해야 합니다 <xref:System.Windows.DependencyObject.GetValue%2A> `get` <xref:System.Windows.DependencyObject.SetValue%2A> `set` . 원래 등록 호출 및 필드는 명확 하 게 나타내기 위해 여기에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-179">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="d4f41-180">모든 상황을 제외 하 고 래퍼 구현은 <xref:System.Windows.DependencyObject.GetValue%2A> 각각 및 동작만 수행 해야 합니다 <xref:System.Windows.DependencyObject.SetValue%2A> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-180">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="d4f41-181">그 이유는 [XAML로드 및 종속성 속성](xaml-loading-and-dependency-properties.md) 항목에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-181">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="d4f41-182">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스에서 제공되는 모든 기존의 공용 종속성 속성은 이 간단한 래퍼 구현 모델을 사용합니다. 종속성 속성의 작동 방식의 대부분은 본질적으로 속성 시스템의 동작이거나 속성 메타데이터를 통한 속성 변경 콜백 또는 강제 변환과 같은 다른 개념을 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-182">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="d4f41-183">규칙에 따라 래퍼 속성의 이름은 속성을 등록 한 호출의 첫 번째 매개 변수로 선택 하 고 지정 된 이름과 동일 해야 합니다 <xref:System.Windows.DependencyProperty.Register%2A> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-183">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="d4f41-184">속성이 규칙을 따르지 않는다고 해서 가능한 모든 용도에 사용하지 못한다는 것은 아니지만 몇 가지 주목할 만한 문제가 발생하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-184">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="d4f41-185">스타일과 템플릿의 특정 측면이 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-185">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="d4f41-186">대부분의 도구와 디자이너는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 제대로 serialize하거나 속성별 수준에서 디자이너 환경 지원을 제공하기 위해 명명 규칙을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-186">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="d4f41-187">현재 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 로더 구현은 래퍼를 완전히 우회 하 고 특성 값을 처리할 때 명명 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-187">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="d4f41-188">자세한 내용은 [XAML로드 및 종속성 속성](xaml-loading-and-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-188">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="d4f41-189">새 종속성 속성의 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="d4f41-189">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="d4f41-190">종속성 속성을 등록할 때 속성 시스템을 통한 등록은 속성 특성을 저장하는 메타데이터 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-190">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="d4f41-191">이러한 특성의 대부분은 속성이의 단순 시그니처로 등록 된 경우 설정 되는 기본값이 있습니다 <xref:System.Windows.DependencyProperty.Register%2A> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-191">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="d4f41-192">의 다른 시그니처 <xref:System.Windows.DependencyProperty.Register%2A> 를 사용 하면 속성을 등록할 때 원하는 메타 데이터를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-192">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="d4f41-193">종속성 속성에 대해 지정된 가장 일반적인 메타데이터는 속성을 사용하는 새 인스턴스에 적용되는 기본값을 속성에 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-193">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="d4f41-194">의 파생 클래스에 존재 하는 종속성 속성을 만드는 경우 <xref:System.Windows.FrameworkElement> 기본 클래스 대신 보다 특수화 된 메타 데이터 클래스를 사용할 수 있습니다 <xref:System.Windows.FrameworkPropertyMetadata> <xref:System.Windows.PropertyMetadata> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-194">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="d4f41-195">클래스에 대 한 생성자에는 <xref:System.Windows.FrameworkPropertyMetadata> 다양 한 메타 데이터 특성을 조합 하 여 지정할 수 있는 여러 시그니처가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-195">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="d4f41-196">기본값만 지정 하려면 형식의 단일 매개 변수를 사용 하는 서명을 사용 합니다 <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-196">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="d4f41-197">해당 개체 매개 변수를 속성의 형식별 기본값으로 전달 합니다. 제공 된 기본값은 `propertyType` 호출에서 매개 변수로 제공한 형식 이어야 합니다 <xref:System.Windows.DependencyProperty.Register%2A> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-197">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="d4f41-198">의 경우 <xref:System.Windows.FrameworkPropertyMetadata> 속성에 대 한 메타 데이터 옵션 플래그를 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-198">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="d4f41-199">이러한 플래그는 등록 후에 속성 메타데이터에서 불연속 속성으로 변환되며 특정 조건을 레이아웃 엔진과 같은 다른 프로세스와 통신하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-199">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="d4f41-200">적절한 메타데이터 플래그 설정</span><span class="sxs-lookup"><span data-stu-id="d4f41-200">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="d4f41-201">속성 (또는 해당 값의 변경)이에 영향을 미치고 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 특히 레이아웃 시스템에서 페이지의 요소 크기를 조정 하거나 렌더링 하는 방법에 영향을 주는 경우에는 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> ,, 플래그 중 하나 이상을 설정 합니다. <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender></span><span class="sxs-lookup"><span data-stu-id="d4f41-201">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="d4f41-202"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>이 속성을 변경 하려면 포함 하는 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 개체가 부모 내에서 더 많은 공간을 필요로 할 수 있는 렌더링을 변경 해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-202"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="d4f41-203">예를 들어 "Width" 속성은 이 플래그를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-203">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="d4f41-204"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>이 속성을 변경 하면 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 일반적으로 전용 공간을 변경할 필요가 없고 공간 내의 위치가 변경 되었음을 나타내는 렌더링을 변경 해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-204"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="d4f41-205">예를 들어 "Alignment" 속성은 이 플래그를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-205">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="d4f41-206"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>는 레이아웃 및 측정에 영향을 주지 않는 다른 변경이 발생 했지만 다른 렌더링이 필요 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-206"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="d4f41-207">예를 들어 기존 요소의 색상을 변경하는 "Background"와 같은 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-207">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="d4f41-208">이러한 플래그는 종종 속성 시스템 또는 레이아웃 콜백의 자체 재정의 구현에 대한 메타데이터의 프로토콜로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-208">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="d4f41-209">예를 들어 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> <xref:System.Windows.UIElement.InvalidateArrange%2A> 인스턴스의 속성이 값 변경 내용을 보고 하 고 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> `true` 해당 메타 데이터에가 있는 경우를 호출 하는 콜백이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-209">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="d4f41-210">일부 속성은 위에 언급된 필수 크기의 변경 이상으로, 포함하는 부모 요소의 렌더링 특성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-210">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="d4f41-211">예를 <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> 들어 유동 문서 모델에서 사용 되는 속성은 해당 속성을 변경 하 여 단락이 포함 된 유동 문서의 전반적인 렌더링을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-211">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="d4f41-212"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange>또는 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> 를 사용 하 여 고유한 속성에서 비슷한 사례를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-212">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="d4f41-213">기본적으로 종속성 속성은 데이터 바인딩을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-213">By default, dependency properties support data binding.</span></span> <span data-ttu-id="d4f41-214">데이터 바인딩에 대한 현실적인 시나리오가 없거나 큰 개체에 대한 데이터 바인딩의 성능이 문제로 인식되는 경우 데이터 바인딩을 의도적으로 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-214">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="d4f41-215">기본적으로 <xref:System.Windows.Data.Binding.Mode%2A> 종속성 속성에 대 한 데이터 바인딩은 기본적으로로 설정 <xref:System.Windows.Data.BindingMode.OneWay> 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-215">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="d4f41-216">바인딩을 바인딩 인스턴스당 언제 든 지 변경할 수 있습니다 <xref:System.Windows.Data.BindingMode.TwoWay> . 자세한 내용은 [바인딩의 방향 지정](../data/how-to-specify-the-direction-of-the-binding.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-216">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="d4f41-217">그러나 종속성 속성 작성자는 속성을 <xref:System.Windows.Data.BindingMode.TwoWay> 기본적으로 바인딩 모드를 사용 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-217">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="d4f41-218">기존 종속성 속성의 예는입니다 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType> .이 속성의 시나리오는 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 설정 논리와의 합성이 <xref:System.Windows.Controls.MenuItem> 기본 테마 스타일과 상호 작용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-218">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="d4f41-219"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>속성 논리는 기본적으로 데이터 바인딩을 사용 하 여 다른 상태 속성 및 메서드 호출에 따라 속성의 상태를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-219">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="d4f41-220">기본적으로 바인딩되는 또 다른 예제 속성 <xref:System.Windows.Data.BindingMode.TwoWay> 은 <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType> 입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-220">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="d4f41-221">플래그를 설정 하 여 사용자 지정 종속성 속성에서 속성 상속을 사용 하도록 설정할 수도 있습니다 <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-221">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="d4f41-222">속성 상속은 부모 요소와 자식 요소가 공통된 속성을 갖는 시나리오에 유용하며 자식 요소가 해당 특정 속성 값을 부모가 설정한 값과 동일한 값으로 설정하는 것이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-222">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="d4f41-223">상속 가능한 속성의 예로는 데이터 표시를 <xref:System.Windows.FrameworkElement.DataContext%2A> 위한 중요 한 마스터-세부 시나리오를 활성화 하는 바인딩 작업에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-223">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="d4f41-224">상속 가능 하 게 만들면 <xref:System.Windows.FrameworkElement.DataContext%2A> 모든 자식 요소가 해당 데이터 컨텍스트를 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-224">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="d4f41-225">속성 값 상속으로 인해 페이지 또는 애플리케이션 루트에서 데이터 컨텍스트를 지정할 수 있으며 가능한 모든 하위 요소의 바인딩에 대해 다시 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-225">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="d4f41-226"><xref:System.Windows.FrameworkElement.DataContext%2A>는 상속이 기본값을 재정의 함을 보여 주는 좋은 예 이기도 하지만 항상 특정 자식 요소에서 로컬로 설정할 수 있습니다. 자세한 내용은 [계층적 데이터에 마스터-세부 패턴 사용](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-226"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="d4f41-227">속성 값 상속을 사용하면 성능이 저하될 수 있으므로 꼭 필요할 때만 사용해야 합니다. 자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-227">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="d4f41-228"><xref:System.Windows.FrameworkPropertyMetadataOptions.Journal>탐색 저널링 서비스에서 종속성 속성을 검색 하거나 사용 해야 하는지 여부를 나타내는 플래그를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-228">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="d4f41-229">예는 속성입니다 <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> . 선택 컨트롤에서 선택한 항목은 저널링 기록을 탐색할 때 유지 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-229">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="d4f41-230">읽기 전용 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d4f41-230">Read-Only Dependency Properties</span></span>

<span data-ttu-id="d4f41-231">읽기 전용인 종속성 속성을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-231">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="d4f41-232">그러나 속성을 읽기 전용으로 정의하는 이유에 대한 시나리오는 속성 시스템에 속성을 등록하고 식별자를 노출하는 절차와 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-232">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="d4f41-233">자세한 내용은 [읽기 전용 종속성 속성](read-only-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-233">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="d4f41-234">컬렉션 형식 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d4f41-234">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="d4f41-235">컬렉션 형식 종속성 속성에는 고려할 몇 가지 추가 구현의 문제점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-235">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="d4f41-236">자세한 내용은 [컬렉션 형식 종속성 속성](collection-type-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-236">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="d4f41-237">종속성 속성 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="d4f41-237">Dependency Property Security Considerations</span></span>

<span data-ttu-id="d4f41-238">종속성 속성은 공용 속성으로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-238">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="d4f41-239">종속성 속성 식별자 필드는 공용 정적 필드로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-239">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="d4f41-240">다른 액세스 수준 (예: protected)을 선언 하려고 해도 종속성 속성은 항상 속성 시스템 Api와 함께 식별자를 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-240">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="d4f41-241">속성 시스템에 포함 된 메타 데이터 보고 또는 값 결정 Api (예:)로 인해 보호 된 식별자 필드에도 액세스할 수 있습니다 <xref:System.Windows.LocalValueEnumerator> .</span><span class="sxs-lookup"><span data-stu-id="d4f41-241">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="d4f41-242">자세한 내용은 [종속성 속성 보안](dependency-property-security.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-242">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="d4f41-243">종속성 속성 및 클래스 생성자</span><span class="sxs-lookup"><span data-stu-id="d4f41-243">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="d4f41-244">클래스 생성자가 가상 ​​메서드를 호출해서는 안 되는 관리 코드 프로그래밍(종종 FxCop와 같은 코드 분석 도구로 시행)에 일반적인 원칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-244">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="d4f41-245">이는 생성자가 파생 클래스 생성자의 기본 초기화로 호출될 수 있고 생성자를 통한 가상 메서드 입력이 생성 중인 개체 인스턴스의 불완전 초기화 상태에서 발생할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-245">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="d4f41-246">에서 파생 된 클래스에서 파생 하는 경우 <xref:System.Windows.DependencyObject> 속성 시스템 자체가 내부적으로 가상 메서드를 호출 하 고 노출 한다는 점에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-246">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="d4f41-247">이러한 가상 메서드는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템 서비스의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-247">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="d4f41-248">메서드를 재정의하면 파생 클래스가 값 결정에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-248">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="d4f41-249">런타임 초기화 시 발생할 수 있는 문제를 방지하려면 매우 구체적인 생성자 패턴을 따라 클래스의 생성자 내에서 종속성 속성 값을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d4f41-249">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="d4f41-250">자세한 내용은 [DependencyObjects의 안전한 생성자 패턴](safe-constructor-patterns-for-dependencyobjects.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d4f41-250">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d4f41-251">참조</span><span class="sxs-lookup"><span data-stu-id="d4f41-251">See also</span></span>

- [<span data-ttu-id="d4f41-252">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="d4f41-252">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="d4f41-253">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="d4f41-253">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="d4f41-254">컨트롤 제작 개요</span><span class="sxs-lookup"><span data-stu-id="d4f41-254">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="d4f41-255">컬렉션 형식 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d4f41-255">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="d4f41-256">종속성 속성 보안</span><span class="sxs-lookup"><span data-stu-id="d4f41-256">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="d4f41-257">XAML 로드 및 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="d4f41-257">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="d4f41-258">DependencyObject의 안전한 생성자 패턴</span><span class="sxs-lookup"><span data-stu-id="d4f41-258">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
