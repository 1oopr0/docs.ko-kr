---
title: 안전성 모범 사례
description: SQL Server와 같은 .NET 호스트 기반 서버 응용 프로그램의 안정성에 대 한 모범 사례를 참조 하세요. 리소스가 누출 되거나 중단 되지 않도록 합니다.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474243"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="9292e-104">안전성 모범 사례</span><span class="sxs-lookup"><span data-stu-id="9292e-104">Reliability Best Practices</span></span>

<span data-ttu-id="9292e-105">다음 안정성 규칙은 SQL Server 중심이지만, 호스트 기반 서버 애플리케이션에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="9292e-106">SQL Server와 같은 서버에서 리소스가 누출되지 않고 중단되지 않는 것이 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="9292e-107">그러나 이 작업은 개체의 상태를 변경하는 모든 메서드에 대해 취소 코드를 작성하여 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="9292e-108">취소 코드를 사용하여 모든 위치에서 모든 오류로부터 복구되는 100% 신뢰할 수 있는 관리 코드를 작성하는 것이 목표가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="9292e-109">성공 가능성이 희박한 매우 까다로운 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="9292e-110">CLR(공용 언어 런타임)에서는 완벽한 코드를 작성할 수 있는 관리 코드가 제공된다고 확실히 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="9292e-111">ASP.NET과 달리 SQL Server에서는 허용할 수 없을 정도로 오랜 기간 동안 데이터베이스를 작동 중지하지 않고는 재활용할 수 없는 단 하나의 프로세스만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="9292e-112">이와 같이 희박하게 보장되며 단일 프로세스에서 실행되는 조건에서, 필요할 때 스레드를 종료하거나 애플리케이션을 재활용하며 핸들이나 메모리와 같은 운영 체제 리소스가 누출되지 않도록 주의하는 것만이 안정성을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="9292e-113">이와 같이 안정성 제약 조건은 단순해도 안정성 요구 사항은 여전히 상당합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="9292e-114">운영 체제 리소스가 누출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="9292e-115">모든 형식의 관리되는 잠금을 CLR에 모두 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="9292e-116">애플리케이션 간 도메인 공유 상태를 중단시키지 않으므로 <xref:System.AppDomain> 재활용이 원활하게 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="9292e-117"><xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> 및 <xref:System.OutOfMemoryException> 예외를 처리하기 위한 관리 코드를 작성하는 것은 이론상으로는 가능하지만, 개발자가 애플리케이션 전체에서 이와 같이 강력한 코드를 작성하는 것을 기대하는 것은 합리적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="9292e-118">따라서 대역 외 예외가 발생하여 스레드 실행이 종료됩니다. 종료된 스레드가 공유 상태를 편집 중이었으면(스레드에서 잠금을 보유하는지에 따라 판별 가능) <xref:System.AppDomain>이 언로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="9292e-119">공유 상태를 편집 중인 메서드가 종료되면 공유 상태로 업데이트하는 안정된 취소 코드를 작성할 수 없으므로 상태가 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="9292e-120">.NET Framework 버전 2.0에서 안정성이 필요한 호스트는 SQL Server뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="9292e-121">어셈블리가 SQL Server에서 실행되는 경우 데이터베이스에서 실행 중일 때 사용하지 않게 설정된 특정 기능이 있어도 해당 어셈블리의 모든 부분에서 안정성이 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="9292e-122">코드 분석 엔진은 어셈블리 수준에서 코드를 검사하고 비활성화된 코드를 구분할 수 없으므로 이와 같은 안정성이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="9292e-123">또 다른 SQL Server 프로그래밍 고려 사항은 SQL Server가 한 프로세스에서 모든 작업을 실행하며 <xref:System.AppDomain> 재활용을 사용하여 메모리 및 운영 체제 핸들과 같은 모든 리소스를 정리한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="9292e-124">종료자, 소멸자 또는 `try/finally` 블록에 의존하여 취소 코드를 작성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="9292e-125">이러한 항목은 중단되거나 호출되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="9292e-126">모든 컴퓨터 명령의 예기치 않은 위치에서 비동기 예외가 발생할 수 있습니다(<xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> 및 <xref:System.OutOfMemoryException>).</span><span class="sxs-lookup"><span data-stu-id="9292e-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="9292e-127">관리되는 스레드는 SQL의 Win32 스레드가 아니어도 되며, 파이버일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="9292e-128">프로세스 전체 또는 애플리케이션 간 도메인 변경 가능 공유 상태는 안전하게 변경하기가 극도로 어려우므로 가능하면 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="9292e-129">메모리 부족 조건은 SQL Server에서 자주 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="9292e-130">SQL Server에서 호스팅되는 라이브러리가 공유 상태를 올바르게 업데이트하지 않아도 데이터베이스를 다시 시작할 때까지 코드가 복구되지 않을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="9292e-131">또한 극단적인 경우에는 SQL Server 프로세스가 실패되는 원인이 되므로 데이터베이스를 다시 부팅해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="9292e-132">데이터베이스를 다시 부팅하면 웹 사이트를 종료시키거나 회사 업무에 영향을 미쳐 가용성이 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="9292e-133">메모리 또는 핸들과 같은 운영 체제 리소스가 서서히 누출되면 서버에서 복구 가능성이 없이 핸들을 할당하는 데 실패하거나 서버의 성능이 서서히 저하되거나 고객의 애플리케이션 가용성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="9292e-134">이러한 시나리오는 확실히 방지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="9292e-135">모범 사례 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-135">Best practice rules</span></span>

<span data-ttu-id="9292e-136">이 소개에서는 프레임워크의 안정성과 신뢰성을 높이기 위해 서버에서 실행되는 관리 코드의 코드 검토에서 파악해야 하는 사항에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="9292e-137">이러한 검사를 수행하는 것은 일반적으로 좋은 방법이며 서버에서는 절대적으로 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="9292e-138">교착 상태나 리소스 제약 조건이 발생하는 경우 SQL Server에서 스레드를 중단하거나 <xref:System.AppDomain>을 손상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="9292e-139">이 경우 제약이 있는 실행 지역(CER)의 취소 코드만 확실히 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="9292e-140">리소스 누수를 방지 하기 위해 SafeHandle 사용</span><span class="sxs-lookup"><span data-stu-id="9292e-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="9292e-141"><xref:System.AppDomain> 언로드 시, 실행 중인 `finally` 블록 또는 종료자에 의존할 수 없으므로 <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> 또는 비슷한 클래스가 아니라 <xref:System.Runtime.InteropServices.SafeHandle> 클래스를 통해 모든 운영 체제 리소스 액세스를 추상화하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="9292e-142">그러면 CLR이 <xref:System.AppDomain>이 손상되는 경우에도 사용하는 핸들을 닫고 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="9292e-143"><xref:System.Runtime.InteropServices.SafeHandle>에서는 CLR이 항상 실행하는 중요한 종료자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="9292e-144">운영 체제 핸들은 생성된 순간부터 해제되는 순간까지 안전한 핸들에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="9292e-145">핸들이 누출되도록 <xref:System.Threading.ThreadAbortException>이 발생할 수 있는 기간이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="9292e-146">또한 플랫폼 호출에서 핸들을 참조-카운트합니다. 그러면 핸들의 수명을 면밀하게 추적할 수 있으므로, `Dispose`와 현재 핸들을 사용 중인 메서드 사이의 경합 상태에서 보안 문제가 발생하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="9292e-147">현재 운영 체제 핸들을 정리만 하는 종료자가 있는 대부분의 클래스에는 더 이상 종료자가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="9292e-148">대신 종료자는 <xref:System.Runtime.InteropServices.SafeHandle> 파생 클래스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="9292e-149"><xref:System.Runtime.InteropServices.SafeHandle>은 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>의 대안이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="9292e-150">운영 체제 리소스를 명시적으로 삭제하면 여전히 리소스 경합과 성능 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="9292e-151">리소스를 명시적으로 삭제하지 않는 `finally` 블록은 완료될 때까지 실행되지 않을 수 있다는 점에 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="9292e-152"><xref:System.Runtime.InteropServices.SafeHandle>을 사용하면 운영 체제 핸들에 상태 전달, 루틴 해제 또는 루프에서 핸들 집합 해제와 같은 핸들 해제 작업을 수행하는 고유 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 메서드를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="9292e-153">CLR에서는 이 메서드가 확실히 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="9292e-154">작성자는 모든 상황에서 핸들이 해제되도록 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="9292e-155">그러지 않으면 핸들이 누출되므로, 핸들과 연결된 네이티브 리소스가 누출되는 결과가 자주 초래됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="9292e-156">따라서 <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 구현에서 호출 시 사용 가능하지 않은 리소스를 할당할 필요가 없도록 <xref:System.Runtime.InteropServices.SafeHandle> 파생 클래스를 구성하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="9292e-157">코드에서 이러한 실패를 처리하고 네이티브 핸들을 해제하는 계약을 완료할 수 있는 경우, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>의 구현에서 실패할 수 있는 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="9292e-158"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>에는 디버깅 용도의 <xref:System.Boolean> 반환 값이 있습니다. 리소스를 해제하지 못하게 하는 치명적인 오류가 발생하는 경우 이 값은 `false`로 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="9292e-159">그러면 [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA가 활성화되어(사용된 경우) 문제를 파악하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="9292e-160">다른 방식으로 런타임에 영향을 주지 않습니다. <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>는 동일한 리소스에 대해 다시 호출되지 않으므로 핸들이 누출됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="9292e-161"><xref:System.Runtime.InteropServices.SafeHandle>은 특정 컨텍스트에서는 적절하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="9292e-162"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> 메서드는 <xref:System.GC> 종료자 스레드에서 실행될 수 있으므로, 특정 스레드에서 해제해야 하는 모든 핸들은 <xref:System.Runtime.InteropServices.SafeHandle>로 래핑하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="9292e-163">런타임 호출 가능 래퍼(RCW)는 추가 코드 없이 CLR에서 정리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="9292e-164">플랫폼 호출을 사용하고 COM 개체를 `IUnknown*` 또는 <xref:System.IntPtr>로 처리하므로, RCW를 사용하도록 코드를 다시 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="9292e-165"><xref:System.Runtime.InteropServices.SafeHandle>은 관리되지 않는 릴리스 메서드가 관리 코드로 다시 호출될 수 있으므로 이 시나리오에는 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-166">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-166">Code analysis rule</span></span>

<span data-ttu-id="9292e-167"><xref:System.Runtime.InteropServices.SafeHandle>을 사용하여 운영 체제 리소스를 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="9292e-168"><xref:System.Runtime.InteropServices.HandleRef> 또는 <xref:System.IntPtr> 형식의 필드를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="9292e-169">운영 체제 리소스 누수를 방지 하기 위해 종료자를 실행 하지 않아도 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="9292e-170">종료자를 실행하지 않아도 중요한 운영 체제 리소스가 누출되지 않게 종료자를 신중하게 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="9292e-171">애플리케이션이 안정된 상태로 실행되거나 SQL Server와 같은 서버가 종료될 때 수행되는 정상 <xref:System.AppDomain> 언로드와 달리, 갑작스러운 <xref:System.AppDomain> 언로드 중에는 개체가 종료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="9292e-172">애플리케이션의 정확도는 보장할 수 없지만, 서버의 무결성은 누출되지 않는 리소스를 통해 유지 관리해야 하므로, 갑작스러운 언로드 시 리소스가 누출되지 않게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="9292e-173"><xref:System.Runtime.InteropServices.SafeHandle>을 사용하여 운영 체제 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="9292e-174">Finally 절을 실행 하 여 운영 체제 리소스 누수가 발생 하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="9292e-175">`finally` 절은 CER 외부에서는 실행되지 않을 수도 있으므로, 라이브러리 개발자가 관리되지 않는 리소스를 해제하는 데 `finally` 블록 내의 코드에 의존하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="9292e-176"><xref:System.Runtime.InteropServices.SafeHandle>을 사용하는 것이 좋은 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-177">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-177">Code analysis rule</span></span>

<span data-ttu-id="9292e-178">운영 체제 리소스를 정리하는 데 `Finalize`가 아니라 <xref:System.Runtime.InteropServices.SafeHandle>을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="9292e-179"><xref:System.IntPtr>을 사용하지 않습니다. <xref:System.Runtime.InteropServices.SafeHandle>을 사용하여 리소스를 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="9292e-180">finally 절을 실행해야 하는 경우 CER에 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="9292e-181">모든 잠금은 기존 관리 되는 잠금 코드를 통과 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="9292e-182">스레드를 단지 중단하는 것이 아니라 <xref:System.AppDomain>을 손상시키는 경우를 파악하기 위해 CLR에서는 코드가 언제 잠금 상태인지를 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="9292e-183">스레드를 중단하면 해당 스레드에서 조작하는 데이터가 일관되지 않은 상태가 될 수 있으므로 위험해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="9292e-184">따라서 전체 <xref:System.AppDomain>을 재활용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="9292e-185">잠금 상태를 파악하지 못하면 교착 상태나 잘못된 결과가 초래될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="9292e-186"><xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A> 메서드를 사용하여 잠금 영역을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="9292e-187">이 메서드는 현재 스레드에만 적용되는 <xref:System.Threading.Thread> 클래스의 정적 메서드이므로, 한 스레드가 다른 스레드의 잠금 카운트를 편집하지 못하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="9292e-188"><xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A>에는 이 CLR 알림이 기본으로 제공되므로, 이러한 메서드를 사용하는 [lock 문](../../csharp/language-reference/keywords/lock-statement.md)뿐 아니라 이 알림을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="9292e-189">스핀 잠금 및 <xref:System.Threading.AutoResetEvent>와 같은 기타 잠금 메커니즘에서는 이러한 메서드를 호출하여 임계 영역으로 전환하고 있음을 CLR에 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="9292e-190">이러한 메서드는 잠금을 사용하지 않습니다. 임계 영역에서 코드가 실행 중이며, 스레드를 중단하면 공유 상태가 일관되지 않게 될 수 있음을 CLR에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="9292e-191">사용자 지정 <xref:System.Threading.ReaderWriterLock> 클래스와 같은 고유 잠금 형식을 정의한 경우 이러한 잠금 카운트 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-192">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-192">Code analysis rule</span></span>

<span data-ttu-id="9292e-193"><xref:System.Threading.Thread.BeginCriticalRegion%2A> 및 <xref:System.Threading.Thread.EndCriticalRegion%2A>을 사용하여 모든 잠금을 표시하고 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="9292e-194">루프에서 <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> 및 <xref:System.Threading.Interlocked.Decrement%2A>를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="9292e-195">이러한 메서드의 Win32 변형에 대한 플랫폼 호출을 수행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="9292e-196">루프에서 <xref:System.Threading.Thread.Sleep%2A>을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="9292e-197">Volatile 필드를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="9292e-198">정리 코드는 catch를 수행 하는 것이 아니라 finally 또는 catch 블록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="9292e-199">정리 코드는 `catch` 블록을 수행하지 않아야 합니다. `finally` 또는 `catch` 블록 자체에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="9292e-200">이 방법은 정상적인 모범 사례여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-200">This should be a normal good practice.</span></span> <span data-ttu-id="9292e-201">`finally` 블록은 예외가 throw되고 `try` 블록이 정상적으로 종료될 때 모두 동일한 코드를 실행하므로 일반적으로 사용이 선호됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="9292e-202">예기치 않은 예외가 throw되는 경우(예: <xref:System.Threading.ThreadAbortException>) 정리 코드가 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="9292e-203">누출을 방지하기 위해 `finally`에서 정리할 관리되지 않는 리소스는 <xref:System.Runtime.InteropServices.SafeHandle>로 래핑하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="9292e-204">C# `using` 키워드는 핸들 등의 개체를 삭제하는 데 효과적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="9292e-205"><xref:System.AppDomain> 재활용을 통해 종료자 스레드에서 리소스를 정리할 수 있지만 정리 코드를 올바른 위치에 두는 것이 여전히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="9292e-206">스레드에서 잠금을 보유하지 않고 비동기 예외를 받는 경우 CLR에서 <xref:System.AppDomain>을 재활용할 필요 없이 스레드를 종료하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="9292e-207">리소스를 늦게 정리하는 것보다 빨리 정리하면 더 많은 리소스가 사용 가능하게 되므로 수명 관리가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="9292e-208">일부 오류 코드 경로에 있는 파일의 핸들을 명시적으로 종료하는 경우가 아니면 <xref:System.Runtime.InteropServices.SafeHandle> 종료자가 정리할 때까지 기다립니다. 다음번에 코드를 실행할 때 종료자가 아직 실행되지 않았으면 똑같은 파일에 액세스하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="9292e-209">따라서 정리 코드가 있고 제대로 작동하는지 확인하면 실패에서 더 깔끔하고 신속하게 복구할 수 있습니다. 그러나 필수는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-210">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-210">Code analysis rule</span></span>

<span data-ttu-id="9292e-211">`catch` 다음에 있는 정리 코드는 `finally` 블록에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="9292e-212">삭제할 호출을 finally 블록에 둡니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="9292e-213">`catch` 블록은 throw 또는 rethrow로 종료되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="9292e-214">네트워크 연결 설정 여부를 감지하며 다수의 예외가 발생할 수 있는 코드에서와 같이 예외가 발생할 수 있지만, 정상 상황에서 다수의 예외를 catch해야 하는 코드에서는 성공 여부를 확인하기 위해 코드를 테스트해야 한다고 표시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="9292e-215">응용 프로그램 도메인 간의 프로세스 차원의 변경 가능 공유 상태는 제거 하거나 제약이 있는 실행 영역을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="9292e-216">소개에 설명된 것처럼 애플리케이션 도메인 간에 프로세스 전체 공유 상태를 안정되게 모니터하는 관리 코드를 작성하기는 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="9292e-217">프로세스 전체 공유 상태는 Win32 코드, CLR 내부 또는 원격을 사용하여 관리 코드 내에서 애플리케이션 도메인 간에 공유하는 일종의 데이터 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="9292e-218">변경할 수 있는 공유 상태는 관리 코드에서 올바르게 작성하기가 매우 어려우며, 정적 공유 상태를 작성할 때는 상당한 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="9292e-219">프로세스 전체 또는 컴퓨터 전체 공유 상태가 있으면 제거 방법을 찾거나 제약이 있는 실행 지역(CER)을 사용하여 공유 상태를 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="9292e-220">공유 상태의 라이브러리를 식별하여 정정하지 않으면 정리 <xref:System.AppDomain> 언로드가 필요한 호스트(예: SQL Server)를 중단시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="9292e-221">코드에서 COM 개체를 사용하는 경우 애플리케이션 도메인 간에 COM 개체를 공유하지 않게 하세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="9292e-222">잠금은 프로세스 전체 또는 응용 프로그램 도메인 간에 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="9292e-223">이전에는 <xref:System.Threading.Monitor.Enter%2A> 및 [lock 문](../../csharp/language-reference/keywords/lock-statement.md)을 사용하여 전역 프로세스 잠금을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="9292e-224">예를 들어, 이 동작은 <xref:System.AppDomain> agile 클래스에서 잠글 때 발생합니다(예: 비공유 어셈블리의 <xref:System.Type> 인스턴스, <xref:System.Threading.Thread> 개체, 인턴 지정 문자열 및 원격을 사용하여 애플리케이션 도메인 간에 공유하는 문자열).</span><span class="sxs-lookup"><span data-stu-id="9292e-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="9292e-225">이러한 잠금은 더 이상 프로세스 전체에 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="9292e-226">프로세스 전체 애플리케이션 도메인 간 잠금의 현재 상태를 파악하려면 잠금 내의 코드에서 디스크의 파일 또는 데이터베이스와 같은 외부 영구 리소스를 사용하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="9292e-227"><xref:System.AppDomain>에서 잠금을 사용하면 보호된 코드에서 외부 리소스를 사용하는 경우 문제가 발생할 수 있습니다. 해당 코드가 여러 애플리케이션 도메인에서 동시에 실행될 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="9292e-228">그러면 한 로그 파일에 쓰거나 전체 프로세스를 위해 소켓에 바인딩할 때 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="9292e-229">이러한 변경은 명명된 <xref:System.Threading.Mutex> 또는 <xref:System.Threading.Semaphore> 인스턴스를 사용하는 방법 외에 관리 코드를 사용하여 프로세스-전역 잠금을 얻기가 쉽지 않다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="9292e-230">두 애플리케이션 도메인에서 동시에 실행되지 않는 코드를 만들거나 <xref:System.Threading.Mutex> 또는 <xref:System.Threading.Semaphore> 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="9292e-231">기존 코드를 변경할 수 없으면 이 동기화를 달성하는 데 Win32 명명된 뮤텍스를 사용하지 마세요. 파이버 모드에서 실행하면 동일한 운영 체제 스레드가 뮤텍스를 확보하고 해제하지 못할 수도 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="9292e-232">비관리 코드를 사용하여 잠금을 동기화하는 대신 CLR에서 알고 있는 방식으로 코드 잠금을 동기화하려면 관리되는 <xref:System.Threading.Mutex> 클래스 또는 명명된 <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent> 또는 <xref:System.Threading.Semaphore>를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="9292e-233">lock(typeof(MyType)) 방지</span><span class="sxs-lookup"><span data-stu-id="9292e-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="9292e-234">모든 애플리케이션 도메인 간에 공유되는 코드 복사본이 하나뿐인 공유 어셈블리의 개인 및 공용 <xref:System.Type> 개체도 문제를 초래합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="9292e-235">공유 어셈블리의 경우 <xref:System.Type> 인스턴스는 프로세스당 하나뿐입니다. 즉, 여러 애플리케이션 도메인에서 똑같은 <xref:System.Type> 인스턴스를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="9292e-236"><xref:System.Type> 인스턴스에서 잠금을 사용하면 단지 <xref:System.AppDomain>만이 아니라 전체 프로세스에 영향을 미치는 잠금을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="9292e-237">하나의 <xref:System.AppDomain>이 <xref:System.Type> 개체에서 잠금을 사용하면 해당 스레드가 갑자기 중단되고 잠금을 릴리스하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="9292e-238">그러면 이 잠금으로 인해 다른 애플리케이션 도메인이 교착 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="9292e-239">정적 메서드에서 잠금을 사용하려면 정적 내부 동기화 개체를 코드에 추가하는 것이 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="9292e-240">개체가 하나 있으면 클래스 생성자에서 초기화할 수 있지만, 없으면 다음과 같이 초기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="9292e-241">잠금을 사용할 때 `InternalSyncObject` 속성을 사용하여 잠글 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="9292e-242">클래스 생성자에서 내부 동기화 개체를 초기화한 경우 이 속성을 사용하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="9292e-243">이중 검사 잠금 초기화 코드는 다음 예와 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="9292e-244">잠금에 대 한 참고 사항 (this)</span><span class="sxs-lookup"><span data-stu-id="9292e-244">A note about lock(this)</span></span>

<span data-ttu-id="9292e-245">공개적으로 액세스할 수 있는 개별 개체에서는 일반적으로 잠금을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="9292e-246">그러나 개체가 전체 하위 시스템에서 교착 상태를 초래할 수 있는 단일 개체인 경우에는 추가로 위의 디자인 패턴을 사용해 보세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="9292e-247">예를 들어, 한 <xref:System.Security.SecurityManager> 개체의 잠금으로 인해 <xref:System.AppDomain>에 교착 상태가 발생할 수 있으므로, 전체 <xref:System.AppDomain>을 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="9292e-248">공개적으로 액세스할 수 있는 이 형식의 개체에서 잠금을 사용하지 않는 것이 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="9292e-249">그러나 개별 컬렉션 또는 배열의 잠금은 일반적으로 문제를 초래하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-250">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-250">Code analysis rule</span></span>

<span data-ttu-id="9292e-251">애플리케이션 도메인 간에 사용할 수 있거나 엄격한 ID 규칙이 없는 형식에서는 잠금을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="9292e-252"><xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> 또는 <xref:System.MarshalByRefObject>에서 파생된 개체에서는 <xref:System.Threading.Monitor.Enter%2A>를 호출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="9292e-253">GC를 제거 합니다. KeepAlive 호출</span><span class="sxs-lookup"><span data-stu-id="9292e-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="9292e-254">상당한 양의 기존 코드에서<xref:System.GC.KeepAlive%2A>를 사용해야 하지만 그렇지 않거나, 사용이 적절하지 않을 때 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="9292e-255"><xref:System.Runtime.InteropServices.SafeHandle>로 변환한 후에는 클래스에서 <xref:System.GC.KeepAlive%2A>를 호출하지 않아도 되며, 종료자가 없지만 <xref:System.Runtime.InteropServices.SafeHandle>을 사용하여 운영 체제 핸들을 종료한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="9292e-256"><xref:System.GC.KeepAlive%2A>에 대한 호출을 유지하는 데 따른 성능 저하는 무시할 수 있지만, <xref:System.GC.KeepAlive%2A>에 대한 호출이 필요하거나 더 이상 존재하지 않는 수명 문제를 해결하는 데 충분하다는 인식 때문에 코드를 유지하기가 더 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="9292e-257">그러나 COM interop CLR 호출 가능 래퍼(RCW)를 사용할 때 <xref:System.GC.KeepAlive%2A>가 여전히 코드에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-258">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-258">Code analysis rule</span></span>

<span data-ttu-id="9292e-259"><xref:System.GC.KeepAlive%2A>를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="9292e-260">HostProtection 특성 사용</span><span class="sxs-lookup"><span data-stu-id="9292e-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="9292e-261"><xref:System.Security.Permissions.HostProtectionAttribute>(HPA)에서는 호스트 보호 요구 사항을 판별하기 위해 선언적 보호 작업 사용을 제공하므로, 호스트가 완전히 신뢰할 수 있는 코드에서도 SQL Server용 <xref:System.Environment.Exit%2A> 또는 <xref:System.Windows.Forms.MessageBox.Show%2A>와 같이 지정된 호스트에 적합하지 않은 특정 호스트를 호출하지 못하게 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="9292e-262">HPA는 공용 언어 런타임을 호스트하고 SQL Server와 같은 호스트 보호를 구현하는 관리되지 않는 애플리케이션에서만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="9292e-263">적용되면 보안 작업에서 클래스 또는 메서드가 노출하는 호스트 리소스를 기반으로 링크 요구 사항을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="9292e-264">호스트에서 보호되지 않는 서버나 클라이언트 애플리케이션에서 코드가 실행되면 “evaporates” 특성이 감지되지 않으므로 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9292e-265">이 특성은 보안 동작이 아니라 호스트별 프로그래밍 모델 지침을 적용하는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="9292e-266">링크 요구 사항을 사용하여 프로그래밍 모델 요구 사항을 만족하는지 확인하지만 <xref:System.Security.Permissions.HostProtectionAttribute>는 보안 권한이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="9292e-267">호스트에 프로그래밍 모델 요구 사항이 없으면 링크 요구가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="9292e-268">이 특성을 사용하여 다음을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="9292e-269">호스트 프로그래밍 모델에 적합하지 않지만 달리 유해하지 않은 메서드 또는 클래스.</span><span class="sxs-lookup"><span data-stu-id="9292e-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="9292e-270">호스트 프로그래밍 모델에 적합하지 않으며 서버 관리 사용자 코드를 불안정하게 만드는 메서드 또는 클래스.</span><span class="sxs-lookup"><span data-stu-id="9292e-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="9292e-271">호스트 프로그래밍 모델에 적합하지 않으며 서버 프로세스 자체를 불안정하게 만드는 메서드 또는 클래스.</span><span class="sxs-lookup"><span data-stu-id="9292e-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="9292e-272">호스트 보호 환경에서 실행할 수 있는 애플리케이션에서 호출할 클래스 라이브러리를 만드는 경우 <xref:System.Security.Permissions.HostProtectionResource> 리소스 범주를 노출하는 멤버에 이 특성을 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="9292e-273">이 특성과 함께 .NET Framework 클래스 라이브러리 멤버를 사용하면 즉각적인 호출자만 검사하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="9292e-274">사용자의 라이브러리 멤버도 이와 동일한 방식으로 즉각적인 호출자 검사만 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="9292e-275"><xref:System.Security.Permissions.HostProtectionAttribute>에 HPA에 대한 자세한 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-276">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-276">Code analysis rule</span></span>

<span data-ttu-id="9292e-277">SQL Server의 경우 동기화 또는 스레딩을 소개하는 데 사용한 모든 메서드는 HPA를 사용하여 식별해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="9292e-278">여기에는 상태를 공유하거나 동기화되거나 외부 프로세스를 관리하는 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="9292e-279">SQL Server에 영향을 주는 <xref:System.Security.Permissions.HostProtectionResource> 값은 <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> 및 <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="9292e-280">그러나 SQL에 영향을 미치는 리소스를 사용하는 메서드뿐 아니라 <xref:System.Security.Permissions.HostProtectionResource>를 노출하는 모든 메서드를 HPA를 통해 식별해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="9292e-281">비관리 코드에서 무기한 차단 안 함</span><span class="sxs-lookup"><span data-stu-id="9292e-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="9292e-282">관리 코드가 아니라 비관리 코드에서 차단하면 CLR에서 스레드를 중단할 수 없으므로 서비스 거부 공격이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="9292e-283">스레드가 차단되면 극도로 안전하지 않은 작업을 수행하지 않고 CLR에서 <xref:System.AppDomain>을 언로드하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="9292e-284">Windows 동기화 기본 형식을 사용 하 여 차단 하는 것은 허용 되지 않는 항목의 명확한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="9292e-285">가능한 경우 소켓에서 호출을 차단 하는 것은 피해 야 합니다 `ReadFile` . 즉, WINDOWS API가 시간 초과와 같은 작업에 대 한 메커니즘을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="9292e-286">네이티브를 호출하는 모든 메서드는 적절한 시간 제한 내에 Win32 호출을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="9292e-287">사용자가 시간 제한을 지정할 수 있으면 특정 보안 권한이 없이는 무한 시간을 지정할 수 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="9292e-288">참고로 메서드를 10초가 넘게 차단할 경우 시간 제한을 지원하는 버전을 사용하거나 추가 CLR 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="9292e-289">다음은 문제가 있는 Api의 몇 가지 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="9292e-290">파이프(익명 파이프 및 명명된 파이프 모두)는 시간 제한을 지정하여 만들 수 있지만, 코드에서 NMPWAIT_WAIT_FOREVER를 사용하여 `CreateNamedPipe`와 `WaitNamedPipe`를 호출하지 않게 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="9292e-291">또한 시간 제한이 지정된 경우에도 예기치 않은 차단이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="9292e-292">익명 파이프에서 수행되는 `WriteFile` 호출은 모든 바이트를 작성할 때까지 차단됩니다. 즉, 버퍼에 읽지 않은 데이터가 있으면 판독기에서 파이프 버퍼의 공간을 확보할 때까지 `WriteFile` 호출이 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="9292e-293">소켓에서는 시간 제한 메커니즘을 준수하는 API를 항상 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-294">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-294">Code analysis rule</span></span>

<span data-ttu-id="9292e-295">비관리 코드에서 시간 제한 없이 차단하는 것은 서비스 거부 공격입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="9292e-296">`WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` 및 `MsgWaitForMultipleObjectsEx`에 대한 플랫폼 호출을 수행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="9292e-297">NMPWAIT_WAIT_FOREVER를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="9292e-298">모든 STA 종속 기능 식별</span><span class="sxs-lookup"><span data-stu-id="9292e-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="9292e-299">COM STA(단일 스레드 아파트)를 사용하는 코드를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="9292e-300">STA는 SQL Server 프로세스에서 비활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="9292e-301">성능 카운터 또는 클립보드와 같이 `CoInitialize`를 사용하는 기능은 SQL Server에서 비활성화되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="9292e-302">종료 자가 동기화 문제가 없는지 확인</span><span class="sxs-lookup"><span data-stu-id="9292e-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="9292e-303">향후 버전의 .NET Framework에 여러 종료자 스레드가 있을 수 있습니다. 즉, 동일한 형식의 여러 다른 인스턴스에 대해 종료자가 동시에 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="9292e-304">스레드로부터 완전히 안전하지 않아도 됩니다. 가비지 수집기에서는 하나의 스레드만 지정된 개체 인스턴스에 대해 종료자를 실행하도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="9292e-305">그러나 여러 다른 개체 인스턴스에서 동시에 실행될 때 경합 상태와 교착 상태를 방지하도록 종료자를 코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="9292e-306">종료자에서 로그 파일에 쓰기와 같이 외부 상태를 사용하는 경우 스레딩 문제를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="9292e-307">종료에서 스레드 보안을 제공할 것으로 의존하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="9292e-308">스레드 로컬 스토리지, 관리 또는 네이티브를 사용하여 종료자 스레드에 상태를 저장하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-309">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-309">Code analysis rule</span></span>

<span data-ttu-id="9292e-310">종료자에 동기화 문제가 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="9292e-311">종료자에서 정적 변경 가능 상태를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="9292e-312">가능 하면 관리 되지 않는 메모리 방지</span><span class="sxs-lookup"><span data-stu-id="9292e-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="9292e-313">운영 체제 핸들과 마찬가지로 관리되지 않는 메모리는 누출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="9292e-314">가능하면 [stackalloc](../../csharp/language-reference/operators/stackalloc.md)를 사용하는 스택의 메모리, 고정된 관리 개체(예: [fixed 문](../../csharp/language-reference/keywords/fixed-statement.md)) 또는 byte[]를 사용하는 <xref:System.Runtime.InteropServices.GCHandle>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="9292e-315">결국 <xref:System.GC>에서 정리합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="9292e-316">그러나 관리되지 않는 메모리를 할당해야 하는 경우 <xref:System.Runtime.InteropServices.SafeHandle>에서 파생되는 클래스를 사용하여 메모리 할당을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="9292e-317"><xref:System.Runtime.InteropServices.SafeHandle>이 적합하지 않은 경우가 하나 이상 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="9292e-318">메모리를 할당하거나 해제하는 COM 메서드 호출의 경우 한 DLL에서 `CoTaskMemAlloc`를 통해 메모리를 할당한 다음 다른 DLL에서 `CoTaskMemFree`로 메모리를 해제하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="9292e-319">이러한 위치에서 <xref:System.Runtime.InteropServices.SafeHandle>을 사용하면 다른 DLL에서 메모리의 수명을 제어하도록 허용하지 않고 관리되지 않는 메모리의 수명을 <xref:System.Runtime.InteropServices.SafeHandle>의 수명과 연결하려고 하므로 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="9292e-320">Catch의 모든 사용 검토 (예외)</span><span class="sxs-lookup"><span data-stu-id="9292e-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="9292e-321">하나의 특정 예외가 아니라 모든 예외를 catch하는 Catch 블록은 이제 비동기 예외도 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="9292e-322">모든 catch(Exception) 블록을 검사하여 건너뛸 수 있는 중요한 리소스 해제 또는 취소 코드가 없으며, <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> 또는 <xref:System.OutOfMemoryException>을 처리하는 catch 블록 자체에 잘못된 동작이 없는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="9292e-323">이 코드에서는 특정 예외만 볼 수 있거나 예외가 발생할 때마다 단 하나의 특정 이유로 인해 실패한다고 가정하거나 로깅 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="9292e-324"><xref:System.Threading.ThreadAbortException>을 포함하도록 이러한 가정을 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="9292e-325">문자열 형식 메서드의 <xref:System.FormatException>과 같이 예외가 throw될 것으로 예상하는 특정 형식의 예외를 catch하도록 모든 예외를 catch하는 위치를 모두 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="9292e-326">그러면 catch 블록이 예기치 않은 예외에 대해 실행되지 않으며 예기치 않은 예외를 catch하여 코드에서 버그를 숨기지 않게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="9292e-327">일반적으로 규칙은 라이브러리 코드의 예외를 처리하지 않습니다(예외를 catch해야 하는 코드가 호출하는 코드의 디자인 결함을 나타낼 수 있음).</span><span class="sxs-lookup"><span data-stu-id="9292e-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="9292e-328">경우에 따라 더 많은 데이터를 제공하기 위해 예외를 catch하여 여러 다른 예외 형식을 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="9292e-329">이 경우 중첩 예외를 사용하면 새로운 예외의 <xref:System.Exception.InnerException%2A> 속성에 실패의 실제 이유를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-330">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-330">Code analysis rule</span></span>

<span data-ttu-id="9292e-331">관리 코드에서 모든 개체를 catch하거나 모든 예외를 catch하는 모든 catch 블록을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="9292e-332">C #에서이는 및의 플래그를 나타냅니다 `catch` {} `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="9292e-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="9292e-333">예외 형식을 매우 구체적으로 만들거나 코드를 검토하여 예기치 않은 예외 형식을 catch하는 경우 잘못된 방식으로 작동하지 않게 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="9292e-334">관리 되는 스레드가 Win32 스레드 라고 가정 하지 않음-파이버입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="9292e-335">관리되는 스레드 로컬 스토리지를 사용하는 것은 가능하지만, 관리되지 않는 스레드 로컬 스토리지를 사용하지 않거나 코드가 현재 운영 체제 스레드에서 다시 실행된다고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="9292e-336">스레드 로캘과 같은 설정은 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="9292e-337">플랫폼 호출을 통해 `InitializeCriticalSection` 또는 `CreateMutex`를 호출하지 마세요. 잠금을 시작하는 운영 체제 스레드가 잠금을 종료해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="9292e-338">파이버를 사용할 때는 해당되지 않으므로, Win32 중요 섹션과 뮤텍스를 SQL에서 직접 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="9292e-339">관리되는 <xref:System.Threading.Mutex> 클래스에서는 이러한 스레드 선호도 문제를 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="9292e-340">관리되는 스레드 로컬 스토리지 및 스레드의 현재 UI 문화권을 포함하여 대부분의 상태를 관리되는 <xref:System.Threading.Thread> 개체에서 안전하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="9292e-341"><xref:System.ThreadStaticAttribute>도 사용할 수 있습니다. 그러면 현재 관리되는 스레드에서만 기존 정적 변수의 값에 액세스할 수 있습니다(이는 CLR에서 파이버 로컬 스토리지를 수행하는 또 다른 방법임).</span><span class="sxs-lookup"><span data-stu-id="9292e-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="9292e-342">프로그래밍 모델 때문에 SQL에서 실행할 때 현재 스레드의 문화권을 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-343">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-343">Code analysis rule</span></span>

<span data-ttu-id="9292e-344">SQL Server는 파이버 모드로 실행됩니다. 스레드 로컬 스토리지를 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="9292e-345">`TlsAlloc`, `TlsFree`, `TlsGetValue` 및 `TlsSetValue.`에 대한 플랫폼 호출을 수행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="9292e-346">SQL Server 가장을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="9292e-347">가장은 스레드 수준에서 작동하고 SQL은 파이버 모드에서 실행될 수 있으므로 관리 코드에서는 사용자를 가장하지 않아야 하며 `RevertToSelf`를 호출하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-348">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-348">Code analysis rule</span></span>

<span data-ttu-id="9292e-349">SQL Server 핸들 가장 허용</span><span class="sxs-lookup"><span data-stu-id="9292e-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="9292e-350">`RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` 또는 `SetThreadToken`을 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="9292e-351">Thread:: Suspend를 호출 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9292e-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="9292e-352">스레드를 일시 중단하는 기능은 간단한 작업처럼 보일 수 있지만 교착 상태를 초래할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="9292e-353">두 번째 스레드가 잠금을 보유하는 스레드를 일시 중단한 다음 동일한 잠금을 사용하려고 하면 교착 상태가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="9292e-354"><xref:System.Threading.Thread.Suspend%2A>는 현재 보안, 클래스 로드, 원격 및 리플렉션을 방해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="9292e-355">코드 분석 규칙</span><span class="sxs-lookup"><span data-stu-id="9292e-355">Code analysis rule</span></span>

<span data-ttu-id="9292e-356"><xref:System.Threading.Thread.Suspend%2A>를 호출하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="9292e-357">대신 <xref:System.Threading.Semaphore> 또는 <xref:System.Threading.ManualResetEvent>와 같은 실제 동기화 기본 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="9292e-358">제약이 있는 실행 영역 및 안정성 계약을 사용 하 여 중요 한 작업 보호</span><span class="sxs-lookup"><span data-stu-id="9292e-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="9292e-359">공유 상태를 업데이트하거나 완벽한 성공 또는 실패 여부를 판별해야 하는 복잡한 작업을 수행할 때 제약이 있는 실행 영역(CER)으로 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="9292e-360">그러면 갑작스러운 스레드 중단 또는 갑작스러운 <xref:System.AppDomain> 언로드 시에도 코드가 항상 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="9292e-361">CER은 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>에 대한 호출 바로 다음에 오는 특정 `try/finally` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="9292e-362">그러면 `try` 블록을 실행하기 전에 finally 블록의 모든 코드를 준비하도록 Just-In-Time 컴파일러에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="9292e-363">그러면 finally 블록의 코드가 빌드되고 경우에 상관없이 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="9292e-364">CER에서 `try` 블록이 비어 있는 경우가 드물지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="9292e-365">CER을 사용하여 비동기 스레드 중단 및 메모리 부족 예외로부터 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="9292e-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="9292e-366">매우 복잡한(deep) 코드의 스택 오버플로를 추가로 처리하는 CER 양식은 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9292e-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="9292e-367">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9292e-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="9292e-368">SQL Server 프로그래밍 및 호스트 보호 특성</span><span class="sxs-lookup"><span data-stu-id="9292e-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
