---
title: Azure 플랫폼 복원 력
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | Azure를 사용 하는 클라우드 인프라 복원 력
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 88634bc60df15cc93b1769a85879795ae383757a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91163767"
---
# <a name="azure-platform-resiliency"></a><span data-ttu-id="12c97-103">Azure 플랫폼 복원 력</span><span class="sxs-lookup"><span data-stu-id="12c97-103">Azure platform resiliency</span></span>

<span data-ttu-id="12c97-104">클라우드에서 신뢰할 수 있는 응용 프로그램을 구축 하는 것은 기존 온-프레미스 응용 프로그램 개발과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-104">Building a reliable application in the cloud is different from traditional on-premises application development.</span></span> <span data-ttu-id="12c97-105">지금까지 강화 하기 위해 고급 하드웨어를 구입 했지만, 클라우드 환경에서는 규모를 확장 합니다. 목표는 오류를 방지 하는 것이 아니라 영향을 최소화 하 고 시스템을 안정적으로 유지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-105">While historically you purchased higher-end hardware to scale up, in a cloud environment you scale out. Instead of trying to prevent failures, the goal is to minimize their effects and keep the system stable.</span></span>

<span data-ttu-id="12c97-106">즉, 신뢰할 수 있는 클라우드 응용 프로그램은 다음과 같은 고유한 특성을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-106">That said, reliable cloud applications display distinct characteristics:</span></span>

- <span data-ttu-id="12c97-107">복원 력을 유지 하 고 문제를 해결 하며 계속 해 서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-107">They're resilient, recover gracefully from problems, and continue to function.</span></span>
- <span data-ttu-id="12c97-108">HA (고가용성) 이며 상당한 가동 중지 시간 없이 정상 상태에서 설계 된 대로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-108">They're highly available (HA) and run as designed in a healthy state with no significant downtime.</span></span>

<span data-ttu-id="12c97-109">이러한 특징이 함께 작동 하는 방식과 비용에 미치는 영향을 이해 하는 것은 안정적인 클라우드 네이티브 응용 프로그램을 구축 하는 데 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-109">Understanding how these characteristics work together - and how they affect cost - is essential to building a reliable cloud-native application.</span></span> <span data-ttu-id="12c97-110">다음으로 Azure 클라우드의 기능을 활용 하 여 클라우드 네이티브 응용 프로그램에 복원 력 및 가용성을 구축할 수 있는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-110">We'll next look at ways that you can build resiliency and availability into your cloud-native applications leveraging features from the Azure cloud.</span></span>

## <a name="design-with-resiliency"></a><span data-ttu-id="12c97-111">복원 력을 사용 하 여 디자인</span><span class="sxs-lookup"><span data-stu-id="12c97-111">Design with resiliency</span></span>

<span data-ttu-id="12c97-112">복원 력을 통해 응용 프로그램은 오류에 대응 하 여 계속 작동 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-112">We've said resiliency enables your application to react to failure and still remain functional.</span></span> <span data-ttu-id="12c97-113">[Azure의 복원 력](https://azure.microsoft.com/mediahandler/files/resourcefiles/resilience-in-azure-whitepaper/Resilience%20in%20Azure.pdf)백서에서는 azure 플랫폼에서 복원 력을 달성 하기 위한 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-113">The whitepaper, [Resilience in Azure whitepaper](https://azure.microsoft.com/mediahandler/files/resourcefiles/resilience-in-azure-whitepaper/Resilience%20in%20Azure.pdf), provides guidance for achieving resilience in the Azure platform.</span></span> <span data-ttu-id="12c97-114">몇 가지 주요 권장 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-114">Here are some key recommendations:</span></span>

- <span data-ttu-id="12c97-115">*하드웨어 오류입니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-115">*Hardware failure.*</span></span> <span data-ttu-id="12c97-116">여러 장애 도메인에 구성 요소를 배포 하 여 응용 프로그램에 중복성을 구축 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-116">Build redundancy into the application by deploying components across different fault domains.</span></span> <span data-ttu-id="12c97-117">예를 들어 가용성 집합을 사용 하 여 Azure Vm이 다른 랙에 배치 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-117">For example, ensure that Azure VMs are placed in different racks by using Availability Sets.</span></span>

- <span data-ttu-id="12c97-118">*데이터 센터 오류입니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-118">*Datacenter failure.*</span></span> <span data-ttu-id="12c97-119">데이터 센터의 오류 격리 영역을 통해 응용 프로그램에 중복성을 구축 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-119">Build redundancy into the application with fault isolation zones across datacenters.</span></span> <span data-ttu-id="12c97-120">예를 들어 Azure 가용성 영역를 사용 하 여 Azure Vm이 서로 다른 오류 데이터 센터에 배치 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-120">For example, ensure that Azure VMs are placed in different fault-isolated datacenters by using Azure Availability Zones.</span></span>

- <span data-ttu-id="12c97-121">*지역 오류입니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-121">*Regional failure.*</span></span> <span data-ttu-id="12c97-122">응용 프로그램을 신속 하 게 복구할 수 있도록 데이터 및 구성 요소를 다른 지역에 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-122">Replicate the data and components into another region so that applications can be quickly recovered.</span></span> <span data-ttu-id="12c97-123">예를 들어 Azure Site Recovery를 사용 하 여 Azure Vm을 다른 Azure 지역에 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-123">For example, use Azure Site Recovery to replicate Azure VMs to another Azure region.</span></span>

- <span data-ttu-id="12c97-124">*부하가 높습니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-124">*Heavy load.*</span></span> <span data-ttu-id="12c97-125">인스턴스의 부하를 분산 하 여 사용량 급증을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-125">Load balance across instances to handle spikes in usage.</span></span> <span data-ttu-id="12c97-126">예를 들어 부하 분산 장치 뒤에 둘 이상의 Azure Vm을 배치 하 여 모든 Vm에 트래픽을 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-126">For example, put two or more Azure VMs behind a load balancer to distribute traffic to all VMs.</span></span>

- <span data-ttu-id="12c97-127">*실수로 인 한 데이터 삭제 또는 손상입니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-127">*Accidental data deletion or corruption.*</span></span> <span data-ttu-id="12c97-128">삭제 또는 손상이 있는 경우 데이터를 복원할 수 있도록 데이터를 백업 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-128">Back up data so it can be restored if there’s any deletion or corruption.</span></span> <span data-ttu-id="12c97-129">예를 들어 Azure Backup를 사용 하 여 Azure Vm을 주기적으로 백업 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-129">For example, use Azure Backup to periodically back up your Azure VMs.</span></span>

## <a name="design-with-redundancy"></a><span data-ttu-id="12c97-130">중복성으로 디자인</span><span class="sxs-lookup"><span data-stu-id="12c97-130">Design with redundancy</span></span>

<span data-ttu-id="12c97-131">오류는 영향 범위에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-131">Failures vary in scope of impact.</span></span> <span data-ttu-id="12c97-132">하드웨어 오류 (예: 실패 한 디스크)는 클러스터의 단일 노드에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-132">A hardware failure, such as a failed disk, can affect a single node in a cluster.</span></span> <span data-ttu-id="12c97-133">실패 한 네트워크 스위치는 전체 서버 랙에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-133">A failed network switch could affect an entire server rack.</span></span> <span data-ttu-id="12c97-134">전력 손실과 같이 일반적이 지 않은 오류는 전체 데이터 센터에 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-134">Less common failures, such as loss of power, could disrupt a whole datacenter.</span></span> <span data-ttu-id="12c97-135">드물게 전체 지역을 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-135">Rarely, an entire region becomes unavailable.</span></span>

<span data-ttu-id="12c97-136">[중복성](/azure/architecture/guide/design-principles/redundancy) 은 응용 프로그램 복원 력을 제공 하는 한 가지 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-136">[Redundancy](/azure/architecture/guide/design-principles/redundancy) is one way to provide application resilience.</span></span> <span data-ttu-id="12c97-137">필요한 정확한 중복성 수준은 비즈니스 요구 사항에 따라 다르며 시스템의 비용과 복잡도에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-137">The exact level of redundancy needed depends upon your business requirements and will affect both the cost and complexity of your system.</span></span> <span data-ttu-id="12c97-138">예를 들어 다중 지역 배포는 단일 지역 배포 보다 더 비용이 많이 들고 관리가 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-138">For example, a multi-region deployment is more expensive and more complex to manage than a single-region deployment.</span></span> <span data-ttu-id="12c97-139">장애 조치 (failover) 및 장애 복구를 관리 하려면 운영 절차가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-139">You'll need operational procedures to manage failover and failback.</span></span> <span data-ttu-id="12c97-140">일부 비즈니스 시나리오에서는 추가 비용 및 복잡성이 정당화 될 수 있지만 다른 비즈니스 시나리오는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-140">The additional cost and complexity might be justified for some business scenarios, but not others.</span></span>

<span data-ttu-id="12c97-141">중복성을 설계 하려면 응용 프로그램에서 중요 한 경로를 확인 한 다음 경로의 각 지점에서 중복성이 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-141">To architect redundancy, you need to identify the critical paths in your application, and then determine if there's redundancy at each point in the path?</span></span> <span data-ttu-id="12c97-142">하위 시스템이 실패 하는 경우 응용 프로그램이 다른 작업으로 장애 조치 (failover) 되나요?</span><span class="sxs-lookup"><span data-stu-id="12c97-142">If a subsystem should fail, will the application fail over to something else?</span></span> <span data-ttu-id="12c97-143">마지막으로, 중복성 요구 사항을 충족 하기 위해 활용할 수 있는 Azure 클라우드 플랫폼에 기본 제공 되는 기능을 명확 하 게 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-143">Finally, you need a clear understanding of those features built into the Azure cloud platform that you can leverage to meet your redundancy requirements.</span></span> <span data-ttu-id="12c97-144">중복성 설계에 대 한 권장 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-144">Here are recommendations for architecting redundancy:</span></span>

- <span data-ttu-id="12c97-145">*서비스의 여러 인스턴스를 배포합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-145">*Deploy multiple instances of services.*</span></span> <span data-ttu-id="12c97-146">애플리케이션이 서비스의 단일 인스턴스에 종속된 경우 단일 실패 지점이 생깁니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-146">If your application depends on a single instance of a service, it creates a single point of failure.</span></span> <span data-ttu-id="12c97-147">여러 인스턴스를 프로비전하면 복원력 및 확장성이 모두 개선됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-147">Provisioning multiple instances improves both resiliency and scalability.</span></span> <span data-ttu-id="12c97-148">Azure Kubernetes Service에서 호스트 하는 경우 Kubernetes 매니페스트 파일에서 중복 인스턴스 (복제본 집합)를 선언적으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-148">When hosting in Azure Kubernetes Service, you can declaratively configure redundant instances (replica sets) in the Kubernetes manifest file.</span></span> <span data-ttu-id="12c97-149">복제본 수 값은 프로그래밍 방식으로, 포털에서 또는 자동 크기 조정 기능을 통해 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-149">The replica count value can be managed programmatically, in the portal, or through autoscaling features.</span></span>

- <span data-ttu-id="12c97-150">*부하 분산 장치 활용*</span><span class="sxs-lookup"><span data-stu-id="12c97-150">*Leveraging a load balancer.*</span></span> <span data-ttu-id="12c97-151">부하 분산은 응용 프로그램의 요청을 정상적인 서비스 인스턴스에 배포 하 고 자동으로 비정상 인스턴스를 회전에서 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-151">Load-balancing distributes your application's requests to healthy service instances and automatically removes unhealthy instances from rotation.</span></span> <span data-ttu-id="12c97-152">Kubernetes에 배포 하는 경우 Kubernetes manifest 파일의 서비스 섹션에서 부하 분산을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-152">When deploying to Kubernetes, load balancing can be specified in the Kubernetes manifest file in the Services section.</span></span>

- <span data-ttu-id="12c97-153">*다중 지역 배포를 계획 합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-153">*Plan for multiregion deployment.*</span></span> <span data-ttu-id="12c97-154">응용 프로그램을 단일 지역에 배포 하는 경우 해당 지역을 사용할 수 없게 되 면 응용 프로그램도 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-154">If you deploy your application to a single region, and that region becomes unavailable, your application will also become unavailable.</span></span> <span data-ttu-id="12c97-155">이는 응용 프로그램의 서비스 수준 계약의 조건에서 허용 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-155">This may be unacceptable under the terms of your application's service level agreements.</span></span> <span data-ttu-id="12c97-156">대신 여러 지역에 응용 프로그램 및 서비스를 배포 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-156">Instead, consider deploying your application and its services across multiple regions.</span></span> <span data-ttu-id="12c97-157">예를 들어 AKS (Azure Kubernetes Service) 클러스터는 단일 지역에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-157">For example, an Azure Kubernetes Service (AKS) cluster is deployed to a single region.</span></span> <span data-ttu-id="12c97-158">지역 장애 로부터 시스템을 보호 하기 위해 응용 프로그램을 여러 지역의 여러 AKS 클러스터에 배포 하 고 [쌍을 이루는 지역](https://buildazure.com/2017/01/06/azure-region-pairs-explained/) 기능을 사용 하 여 플랫폼 업데이트를 조정 하 고 복구 작업의 우선 순위를 정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-158">To protect your system from a regional failure, you might deploy your application to multiple AKS clusters across different regions and use the [Paired Regions](https://buildazure.com/2017/01/06/azure-region-pairs-explained/) feature to coordinate platform updates and prioritize recovery efforts.</span></span>

- <span data-ttu-id="12c97-159">*[지역에서 복제](/azure/sql-database/sql-database-active-geo-replication)를 사용 하도록 설정 합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-159">*Enable [geo-replication](/azure/sql-database/sql-database-active-geo-replication).*</span></span> <span data-ttu-id="12c97-160">Azure SQL Database, Cosmos DB 등의 서비스에 대 한 지역에서 복제는 여러 지역에 걸쳐 데이터의 보조 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-160">Geo-replication for services such as Azure SQL Database and Cosmos DB will create secondary replicas of your data across multiple regions.</span></span> <span data-ttu-id="12c97-161">두 서비스 모두 동일한 지역 내에서 데이터를 자동으로 복제 하지만 지역에서 복제는 보조 지역으로 장애 조치 (failover) 할 수 있도록 하 여 지역 가동 중단 으로부터 사용자를 보호 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-161">While both services will automatically replicate data within the same region, geo-replication protects you against a regional outage by enabling you to fail over to a secondary region.</span></span> <span data-ttu-id="12c97-162">컨테이너 이미지를 저장 하는 방법에 대 한 지리적 복제 센터의 또 다른 모범 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-162">Another best practice for geo-replication centers around storing container images.</span></span> <span data-ttu-id="12c97-163">AKS에 서비스를 배포 하려면 리포지토리에서 이미지를 저장 하 고 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-163">To deploy a service in AKS, you need to store and pull the image from a repository.</span></span> <span data-ttu-id="12c97-164">Azure Container Registry AKS와 통합 되며 컨테이너 이미지를 안전 하 게 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-164">Azure Container Registry integrates with AKS and can securely store container images.</span></span> <span data-ttu-id="12c97-165">성능 및 가용성을 향상 시키려면 이미지를 AKS 클러스터가 있는 각 지역의 레지스트리에 지리적으로 복제 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-165">To improve performance and availability, consider geo-replicating your images to a registry in each region where you have an AKS cluster.</span></span> <span data-ttu-id="12c97-166">그런 다음 그림 6-4에 표시 된 것 처럼 각 AKS 클러스터는 해당 지역의 로컬 컨테이너 레지스트리에서 컨테이너 이미지를 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-166">Each AKS cluster then pulls container images from the local container registry in its region as shown in Figure 6-4:</span></span>

![지역 간 복제 된 리소스](./media/replicated-resources.png)

<span data-ttu-id="12c97-168">**그림 6-4**</span><span class="sxs-lookup"><span data-stu-id="12c97-168">**Figure 6-4**.</span></span> <span data-ttu-id="12c97-169">지역 간 복제 된 리소스</span><span class="sxs-lookup"><span data-stu-id="12c97-169">Replicated resources across regions</span></span>

- <span data-ttu-id="12c97-170">*DNS 트래픽 부하 분산 장치를 구현 합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-170">*Implement a DNS traffic load balancer.*</span></span> <span data-ttu-id="12c97-171">[Azure Traffic Manager](/azure/traffic-manager/traffic-manager-overview) 는 DNS 수준에서 부하 분산을 통해 중요 한 응용 프로그램에 대 한 고가용성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-171">[Azure Traffic Manager](/azure/traffic-manager/traffic-manager-overview) provides high-availability for critical applications by load-balancing at the DNS level.</span></span> <span data-ttu-id="12c97-172">지리적 위치, 클러스터 응답 시간 및 심지어 응용 프로그램 끝점 상태에 따라 다른 지역으로 트래픽을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-172">It can route traffic to different regions based on geography, cluster response time, and even application endpoint health.</span></span> <span data-ttu-id="12c97-173">예를 들어 Azure Traffic Manager는 고객에 게 가장 가까운 AKS 클러스터 및 응용 프로그램 인스턴스로 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-173">For example, Azure Traffic Manager can direct customers to the closest AKS cluster and application instance.</span></span> <span data-ttu-id="12c97-174">서로 다른 지역에 여러 AKS 클러스터가 있는 경우 Traffic Manager를 사용 하 여 각 클러스터에서 실행 되는 응용 프로그램에 대 한 트래픽 흐름 방식을 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-174">If you have multiple AKS clusters in different regions, use Traffic Manager to control how traffic flows to the applications that run in each cluster.</span></span> <span data-ttu-id="12c97-175">그림 6-5에서는이 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-175">Figure 6-5 shows this scenario.</span></span>

![AKS 및 Azure Traffic Manager](./media/aks-traffic-manager.png)

<span data-ttu-id="12c97-177">**그림 6-5**</span><span class="sxs-lookup"><span data-stu-id="12c97-177">**Figure 6-5**.</span></span> <span data-ttu-id="12c97-178">AKS 및 Azure Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="12c97-178">AKS and Azure Traffic Manager</span></span>

## <a name="design-for-scalability"></a><span data-ttu-id="12c97-179">확장성을 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="12c97-179">Design for scalability</span></span>

<span data-ttu-id="12c97-180">클라우드는 크기를 thrives.</span><span class="sxs-lookup"><span data-stu-id="12c97-180">The cloud thrives on scaling.</span></span> <span data-ttu-id="12c97-181">시스템 리소스를 늘리거나 줄여 시스템 부하를 해결 하는 기능은 Azure 클라우드의 주요 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-181">The ability to increase/decrease system resources to address increasing/decreasing system load is a key tenet of the Azure cloud.</span></span> <span data-ttu-id="12c97-182">그러나 응용 프로그램을 효과적으로 확장 하려면 응용 프로그램에 포함 하는 각 Azure 서비스의 크기 조정 기능을 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-182">But, to effectively scale an application, you need an understanding of the scaling features of each Azure service that you include in your application.</span></span>  <span data-ttu-id="12c97-183">시스템에서 크기 조정을 효과적으로 구현 하기 위한 권장 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-183">Here are recommendations for effectively implementing scaling in your system.</span></span>

- <span data-ttu-id="12c97-184">*크기 조정을 위한 디자인.*</span><span class="sxs-lookup"><span data-stu-id="12c97-184">*Design for scaling.*</span></span> <span data-ttu-id="12c97-185">응용 프로그램은 크기 조정을 위해 디자인 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-185">An application must be designed for scaling.</span></span> <span data-ttu-id="12c97-186">시작 하려면 요청을 임의의 인스턴스로 라우팅할 수 있도록 서비스의 상태를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-186">To start, services should be stateless so that requests can be routed to any instance.</span></span> <span data-ttu-id="12c97-187">상태 비저장 서비스가 있으면 인스턴스를 추가 하거나 제거 해도 현재 사용자에 게 부정적인 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-187">Having stateless services also means that adding or removing an instance doesn't adversely impact current users.</span></span>

- <span data-ttu-id="12c97-188">*작업을 분할*합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-188">*Partition workloads*.</span></span> <span data-ttu-id="12c97-189">독립적인 자체 포함 마이크로 서비스로 도메인을 분해 각 서비스를 다른 서비스와 독립적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-189">Decomposing domains into independent, self-contained microservices enable each service to scale independently of others.</span></span> <span data-ttu-id="12c97-190">일반적으로 서비스에는 서로 다른 확장성 요구 사항과 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-190">Typically, services will have different scalability needs and requirements.</span></span> <span data-ttu-id="12c97-191">분할을 사용 하면 전체 응용 프로그램의 크기를 조정 하는 데 불필요 한 비용 없이 크기를 조정 해야 하는 내용만 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-191">Partitioning enables you to scale only what needs to be scaled without the unnecessary cost of scaling an entire application.</span></span>

- <span data-ttu-id="12c97-192">*규모 확장을 선호 합니다.* 클라우드 기반 응용 프로그램은 확장이 아니라 리소스를 확장 하는 것을 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-192">*Favor scale-out.* Cloud-based applications favor scaling out resources as opposed to scaling up.</span></span> <span data-ttu-id="12c97-193">규모 확장 (수평 크기 조정이 라고도 함)은 원하는 수준의 성능을 충족 하 고 공유 하기 위해 기존 시스템에 서비스 리소스를 더 추가 하는 작업을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-193">Scaling out (also known as horizontal scaling) involves adding more service resources to an existing system to meet and share a desired level of performance.</span></span> <span data-ttu-id="12c97-194">수직 확장 (수직 확장이 라고도 함)은 기존 리소스를 더 강력한 하드웨어 (더 많은 디스크, 메모리 및 처리 코어)로 교체 하는 과정을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-194">Scaling up (also known as vertical scaling) involves replacing existing resources with more powerful hardware (more disk, memory, and processing cores).</span></span> <span data-ttu-id="12c97-195">일부 Azure 클라우드 리소스에서 사용할 수 있는 자동 크기 조정 기능을 사용 하 여 확장을 자동으로 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-195">Scaling out can be invoked automatically with the autoscaling features available in some Azure cloud resources.</span></span> <span data-ttu-id="12c97-196">여러 리소스에 걸쳐 확장 하면 전체 시스템에 중복성도 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-196">Scaling out across multiple resources also adds redundancy to the overall system.</span></span> <span data-ttu-id="12c97-197">마지막으로, 단일 리소스를 확장 하는 작업은 일반적으로 더 작은 리소스에서 확장 하는 것 보다 더 비쌉니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-197">Finally scaling up a single resource is typically more expensive than scaling out across many smaller resources.</span></span> <span data-ttu-id="12c97-198">그림 6-6에서는 두 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-198">Figure 6-6 shows the two approaches:</span></span>

![규모 확장 및 규모 확장](./media/scale-up-scale-out.png)

<span data-ttu-id="12c97-200">**그림 6-6.**</span><span class="sxs-lookup"><span data-stu-id="12c97-200">**Figure 6-6.**</span></span> <span data-ttu-id="12c97-201">규모 확장 및 규모 확장</span><span class="sxs-lookup"><span data-stu-id="12c97-201">Scale up versus scale out</span></span>

- <span data-ttu-id="12c97-202">*비례적으로 크기 조정*</span><span class="sxs-lookup"><span data-stu-id="12c97-202">*Scale proportionally.*</span></span> <span data-ttu-id="12c97-203">서비스 크기를 조정 하는 경우 *리소스 집합*을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-203">When scaling a service, think in terms of *resource sets*.</span></span> <span data-ttu-id="12c97-204">특정 서비스를 크게 확장 하는 경우 백 엔드 데이터 저장소, 캐시 및 종속 서비스에 미치는 영향은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="12c97-204">If you were to dramatically scale out a specific service, what impact would that have on back-end data stores, caches and dependent services?</span></span> <span data-ttu-id="12c97-205">Cosmos DB와 같은 일부 리소스는 비례적으로 확장 될 수 있지만 다른 많은 리소스는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-205">Some resources such as Cosmos DB can scale out proportionally, while many others can't.</span></span> <span data-ttu-id="12c97-206">리소스를 다른 연결 된 리소스를 소모 하는 지점으로 확장 하지 않도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-206">You want to ensure that you don't scale out a resource to a point where it will exhaust other associated resources.</span></span>

- <span data-ttu-id="12c97-207">*선호도를 피합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-207">*Avoid affinity.*</span></span> <span data-ttu-id="12c97-208">노드가 로컬 선호도를 필요로 하지 않도록 하는 것이 가장 좋은 방법입니다. 일반적으로 *고정 세션이*라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-208">A best practice is to ensure a node doesn't require local affinity, often referred to as a *sticky session*.</span></span> <span data-ttu-id="12c97-209">요청은 임의의 인스턴스로 라우팅할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-209">A request should be able to route to any instance.</span></span> <span data-ttu-id="12c97-210">상태를 유지 해야 하는 경우 [Azure Redis cache](https://azure.microsoft.com/services/cache/)와 같은 분산 캐시에 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-210">If you need to persist state, it should be saved to a distributed cache, such as [Azure Redis cache](https://azure.microsoft.com/services/cache/).</span></span>

- <span data-ttu-id="12c97-211">*플랫폼 자동 크기 조정 기능을 활용 합니다.*</span><span class="sxs-lookup"><span data-stu-id="12c97-211">*Take advantage of platform autoscaling features.*</span></span> <span data-ttu-id="12c97-212">사용자 지정 또는 타사 메커니즘이 아닌 가능한 경우 기본 제공 자동 크기 조정 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-212">Use built-in autoscaling features whenever possible, rather than custom or third-party mechanisms.</span></span> <span data-ttu-id="12c97-213">가능 하면 예약 된 크기 조정 규칙을 사용 하 여 시작 지연 없이 리소스를 사용할 수 있도록 하 고, 필요에 따라 규칙에 반응 형 자동 크기 조정을 추가 하 여 예기치 않은 수요 변화를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-213">Where possible, use scheduled scaling rules to ensure that resources are available without a startup delay, but add reactive autoscaling to the rules as appropriate, to cope with unexpected changes in demand.</span></span> <span data-ttu-id="12c97-214">자세한 내용은 자동 크기 조정 [지침](/azure/architecture/best-practices/auto-scaling)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="12c97-214">For more information, see [Autoscaling guidance](/azure/architecture/best-practices/auto-scaling).</span></span>

- <span data-ttu-id="12c97-215">*적극적으로 확장 하세요.*</span><span class="sxs-lookup"><span data-stu-id="12c97-215">*Scale out aggressively.*</span></span> <span data-ttu-id="12c97-216">최종 방법은 비즈니스를 잃지 않고 트래픽의 즉각적인 급증을 신속 하 게 충족할 수 있도록 적극적으로 규모를 확장 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-216">A final practice would be to scale out aggressively so that you can quickly meet immediate spikes in traffic without losing business.</span></span> <span data-ttu-id="12c97-217">그리고 시스템을 안정적으로 유지 하기 위해 (즉, 불필요 한 인스턴스 제거)를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-217">And, then scale in (that is, remove unneeded instances) conservatively to keep the system stable.</span></span> <span data-ttu-id="12c97-218">이를 구현 하는 간단한 방법은 크기 조정 작업 사이에 대기 하는 시간, 리소스를 추가 하는 데 5 분, 인스턴스를 제거 하는 데 최대 15 분이 되는 쿨 다운 기간을 설정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-218">A simple way to implement this is to set the cool down period, which is the time to wait between scaling operations, to five minutes for adding resources and up to 15 minutes for removing instances.</span></span>

## <a name="built-in-retry-in-services"></a><span data-ttu-id="12c97-219">서비스의 기본 제공 다시 시도</span><span class="sxs-lookup"><span data-stu-id="12c97-219">Built-in retry in services</span></span>

<span data-ttu-id="12c97-220">이전 섹션에서 프로그래밍 방식으로 다시 시도 하는 작업을 구현 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-220">We encouraged the best practice of implementing programmatic retry operations in an earlier section.</span></span> <span data-ttu-id="12c97-221">많은 Azure 서비스와 해당 클라이언트 Sdk에도 다시 시도 메커니즘이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-221">Keep in mind that many Azure services and their corresponding client SDKs also include retry mechanisms.</span></span> <span data-ttu-id="12c97-222">다음 목록에서는이 책에서 설명 하는 대부분의 Azure 서비스에 대 한 다시 시도 기능을 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-222">The following list summarizes retry features in the many of the Azure services that are discussed in this book:</span></span>

- <span data-ttu-id="12c97-223">*Azure Cosmos DB.*</span><span class="sxs-lookup"><span data-stu-id="12c97-223">*Azure Cosmos DB.*</span></span> <span data-ttu-id="12c97-224"><xref:Microsoft.Azure.Documents.Client.DocumentClient>클라이언트 API의 클래스가 실패 한 시도를 자동으로 받아볼 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-224">The <xref:Microsoft.Azure.Documents.Client.DocumentClient> class from the client API automatically retires failed attempts.</span></span> <span data-ttu-id="12c97-225">재시도 횟수와 최대 대기 시간을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-225">The number of retries and maximum wait time are configurable.</span></span> <span data-ttu-id="12c97-226">클라이언트 API에서 throw 되는 예외는 재시도 정책 또는 일시적이 지 않은 오류를 초과 하는 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-226">Exceptions thrown by the client API are either requests that exceed the retry policy or non-transient errors.</span></span>

- <span data-ttu-id="12c97-227">*Azure Redis Cache.*</span><span class="sxs-lookup"><span data-stu-id="12c97-227">*Azure Redis Cache.*</span></span> <span data-ttu-id="12c97-228">Redis StackExchange 클라이언트는 실패 한 시도에서 재시도를 포함 하는 연결 관리자 클래스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-228">The Redis StackExchange client uses a connection manager class that includes retries on failed attempts.</span></span> <span data-ttu-id="12c97-229">재시도 횟수, 특정 재시도 정책 및 대기 시간을 모두 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-229">The number of retries, specific retry policy and wait time are all configurable.</span></span>

- <span data-ttu-id="12c97-230">*Azure Service Bus.*</span><span class="sxs-lookup"><span data-stu-id="12c97-230">*Azure Service Bus.*</span></span> <span data-ttu-id="12c97-231">Service Bus 클라이언트는 백오프 간격, 다시 시도 횟수 및 작업에 사용할 수 있는 최대 시간을 지정 하는을 사용 하 여 구성할 수 있는 [RetryPolicy 클래스](xref:Microsoft.ServiceBus.RetryPolicy) 를 노출 합니다 <xref:Microsoft.ServiceBus.RetryExponential.TerminationTimeBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="12c97-231">The Service Bus client exposes a [RetryPolicy class](xref:Microsoft.ServiceBus.RetryPolicy) that can be configured with a back-off interval, retry count, and <xref:Microsoft.ServiceBus.RetryExponential.TerminationTimeBuffer%2A>, which specifies the maximum time an operation can take.</span></span> <span data-ttu-id="12c97-232">기본 정책은 시도 사이에 30 초 간격으로 재시도 하는 최대 9 번의 재시도 백오프.</span><span class="sxs-lookup"><span data-stu-id="12c97-232">The default policy is nine maximum retry attempts with a 30-second backoff period between attempts.</span></span>

- <span data-ttu-id="12c97-233">*Azure SQL Database.*</span><span class="sxs-lookup"><span data-stu-id="12c97-233">*Azure SQL Database.*</span></span> <span data-ttu-id="12c97-234">[Entity Framework Core](/ef/core/miscellaneous/connection-resiliency) 라이브러리를 사용 하는 경우 다시 시도 지원이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-234">Retry support is provided when using the [Entity Framework Core](/ef/core/miscellaneous/connection-resiliency) library.</span></span>

- <span data-ttu-id="12c97-235">*Azure Storage.*</span><span class="sxs-lookup"><span data-stu-id="12c97-235">*Azure Storage.*</span></span> <span data-ttu-id="12c97-236">저장소 클라이언트 라이브러리는 다시 시도 작업을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-236">The storage client library support retry operations.</span></span> <span data-ttu-id="12c97-237">전략은 Azure storage 테이블, blob 및 큐에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-237">The strategies vary across Azure storage tables, blobs, and queues.</span></span> <span data-ttu-id="12c97-238">또한 대체 재시도는 지역 중복 기능이 사용 하도록 설정 된 경우 기본 및 보조 저장소 서비스 위치 간에 전환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-238">As well, alternate retries switch between primary and secondary storage services locations when the geo-redundancy feature is enabled.</span></span>

- <span data-ttu-id="12c97-239">*Azure Event Hubs.*</span><span class="sxs-lookup"><span data-stu-id="12c97-239">*Azure Event Hubs.*</span></span> <span data-ttu-id="12c97-240">이벤트 허브 클라이언트 라이브러리는 구성 가능한 지 수 백오프 기능을 포함 하는 RetryPolicy 속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="12c97-240">The Event Hub client library features a RetryPolicy property, which includes a configurable exponential backoff feature.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="12c97-241">[이전](application-resiliency-patterns.md)
>[다음](resilient-communications.md)</span><span class="sxs-lookup"><span data-stu-id="12c97-241">[Previous](application-resiliency-patterns.md)
[Next](resilient-communications.md)</span></span>
