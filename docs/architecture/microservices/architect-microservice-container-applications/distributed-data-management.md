---
title: 분산 데이터 관리를 위한 과제 및 해결 방법
description: 마이크로 서비스 환경에서 분산 데이터 관리를 위한 과제 및 솔루션은 무엇인지 알아봅니다.
ms.date: 09/20/2018
ms.openlocfilehash: 1439dd5a04c3991a2b3b2ef12763843f9f339a29
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91152653"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="64db5-103">분산 데이터 관리를 위한 과제 및 해결 방법</span><span class="sxs-lookup"><span data-stu-id="64db5-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="64db5-104">과제 \#1: 각 마이크로 서비스의 경계를 정의하는 방법</span><span class="sxs-lookup"><span data-stu-id="64db5-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="64db5-105">마이크로 서비스 경계를 정의하는 것은 아마도 처음 만나는 도전일 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="64db5-106">각 마이크로 서비스는 애플리케이션의 일부여야 하며, 각 마이크로 서비스에서 제공하는 모든 이점과 과제를 통해 독립적으로 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="64db5-107">하지만 이러한 경계는 어떻게 알아볼 수 있을까요?</span><span class="sxs-lookup"><span data-stu-id="64db5-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="64db5-108">먼저 애플리케이션의 논리 도메인 모델 및 관련 데이터에 집중해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="64db5-109">동일한 애플리케이션 내에서 분리된 위치의 데이터와 다양한 컨텍스트를 식별해 보세요.</span><span class="sxs-lookup"><span data-stu-id="64db5-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="64db5-110">각 컨텍스트에는 다양한 비즈니스 언어(용어)가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="64db5-111">컨텍스트는 독립적으로 정의하고 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="64db5-112">이러한 다양한 컨텍스트에서 사용되는 용어와 엔터티는 비슷하지만, 특정 컨텍스트에서 하나의 비즈니스 개념이 다른 컨텍스트에서 다른 용도로 사용되고 다른 이름을 가질 수도 있다는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="64db5-113">예를 들어 사용자는 ID 또는 멤버 자격 컨텍스트에서 사용자, CRM 컨텍스트에서 고객, 주문 컨텍스트에서 구매자 등등으로 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="64db5-114">각 컨텍스트마다 다른 도메인이 있는 여러 애플리케이션 컨텍스트 간에 경계를 식별하는 방법은 정확히 각 비즈니스 마이크로 서비스와 해당 도메인 모델 및 데이터에 대한 경계를 식별하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="64db5-115">항상 이러한 마이크로 서비스 간의 결합을 최소화하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="64db5-116">이 가이드는 나중에 [각 마이크로 서비스에 대한 도메인 모델 경계 식별](identify-microservice-domain-model-boundaries.md) 섹션에서 이러한 식별 및 도메인 모델 디자인에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="64db5-117">과제 \#2: 여러 마이크로 서비스에서 데이터를 검색하는 쿼리를 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="64db5-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="64db5-118">두 번째 과제는 원격 클라이언트 앱에서 마이크로 서비스에 대한 번거로운 통신을 피하면서 여러 마이크로 서비스에서 데이터를 검색하는 쿼리를 구현하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="64db5-119">예를 들어 장바구니, 카탈로그 및 사용자 ID 마이크로 서비스에서 소유한 사용자 정보를 표시해야 하는 모바일 앱의 단일 화면이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="64db5-120">또 다른 예로 여러 마이크로 서비스에 있는 많은 테이블이 포함된 복잡한 보고서가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="64db5-121">올바른 해결 방법은 쿼리의 복잡성에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="64db5-122">그러나 어떤 경우이든 시스템 통신의 효율성을 높이려면 정보를 집계하는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="64db5-123">가장 인기 있는 해결 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="64db5-124">**API 게이트웨이.**</span><span class="sxs-lookup"><span data-stu-id="64db5-124">**API Gateway.**</span></span> <span data-ttu-id="64db5-125">서로 다른 데이터베이스를 소유한 여러 마이크로 서비스의 간단한 데이터 집계에 권장되는 방법은 API 게이트웨이라고 하는 집계 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="64db5-126">그러나 시스템의 문제 지점(choke point)이 될 수 있고 마이크로 서비스의 자율 원칙을 위반할 수 있으므로 이 패턴을 구현하는 데 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="64db5-127">이러한 가능성을 줄이기 위해 각각 시스템의 수직적 "조각" 또는 비즈니스 영역에 집중하는 여러 개의 정교한 API 게이트웨이가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="64db5-128">API 게이트웨이 패턴은 나중에 [API 게이트웨이 섹션](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication)에서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="64db5-129">**쿼리/읽기 테이블이 포함된 CQRS.**</span><span class="sxs-lookup"><span data-stu-id="64db5-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="64db5-130">여러 마이크로 서비스에서 데이터를 집계하는 또 다른 해결 방법은 [구체화된 뷰 패턴](/azure/architecture/patterns/materialized-view)입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="64db5-131">이 방법에서는 여러 마이크로 서비스에서 소유한 데이터가 있는 읽기 전용 테이블을 미리 생성합니다(실제 쿼리가 수행되기 전에 비정규화된 데이터 준비).</span><span class="sxs-lookup"><span data-stu-id="64db5-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="64db5-132">이 테이블에는 클라이언트 앱의 요구 사항에 적합한 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="64db5-133">모바일 앱에 대한 화면과 같은 것을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="64db5-134">단일 데이터베이스가 있는 경우 여러 테이블과 관련된 복잡한 조인을 수행하는 SQL 쿼리를 사용하여 해당 화면에 대한 데이터를 함께 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="64db5-135">그러나 여러 데이터베이스가 있고 다른 마이크로 서비스에서 각 데이터베이스를 소유하는 경우 이러한 데이터베이스를 쿼리하고 SQL 조인을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="64db5-136">복잡한 쿼리가 문제가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="64db5-137">CQRS 방법을 사용하여 요구 사항을 해결할 수 있습니다. 즉 쿼리에 대해서만 사용되는 다른 데이터베이스에 비정규화된 테이블을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="64db5-138">이 테이블은 복잡한 쿼리에 필요한 데이터에 맞게 특별히 설계할 수 있으며, 애플리케이션의 화면에 필요한 필드와 쿼리 테이블의 열 사이에 일대일 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="64db5-139">또한 보고 목적으로도 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="64db5-140">이 방법은 원래의 문제(여러 마이크로 서비스 간에 쿼리하고 조인하는 방법)를 해결할 뿐만 아니라, 애플리케이션에 필요한 데이터가 이미 쿼리 테이블에 있으므로 성능도 복잡한 조인에 비해 상당히 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="64db5-141">물론 쿼리/읽기 테이블이 포함된 CQRS를 사용하는 경우, 추가 개발 작업이 필요하고 최종 일관성을 수용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="64db5-142">그럼에도 불구하고 [공동 작업 시나리오](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)(또는 관점에 따라 경쟁 시나리오)에서 성능 및 높은 확장성 요구 사항이 있는 경우, 여러 데이터베이스가 포함된 CQRS를 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="64db5-143">**중앙 데이터베이스의 "콜드 데이터"**</span><span class="sxs-lookup"><span data-stu-id="64db5-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="64db5-144">실시간 데이터가 필요하지 않을 수 있는 복잡한 보고서 및 쿼리의 경우, 일반적인 방법은 보고에만 사용되는 대형 데이터베이스에 "핫 데이터"(마이크로 서비스의 트랜잭션 데이터)를 "콜드 데이터"로 내보내는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="64db5-145">이 중앙 데이터베이스 시스템은 빅 데이터 기반 시스템(예: Hadoop), 데이터 웨어하우스(예: Azure SQL Data Warehouse 기반) 또는 보고서에만 사용되는 단일 SQL 데이터베이스(크기가 문제가 되지 않는 경우)일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="64db5-146">이 중앙 집중식 데이터베이스는 실시간 데이터가 필요 없는 쿼리 및 보고서에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="64db5-147">원래의 업데이트 및 트랜잭션은 진실의 원본으로 마이크로 서비스 데이터에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="64db5-148">데이터를 동기화하는 방법은 이벤트 기반 통신(다음 섹션에서 설명됨)을 사용하거나 다른 데이터베이스 인프라 가져오기/내보내기 도구를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="64db5-149">이벤트 기반 통신을 사용하는 경우 해당 통합 프로세스는 CQRS 쿼리 테이블에 대해 앞에서 설명한 대로 데이터를 전파하는 방식과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="64db5-150">그러나 애플리케이션 디자인에서 복잡한 쿼리에 대해 여러 마이크로 서비스의 정보를 지속적으로 집계하는 경우 잘못된 디자인의 증상일 수 있습니다. 즉, 마이크로 서비스는 가능한 한 다른 마이크로 서비스로부터 격리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="64db5-151">(콜드 데이터 중앙 데이터베이스를 항상 사용해야 하는 보고서/분석은 제외됩니다.) 이 문제가 종종 마이크로 서비스를 병합하는 이유가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="64db5-152">각 마이크로 서비스의 진화 및 배포의 자율성과 강력한 종속성, 응집력 및 데이터 집계의 균형을 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="64db5-153">과제 \#3: 여러 마이크로 서비스 간에 일관성을 유지하는 방법</span><span class="sxs-lookup"><span data-stu-id="64db5-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="64db5-154">앞에서 설명한 대로 각 마이크로 서비스에서 소유한 데이터는 해당 마이크로 서비스 전용이며, 마이크로 서비스 API를 통해서만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="64db5-155">따라서 여러 마이크로 서비스 간에 일관성을 유지하면서 엔드투엔드 비즈니스 프로세스를 구현하는 방법을 제시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="64db5-156">이 문제를 분석하기 위해 [eShopOnContainers 참조 애플리케이션](https://aka.ms/eshoponcontainers)의 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="64db5-157">카탈로그 마이크로 서비스는 제품 가격을 포함하여 모든 제품에 대한 정보를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="64db5-158">장바구니 마이크로 서비스는 장바구니에 사용자가 추가하고 있는 제품 항목에 대한 임시 데이터를 관리합니다. 여기에는 장바구니에 추가된 시점의 항목 가격이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="64db5-159">카탈로그에서 제품 가격이 업데이트되면 해당 가격은 동일한 제품을 보관하는 활성 장바구니에서도 업데이트되어야 하고, 추가로 시스템은 사용자에게 특정 항목의 가격이 장바구니에 추가한 이후 변경되었음을 경고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="64db5-160">이 애플리케이션의 가상 모놀리식 버전에서 제품 테이블의 가격이 변경되면 카탈로그 하위 시스템은 ACID 트랜잭션을 사용하여 장바구니 테이블의 현재 가격을 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="64db5-161">그러나 마이크로 서비스 기반 애플리케이션에서는 제품 및 장바구니 테이블은 각각의 마이크로 서비스가 소유합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="64db5-162">그림 4-9와 같이 마이크로 서비스에는 직접 쿼리가 아닌 다른 마이크로 서비스가 소유한 테이블/스토리지를 자체 트랜잭션에 포함해서는 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![마이크로 서비스 데이터베이스 데이터를 공유할 수 없음을 보여 주는 다이어그램입니다.](./media/distributed-data-management/indepentent-microservice-databases.png)

<span data-ttu-id="64db5-164">**그림 4-9**</span><span class="sxs-lookup"><span data-stu-id="64db5-164">**Figure 4-9**.</span></span> <span data-ttu-id="64db5-165">마이크로 서비스는 다른 마이크로 서비스의 테이블에 직접 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="64db5-166">장바구니 테이블은 장바구니 마이크로 서비스가 소유하기 때문에 카탈로그 마이크로 서비스는 장바구니 테이블을 직접 업데이트해서는 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="64db5-167">장바구니 마이크로 서비스를 업데이트하려면 카탈로그 마이크로 서비스는 통합 이벤트(메시지 및 이벤트 기반 통신)와 같은 비동기 통신을 기반으로 최종 일관성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="64db5-168">이는 [eShopOnContainers](https://aka.ms/eshoponcontainers) 참조 애플리케이션이 마이크로 서비스 전반에 걸쳐 이러한 유형의 일관성을 수행하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="64db5-169">[CAP 정리](https://en.wikipedia.org/wiki/CAP_theorem)에서 명시한 대로 가용성과 강력한 ACID 일관성 중에서 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="64db5-170">대부분의 마이크로 서비스 기반 시나리오에서는 강력한 일관성과 달리 가용성과 높은 확장성을 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="64db5-171">중요 업무용 애플리케이션은 계속 유지되고 실행되어야 하고, 개발자는 약한 일관성 또는 최종 일관성 작업을 위한 기술을 사용하여 강력한 일관성을 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="64db5-172">이는 대부분의 마이크로 서비스 기반 아키텍처에서 사용하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="64db5-173">더욱이 ACID 방식 또는 2단계 커밋 트랜잭션은 마이크로 서비스 원칙에 위반되는 것이 아닙니다. 대부분의 NoSQL 데이터베이스(예: Azure Cosmos DB, MongoDB 등)는 분산 데이터베이스 시나리오에서 일반적인 2단계 커밋 트랜잭션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="64db5-174">그러나 서비스와 데이터베이스 간의 데이터 일관성은 반드시 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="64db5-175">또한 이 과제는 특정 데이터가 중복될 필요가 있을 때(예: 카탈로그 마이크로 서비스 및 장바구니 마이크로 서비스에 제품의 이름 또는 설명이 있어야 할 때), 여러 마이크로 서비스에 변경 내용을 전파하는 방법에 대한 질문과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="64db5-176">이 문제에 적합한 해결 방법은 이벤트 기반 통신과 게시 및 구독 시스템을 통해 연결된 마이크로 서비스 간에 최종 일관성을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="64db5-177">이러한 항목은 이 가이드의 뒷부분에 나오는 [비동기 이벤트 기반 통신](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="64db5-178">과제 \#4: 마이크로 서비스 경계 간에 통신을 설계하는 방법</span><span class="sxs-lookup"><span data-stu-id="64db5-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="64db5-179">마이크로 서비스 경계 간의 통신은 실제적인 과제입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="64db5-180">이 컨텍스트에서 통신은 사용해야 하는 프로토콜(HTTP 및 REST, AMQP, 메시징 등)을 참조하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="64db5-181">대신, 사용해야 하는 통신 방식, 특히 마이크로 서비스가 결합되어야 하는 방식을 해결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="64db5-182">오류가 발생하는 경우 결합 수준에 따라 시스템에 미치는 오류의 영향은 상당히 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="64db5-183">마이크로 서비스 기반 애플리케이션과 같은 분산 시스템에서는 여러 서버 또는 호스트에서 분산 서비스를 통해 많은 아티팩트가 이동하므로 결국에는 구성 요소가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="64db5-184">부분적인 실패와 더 큰 중단이 발생할 수 있으므로 이 유형의 분산 시스템에서 일반적인 위험을 고려하여 마이크로 서비스와 이들 간의 통신을 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="64db5-185">인기 있는 방법은 단순성으로 인해 HTTP(REST) 기반 마이크로 서비스를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="64db5-186">HTTP 기반 방법은 완벽하게 허용됩니다. 여기서의 문제는 이를 사용하는 방법과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="64db5-187">HTTP 요청과 응답을 사용하여 클라이언트 애플리케이션 또는 API 게이트웨이에서 마이크로 서비스와 상호 작용하는 경우에는 문제가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="64db5-188">그러나 마이크로 서비스 전체에서 동기식 HTTP 호출의 긴 체인을 만들고 마이크로 서비스가 모놀리식 애플리케이션의 개체인 것처럼 경계 간에 통신하는 경우 결국에는 애플리케이션에 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="64db5-189">예를 들어 클라이언트 애플리케이션이 주문 마이크로 서비스와 같은 개별 마이크로 서비스에 대한 HTTP API 호출을 수행한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="64db5-190">이에 따라 주문 마이크로 서비스에서 동일한 요청/응답 주기 내에서 HTTP를 사용하여 마이크로 서비스를 추가로 호출하면 HTTP 호출 체인이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="64db5-191">처음에는 합리적일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-191">It might sound reasonable initially.</span></span> <span data-ttu-id="64db5-192">그러나 다음과 같은 상황에 있을 때 고려해야 할 중요한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="64db5-193">차단 및 성능 저하.</span><span class="sxs-lookup"><span data-stu-id="64db5-193">Blocking and low performance.</span></span> <span data-ttu-id="64db5-194">HTTP의 동기식 특성으로 인해 모든 내부 HTTP 호출이 완료될 때까지 원래 요청에서 응답을 받지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="64db5-195">이러한 호출 횟수가 크게 증가하는 동시에 마이크로 서비스에 대한 중간 HTTP 호출 중 하나가 차단되는 경우가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="64db5-196">그 결과 성능에 영향을 미치고, 추가 HTTP 요청이 증가함에 따라 전반적인 확장성이 기하급수적으로 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="64db5-197">마이크로 서비스와 HTTP의 결합.</span><span class="sxs-lookup"><span data-stu-id="64db5-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="64db5-198">비즈니스 마이크로 서비스는 다른 비즈니스 마이크로 서비스와 결합하면 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="64db5-199">이상적으로 다른 마이크로 서비스의 존재에 대해 "인식하지" 못합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="64db5-200">예를 들어 애플리케이션에서 마이크로 서비스의 결합을 사용하는 경우 마이크로 서비스별 자율성을 달성하는 것은 거의 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="64db5-201">어느 한 마이크로 서비스에서 발생한 오류.</span><span class="sxs-lookup"><span data-stu-id="64db5-201">Failure in any one microservice.</span></span> <span data-ttu-id="64db5-202">HTTP 호출로 연결되는 마이크로 서비스 체인을 구현한 경우, 마이크로 서비스 중 하나에 오류가 발생하면(결국에는 전체 마이크로 서비스가 실패함) 마이크로 서비스 체인 전체에 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="64db5-203">마이크로 서비스 기반 시스템은 부분적인 오류 발생 시에도 가능한 한 계속 작동하도록 설계되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="64db5-204">지수 백오프 또는 회로 차단기 메커니즘을 통해 다시 시도를 사용하는 클라이언트 논리를 구현하는 경우에도 HTTP 호출 체인이 복잡할수록 HTTP 기반 오류 전략을 구현하는 것이 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="64db5-205">실제로 내부 마이크로 서비스에서 설명한 대로 HTTP 요청 체인을 만들어 통신하는 경우, 모놀리식 애플리케이션이 있지만 내부 처리 통신 메커니즘이 아닌 프로세스 간 HTTP를 기반으로 한다고 주장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="64db5-206">따라서 마이크로 서비스 자율성을 적용하고 복원력을 높이려면 마이크로 서비스 간에 요청/응답 통신 체인을 최소한으로 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="64db5-207">비동기 메시지 및 이벤트 기반 통신을 사용하거나 원래의 HTTP 요청/응답 주기와 별도로(비동기) HTTP 폴링을 사용하여 마이크로 서비스 간 통신에 비동기 상호 작용만 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="64db5-208">비동기 통신 사용에 대한 자세한 내용은 이 가이드의 뒷부분에 나오는 [비동기식 마이크로 서비스 통합에서 마이크로 서비스 자율성 적용](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) 및 [비동기 메시지 기반 통신](asynchronous-message-based-communication.md) 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="64db5-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="64db5-209">추가 자료</span><span class="sxs-lookup"><span data-stu-id="64db5-209">Additional resources</span></span>

- <span data-ttu-id="64db5-210">**CAP 원리** </span><span class="sxs-lookup"><span data-stu-id="64db5-210">**CAP theorem** </span></span>\
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="64db5-211">**최종 일관성** </span><span class="sxs-lookup"><span data-stu-id="64db5-211">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="64db5-212">**데이터 일관성 입문서** </span><span class="sxs-lookup"><span data-stu-id="64db5-212">**Data Consistency Primer** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="64db5-213">**Martin Fowler. CQRS(명령과 쿼리의 역할 구분)**  </span><span class="sxs-lookup"><span data-stu-id="64db5-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** </span></span>\
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="64db5-214">**구체화된 뷰** </span><span class="sxs-lookup"><span data-stu-id="64db5-214">**Materialized View** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="64db5-215">**Charles Row 작성, ACID 및 베이스: 데이터베이스 트랜잭션 처리의 pH 이동** </span><span class="sxs-lookup"><span data-stu-id="64db5-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** </span></span>\
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="64db5-216">**보상 트랜잭션** </span><span class="sxs-lookup"><span data-stu-id="64db5-216">**Compensating Transaction** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="64db5-217">**Udi Dahan. 서비스 지향 컴퍼지션** </span><span class="sxs-lookup"><span data-stu-id="64db5-217">**Udi Dahan. Service Oriented Composition** </span></span>\
  <https://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="64db5-218">[이전](logical-versus-physical-architecture.md)
>[다음](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="64db5-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
