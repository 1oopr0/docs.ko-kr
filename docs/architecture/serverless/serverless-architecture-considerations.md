---
title: 서버리스 아키텍처 고려 사항 - 서버리스 앱
description: 상태 관리 및 영구 저장소에서 크기 조정, 로깅, 추적 및 진단까지 서버리스 애플리케이션 설계와 관련된 문제를 이해합니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 04/06/2020
ms.openlocfilehash: fbbb0c38cea58902124743fb99f9ab31b3d09be9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91171652"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="0741c-103">서버리스 아키텍처 고려 사항</span><span class="sxs-lookup"><span data-stu-id="0741c-103">Serverless architecture considerations</span></span>

<span data-ttu-id="0741c-104">서버리스 아키텍처를 채택할 때 특정 문제가 제기됩니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="0741c-105">이 섹션에서는 몇 가지 일반적인 고려 사항을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="0741c-106">이러한 모든 문제에는 해결 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-106">All of these challenges have solutions.</span></span> <span data-ttu-id="0741c-107">모든 아키텍처 선택과 마찬가지로 서버리스 채택은 장단점을 신중하게 고려한 후에 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="0741c-108">애플리케이션 요구 사항에 따라 서버리스 구현이 특정 구성 요소에 적합한 솔루션이 아니라고 판단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="0741c-109">상태 관리</span><span class="sxs-lookup"><span data-stu-id="0741c-109">Managing state</span></span>

<span data-ttu-id="0741c-110">일반적으로 마이크로 서비스에서와 마찬가지로 서버리스 함수는 기본적으로 상태 비저장입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="0741c-111">상태를 배제하면 서버리스가 사용 후 삭제 가능하고, 수직으로 확장할 수 있고, 중앙 실패 지점 없이 복원력을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="0741c-112">경우에 따라 비즈니스 프로세스에는 상태가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="0741c-113">프로세스에 상태가 필요한 경우 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="0741c-114">서버리스 이외의 모델을 채택하거나 상태를 제공하는 별도의 서비스와 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="0741c-115">상태를 추가하면 솔루션이 복잡해질 수 있으며 확장하기가 더 어렵고 잠재적으로 단일 실패 지점이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="0741c-116">함수가 반드시 상태를 요구하는지 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="0741c-117">대답이 "예"인 경우 그래도 서버리스로 구현하는 것이 적절한지 판단합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="0741c-118">서버리스의 이점을 훼손하지 않고 상태를 채택하는 솔루션이 여러 가지 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="0741c-119">가장 인기 있는 솔루션 중 일부는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="0741c-120">Redis와 같은 임시 데이터 저장소 또는 분산 캐시를 사용</span><span class="sxs-lookup"><span data-stu-id="0741c-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="0741c-121">SQL 또는 CosmosDB와 같은 데이터베이스에 상태를 저장</span><span class="sxs-lookup"><span data-stu-id="0741c-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="0741c-122">[지속성 함수](/azure/azure-functions/durable/durable-functions-overview)와 같은 워크플로 엔진을 통해 상태를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-122">Handle state through a workflow engine like [durable functions](/azure/azure-functions/durable/durable-functions-overview)</span></span>

<span data-ttu-id="0741c-123">중요한 것은 서버리스로 구현하려는 프로세스에서 상태 관리의 필요성이 있는지 알고 있어야 한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="0741c-124">장기 실행 프로세스</span><span class="sxs-lookup"><span data-stu-id="0741c-124">Long-running processes</span></span>

<span data-ttu-id="0741c-125">서버리스의 많은 이점이 사용 후 삭제 프로세스에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="0741c-126">실행 시간이 짧으면 서버리스 공급자가 함수 종료 시 리소스를 해제하고 호스트 간에 함수를 공유하기 더 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="0741c-127">대부분의 클라우드 공급자는 함수를 실행할 수 있는 총 시간을 10분 정도로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="0741c-128">프로세스가 더 오래 걸릴 수 있다면 대체 구현을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="0741c-129">몇 가지 예외와 해결 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="0741c-130">한 가지 해결 방법은 프로세스를 개별적으로 실행하는 데 걸리는 시간이 더 짧은 작은 구성 요소로 분할하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="0741c-131">종속성으로 인해 프로세스가 장시간 실행되는 경우 Durable Functions와 같은 솔루션을 사용하는 비동기 워크플로를 고려할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="0741c-132">Durable Functions는 외부 프로세스가 완료될 때까지 대기하는 동안 프로세스를 일시 중지하고 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="0741c-133">비동기 처리를 통해 실제 프로세스가 실행되는 시간이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="0741c-134">시작 시간</span><span class="sxs-lookup"><span data-stu-id="0741c-134">Startup time</span></span>

<span data-ttu-id="0741c-135">서버리스 구현의 한 가지 잠재적 문제는 시작 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="0741c-136">리소스를 절약하기 위해 대부분의 서버리스 공급자는 "주문형" 인프라를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="0741c-137">서버리스 함수가 일정 시간 후에 트리거되면 함수를 호스트하는 리소스를 만들거나 다시 시작해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="0741c-138">콜드 부팅으로 인해 몇 초 정도 지연될 수 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="0741c-139">시작 시간은 공급자와 서비스 수준에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="0741c-140">앱의 성공을 위해 시작 시간을 최소화하는 것이 중요한 경우 시작 시간을 해결하는 몇 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="0741c-141">일부 공급자는 사용자가 인프라를 "항상 사용"하도록 보장하는 서비스 수준을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="0741c-142">연결 유지 메커니즘을 구현합니다(엔드포인트를 ping하여 "활성" 상태로 유지).</span><span class="sxs-lookup"><span data-stu-id="0741c-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="0741c-143">컨테이너화된 함수 접근 방식을 통해 Kubernetes와 같은 오케스트레이션을 사용합니다(호스트가 이미 실행 중이므로 새 인스턴스는 빠르게 실행됨).</span><span class="sxs-lookup"><span data-stu-id="0741c-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="0741c-144">데이터베이스 업데이트 및 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="0741c-144">Database updates and migrations</span></span>

<span data-ttu-id="0741c-145">서버리스 코드의 이점은 전체 애플리케이션을 다시 배포하지 않고도 새 함수를 릴리스할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="0741c-146">이러한 장점이 관계형 데이터베이스가 포함된 경우에는 단점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="0741c-147">데이터베이스 스키마에 대한 변경 내용은 서버리스 업데이트와 동기화하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="0741c-148">문제가 발생하여 변경 내용을 롤백해야 하는 경우 추가적인 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="0741c-149">데이터 무결성은 자체 데이터를 소유하는 것이 마이크로 서비스 및 서버리스 함수의 한 모범 사례인 이유 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="0741c-150">변경 내용을 컴퓨팅 및 데이터의 단일 단위로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="0741c-151">실제에서는 많은 레거시 시스템이 서버리스 아키텍처와 조정해야 하는 대규모 백 엔드 데이터베이스를 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="0741c-152">스키마 버전 관리를 해결하는 일반적인 방법은 절대로 기존 속성 및 열을 수정하지 않고 새 정보를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="0741c-153">예를 들어 작업 목록에 대한 부울 "완료" 플래그에서 "완료 날짜"로 이동하는 변경하는 것을 생각해 봅시다.</span><span class="sxs-lookup"><span data-stu-id="0741c-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="0741c-154">기존 필드를 제거하는 대신 다음과 같이 데이터베이스를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="0741c-155">새 "완료 날짜" 필드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="0741c-156">"완료" 부울 필드를 완료 날짜가 현재 날짜 이후인지 평가하는 계산 함수로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="0741c-157">완료된 부울이 true로 설정된 경우 완료 날짜를 현재 날짜로 설정하는 트리거를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="0741c-158">일련의 변경 내용은 레거시 코드가 계속해서 "있는 그대로" 실행되고 서버리스 함수가 새 필드를 활용할 수 있게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="0741c-159">서버리스 아키텍처의 데이터에 대한 자세한 내용은 [분산 데이터 관리에 대한 과제 및 해결 방법](../microservices/architect-microservice-container-applications/distributed-data-management.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0741c-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="0741c-160">배율 조정</span><span class="sxs-lookup"><span data-stu-id="0741c-160">Scaling</span></span>

<span data-ttu-id="0741c-161">서버리스가 "서버 없음"을 의미한다고 오해하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="0741c-162">실제로는 "매우 작은 서버"입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-162">It's in fact "less server."</span></span> <span data-ttu-id="0741c-163">지원 인프라가 있다는 사실을 이해하는 것이 크기 조정과 관련하여 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="0741c-164">대부분의 서버리스 플랫폼에서는 이벤트 밀도가 증가할 때 인프라 크기를 조정하는 방법을 처리하는 컨트롤 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="0741c-165">다양한 옵션 중에서 선택할 수 있지만 전략은 함수에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="0741c-166">또한 함수는 일반적으로 관련 호스트에서 실행되므로 동일한 호스트에서 실행되는 함수는 동일한 크기 조정 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="0741c-167">따라서 크기 조정 요구 사항에 따라 함께 어떤 함수를 힘께 호스트할지 구성하고 전략을 수립해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="0741c-168">규칙은 다양한 매개 변수에 따라 수직 확장(호스트 리소스 증가) 및 수평 확장(호스트 인스턴스 수 증가) 방법을 지정하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="0741c-169">크기 조정 트리거에는 일정, 요청 속도, CPU 사용률 및 메모리 사용이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="0741c-170">성능이 높을수록 비용이 증가하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="0741c-171">이보다 저렴한 사용 기반 접근 방식은 요청 속도가 갑자기 증가하는 경우 신속하게 확장되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="0741c-172">미리 "보험 비용"을 지불하는 것과 엄격히 '종량제'로 지불하고 갑작스러운 수요 증가로 인한 응답 속도 저하를 감수하는 것 사이의 상반 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="0741c-173">모니터링, 추적 및 로깅</span><span class="sxs-lookup"><span data-stu-id="0741c-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="0741c-174">DevOps에서 자주 간과되는 측면 하나는 배포된 애플리케이션의 모니터링입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="0741c-175">서버리스 함수를 모니터링하기 위한 전략을 수립하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="0741c-176">가장 어려운 문제는 종종 상관 관계, 즉 사용자가 동일한 상호 작용의 일부로 여러 함수를 호출하는 경우를 인식하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="0741c-177">대부분의 서버리스 플랫폼에서는 타사 도구로 가져올 수 있는 콘솔 로깅을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="0741c-178">또한 원격 분석 컬렉션을 자동화하고, 상관 관계 ID를 생성 및 추적하고, 특정 작업을 모니터링하여 자세한 정보를 제공하는 옵션도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="0741c-179">Azure는 모니터링 및 분석을 위한 고급 [Application Insights 플랫폼](/azure/azure-functions/functions-monitoring)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-179">Azure provides the advanced [Application Insights platform](/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="0741c-180">서비스 간 종속성</span><span class="sxs-lookup"><span data-stu-id="0741c-180">Inter-service dependencies</span></span>

<span data-ttu-id="0741c-181">서버리스 아키텍처에는 다른 함수에 의존하는 함수가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="0741c-182">실제로 서버리스 아키텍처에서 여러 서비스가 상호 작용 또는 분산 트랜잭션의 일부로 서로 호출 하는 경우가 드물지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="0741c-183">강력한 결합을 방지하려면 서비스가 서로를 직접 참조하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="0741c-184">서비스 엔드포인트를 변경해야 하는 경우 직접 참조로 인해 대규모 리팩터링이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="0741c-185">권장하는 해결 방법은 요청 유형에 적합한 엔드포인트를 제공하는 서비스 검색 메커니즘(예: 레지스트리)을 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="0741c-186">또 하나의 해결 방법은 서비스 간 통신에 큐 또는 토픽과 같은 메시징 서비스를 활용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="0741c-187">실패 관리 및 복원력 제공</span><span class="sxs-lookup"><span data-stu-id="0741c-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="0741c-188">*회로 차단기 패턴*을 고려하는 것도 중요합니다. 어떤 이유로든 한 서비스가 계속 실패할 경우 해당 서비스를 반복해서 호출하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="0741c-189">대신, 대체 서비스를 호출하거나 종속 서비스의 상태가 다시 설정될 때까지 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="0741c-190">서버리스 아키텍처는 서비스 간 종속성을 확인하고 관리하기 위한 전략을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="0741c-191">회로 차단기 패턴을 계속하려면 서비스에 내결함성 및 복원력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="0741c-192">내결함성은 예기치 않은 예외 또는 잘못된 상태 발생 후에도 애플리케이션을 계속 실행하는 기능을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="0741c-193">내결함성은 일반적으로 코드 자체의 기능이며 예외를 처리하기 위해 코드가 작성되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="0741c-194">복원력은 애플리케이션에서 얼마나 실패를 복구할 수 있는지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="0741c-195">복원력은 종종 서버리스 플랫폼에 의해 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="0741c-196">플랫폼은 기존 서버리스 함수 인스턴스가 실패할 경우 새 인스턴스를 실행할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="0741c-197">또한 플랫폼은 모든 새 인스턴스가 실패할 경우 새 인스턴스 시작을 중지할 수 있을 정도로 지능적이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="0741c-198">자세한 내용은 [회로 차단기 패턴 구현](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0741c-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="0741c-199">버전 관리 및 그린/블루 배포</span><span class="sxs-lookup"><span data-stu-id="0741c-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="0741c-200">서버리스의 주요 이점 한 가지는 전체 애플리케이션을 다시 배포하지 않고 특정 함수를 업그레이드하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="0741c-201">업그레이드가 성공하려면 함수를 호출하는 서비스가 올바른 버전의 코드로 라우팅되도록 함수 버전을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="0741c-202">새 버전을 배포하는 전략도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="0741c-203">일반적인 접근 방식은 "그린/블루 배포"를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="0741c-204">그린 배포는 현재 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-204">The green deployment is the current function.</span></span> <span data-ttu-id="0741c-205">새 "블루" 버전이 프로덕션에 배포되고 테스트됩니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="0741c-206">테스트를 통과하면 그린 버전과 블루 버전이 교체되어 새 버전이 활성 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="0741c-207">문제가 발생하는 경우 다시 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="0741c-208">버전 관리 및 그린/블루 배포를 지원하려면 버전 변경을 수용하고 서버리스 플랫폼을 사용하여 배포를 처리하는 함수를 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0741c-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0741c-209">[이전](serverless-architecture.md)
>[다음](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="0741c-209">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
