---
title: 개체에서 패턴 사용 - C# 자습서
description: 이 자습서에서는 클래스 멤버에서 패턴 일치를 사용하여 개체 동작에 보다 좋은 모델을 만드는 방법을 배웁니다.
ms.date: 11/05/2020
ms.openlocfilehash: 072f6f57696504c2d691473e3a43c1cda53f227f
ms.sourcegitcommit: 6bef8abde346c59771a35f4f76bf037ff61c5ba3
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/06/2020
ms.locfileid: "94332178"
---
# <a name="use-pattern-matching-to-build-your-class-behavior-for-better-code"></a><span data-ttu-id="5a034-103">패턴 일치를 사용하여 코드를 개선하는 클래스 동작 빌드</span><span class="sxs-lookup"><span data-stu-id="5a034-103">Use pattern matching to build your class behavior for better code</span></span>

<span data-ttu-id="5a034-104">C#의 패턴 일치 기능은 알고리즘을 표현하는 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-104">The pattern matching features in C# provide syntax to express your algorithms.</span></span> <span data-ttu-id="5a034-105">이러한 방법을 사용하여 클래스에서 동작을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-105">You can use these techniques to implement the behavior in your classes.</span></span> <span data-ttu-id="5a034-106">개체 지향 클래스 디자인을 데이터 지향 구현과 결합하면 실제 개체를 모델링하면서 간결한 코드를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-106">You can combine object-oriented class design with a data-oriented implementation to provide concise code while modeling real-world objects.</span></span>

<span data-ttu-id="5a034-107">이 자습서에서 학습할 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="5a034-108">데이터 패턴을 사용하여 개체 지향 클래스를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-108">Express your object oriented classes using data patterns.</span></span>
> - <span data-ttu-id="5a034-109">C#의 패턴 일치 기능을 사용하여 이러한 패턴을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-109">Implement those patterns using C#'s pattern matching features.</span></span>
> - <span data-ttu-id="5a034-110">컴파일러 진단을 활용하여 구현의 유효성을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-110">Leverage compiler diagnostics to validate your implementation.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="5a034-111">필수 구성 요소</span><span class="sxs-lookup"><span data-stu-id="5a034-111">Prerequisites</span></span>

<span data-ttu-id="5a034-112">C# 9.0 컴파일러를 포함하여 .NET 5를 실행하도록 컴퓨터를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-112">You’ll need to set up your machine to run .NET 5, including the C# 9.0 compiler.</span></span> <span data-ttu-id="5a034-113">C# 9.0 컴파일러는 [Visual Studio 2019 버전 16.8 미리 보기](https://visualstudio.microsoft.com/vs/preview/) 또는 [.NET 5.0 SDK 미리 보기](https://dotnet.microsoft.com/download/dotnet/5.0)부터 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-113">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8 preview](https://visualstudio.microsoft.com/vs/preview/) or the [.NET 5.0 SDK preview](https://dotnet.microsoft.com/download/dotnet/5.0).</span></span>

## <a name="build-a-simulation-of-a-canal-lock"></a><span data-ttu-id="5a034-114">운하 갑문 시뮬레이션 빌드</span><span class="sxs-lookup"><span data-stu-id="5a034-114">Build a simulation of a canal lock</span></span>

<span data-ttu-id="5a034-115">이 자습서에서는 [운하 갑문](https://en.wikipedia.org/wiki/Lock_(water_navigation))을 시뮬레이트하는 C# 클래스를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-115">In this tutorial, you'll build a C# class that simulates a [canal lock](https://en.wikipedia.org/wiki/Lock_(water_navigation)).</span></span> <span data-ttu-id="5a034-116">간단히 말해 운하 갑문은 서로 수위가 다른 두 수역 간을 이동하는 배들을 올리고 내리는 장치입니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-116">Briefly, a canal lock is a device that raises and lowers boats as they travel between two stretches of water at different levels.</span></span> <span data-ttu-id="5a034-117">갑문에는 두 개의 수문과 수위를 변경하는 몇 가지 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-117">A lock has two gates and some mechanism to change the water level.</span></span>

<span data-ttu-id="5a034-118">정상 작동 시 배는 갑문 안의 수위와 배가 진입하는 쪽의 수위가 일치할 때 두 개의 수문 중 하나로 들어옵니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-118">In its normal operation, a boat enters one of the gates while the water level in the lock matches the water level on the side the boat enters.</span></span> <span data-ttu-id="5a034-119">갑문 안에 들어오면 배가 갑문에서 나가는 쪽의 수위와 일치하도록 갑문 안 수위가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-119">Once in the lock, the water level is changed to match the water level where the boat will leave the lock.</span></span> <span data-ttu-id="5a034-120">수위가 이쪽 수위와 일치하면 출구 쪽 수문이 열립니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-120">Once the water level matches that side, the gate on the exit side opens.</span></span> <span data-ttu-id="5a034-121">조작자가 운하에서 위험한 상황을 초래하지 않도록 안전 조치가 마련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-121">Safety measures make sure an operator can't create a dangerous situation in the canal.</span></span> <span data-ttu-id="5a034-122">두 수문을 모두 닫은 경우에만 수위를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-122">The water level can be changed only when both gates are closed.</span></span> <span data-ttu-id="5a034-123">하나의 수문만 열려 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-123">At most one gate can be open.</span></span> <span data-ttu-id="5a034-124">수문을 열려면 갑문 내 수위가 열려는 수문 밖의 수위와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-124">To open a gate, the water level in the lock must match the water level outside the gate being opened.</span></span>

<span data-ttu-id="5a034-125">이 동작을 C# 클래스를 빌드하여 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-125">You can build a C# class to model this behavior.</span></span> <span data-ttu-id="5a034-126">`CanalLock` 클래스는 두 수문을 열거나 닫는 명령을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-126">A `CanalLock` class would support commands to open or close either gate.</span></span> <span data-ttu-id="5a034-127">수위를 높이거나 낮추는 다른 명령도 클래스에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-127">It would have other commands to raise or lower the water.</span></span> <span data-ttu-id="5a034-128">클래스는 양쪽 수문의 현재 상태와 수위를 읽는 속성도 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-128">The class should also support properties to read the current state of both gates and the water level.</span></span> <span data-ttu-id="5a034-129">메서드는 안전 조치를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-129">Your methods implement the safety measures.</span></span>

## <a name="define-a-class"></a><span data-ttu-id="5a034-130">클래스 정의</span><span class="sxs-lookup"><span data-stu-id="5a034-130">Define a class</span></span>

<span data-ttu-id="5a034-131">`CanalLock` 클래스를 테스트하는 콘솔 애플리케이션을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-131">You'll build a console application to test your `CanalLock` class.</span></span> <span data-ttu-id="5a034-132">Visual Studio 또는 .NET CLI를 사용하여 .NET 5용 콘솔 프로젝트를 새로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-132">Create a new console project for .NET 5 using either Visual Studio or the .NET CLI.</span></span> <span data-ttu-id="5a034-133">그런 다음 새 클래스를 추가하고 이름을 `CanalLock`으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-133">Then, add a new class and name it `CanalLock`.</span></span> <span data-ttu-id="5a034-134">다음으로 공용 API를 디자인하되 메서드는 구현하지 않은 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-134">Next, design your public API, but leave the methods not implemented:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="APIDesign":::

<span data-ttu-id="5a034-135">앞의 코드는 개체를 초기화하므로 두 수문이 모두 닫혀 있고 수위는 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-135">The preceding code initializes the object so both gates are closed, and the water level is low.</span></span> <span data-ttu-id="5a034-136">그런 다음 클래스의 첫 번째 구현을 만들 때 지침이 될 다음 테스트 코드를 `Main` 메서드에 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-136">Next, write the following test code in your `Main` method to guide you as you create a first implementation of the class:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HappyTests":::

<span data-ttu-id="5a034-137">다음으로 `CanalLock` 클래스에서 각 메서드의 첫 번째 구현을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-137">Next, add a first implementation of each method in the `CanalLock` class.</span></span> <span data-ttu-id="5a034-138">다음 코드는 안전 규칙을 고려하지 않고 클래스의 메서드를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-138">The following code implements the methods of the class without concern to the safety rules.</span></span> <span data-ttu-id="5a034-139">안전 테스트는 나중에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-139">You'll add safety tests later:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="FirstImplementation":::

<span data-ttu-id="5a034-140">지금까지 작성한 테스트는 통과됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-140">The tests you've written so far pass.</span></span> <span data-ttu-id="5a034-141">기초를 구현했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-141">You've implemented the basics.</span></span> <span data-ttu-id="5a034-142">이제 첫 번째 실패 조건에 대한 테스트를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-142">Now, write a test for the first failure condition.</span></span> <span data-ttu-id="5a034-143">이전 테스트의 끝에서는 두 수문이 모두 닫혀 있고 수위가 낮음으로 설정되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-143">At the end of the previous tests, both gates are closed, and the water level is set to low.</span></span> <span data-ttu-id="5a034-144">상류 수문을 열려고 시도하는 테스트를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-144">Add a test to try opening the upper gate:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HighGateSafetyTest":::

<span data-ttu-id="5a034-145">수문이 열리기 때문에 이 테스트는 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-145">This test fails because the gate opens.</span></span> <span data-ttu-id="5a034-146">첫 번째 구현으로 다음 코드를 사용하여 이를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-146">As a first implementation, you could fix it with the following code:</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="SecondImplementation":::

<span data-ttu-id="5a034-147">테스트에 통과됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-147">Your tests pass.</span></span> <span data-ttu-id="5a034-148">하지만 더 많은 테스트를 추가함에 따라 점점 더 많은 `if` 절을 추가하고 여러 속성을 테스트하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-148">But, as you add more tests, you'll add more and more `if` clauses and test different properties.</span></span> <span data-ttu-id="5a034-149">추가하는 조건이 많아지면 이러한 메서드는 금방 너무 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-149">Soon, these methods will get too complicated as you add more conditionals.</span></span>

## <a name="implement-the-commands-with-patterns"></a><span data-ttu-id="5a034-150">패턴을 사용하여 명령 구현</span><span class="sxs-lookup"><span data-stu-id="5a034-150">Implement the commands with patterns</span></span>

<span data-ttu-id="5a034-151">더 나은 방법은 패턴을 사용하여 개체가 명령을 실행하기에 유효한 상태에 있는지 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-151">A better way is to use *patterns* to determine if the object is in a valid state to execute a command.</span></span> <span data-ttu-id="5a034-152">명령이 세 변수(수문 상태, 수위, 새 설정)의 함수로 허용되는지 여부를 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-152">You can express if a command is allowed as a function of three variables: the state of the gate, the level of the water, and the new setting:</span></span>

| <span data-ttu-id="5a034-153">새 설정</span><span class="sxs-lookup"><span data-stu-id="5a034-153">New setting</span></span> | <span data-ttu-id="5a034-154">수문 상태</span><span class="sxs-lookup"><span data-stu-id="5a034-154">Gate state</span></span> | <span data-ttu-id="5a034-155">수위</span><span class="sxs-lookup"><span data-stu-id="5a034-155">Water Level</span></span> | <span data-ttu-id="5a034-156">결과</span><span class="sxs-lookup"><span data-stu-id="5a034-156">Result</span></span>             |
| ----------- | ---------- | ----------- | ------------------ |
| <span data-ttu-id="5a034-157">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-157">Closed</span></span>      | <span data-ttu-id="5a034-158">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-158">Closed</span></span>     | <span data-ttu-id="5a034-159">높은</span><span class="sxs-lookup"><span data-stu-id="5a034-159">High</span></span>        | <span data-ttu-id="5a034-160">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-160">Closed</span></span>             |
| <span data-ttu-id="5a034-161">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-161">Closed</span></span>      | <span data-ttu-id="5a034-162">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-162">Closed</span></span>     | <span data-ttu-id="5a034-163">낮음</span><span class="sxs-lookup"><span data-stu-id="5a034-163">Low</span></span>         | <span data-ttu-id="5a034-164">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-164">Closed</span></span>             |
| <span data-ttu-id="5a034-165">종결</span><span class="sxs-lookup"><span data-stu-id="5a034-165">Closed</span></span>      | <span data-ttu-id="5a034-166">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-166">Open</span></span>       | <span data-ttu-id="5a034-167">높은</span><span class="sxs-lookup"><span data-stu-id="5a034-167">High</span></span>        | <span data-ttu-id="5a034-168">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-168">Open</span></span>               |
| <span data-ttu-id="5a034-169">~~해결됨~~</span><span class="sxs-lookup"><span data-stu-id="5a034-169">~~Closed~~</span></span>  | <span data-ttu-id="5a034-170">~~열기~~</span><span class="sxs-lookup"><span data-stu-id="5a034-170">~~Open~~</span></span>   | <span data-ttu-id="5a034-171">~~낮음~~</span><span class="sxs-lookup"><span data-stu-id="5a034-171">~~Low~~</span></span>     | <span data-ttu-id="5a034-172">~~해결됨~~</span><span class="sxs-lookup"><span data-stu-id="5a034-172">~~Closed~~</span></span>         |
| <span data-ttu-id="5a034-173">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-173">Open</span></span>        | <span data-ttu-id="5a034-174">해결됨</span><span class="sxs-lookup"><span data-stu-id="5a034-174">Closed</span></span>     | <span data-ttu-id="5a034-175">높은</span><span class="sxs-lookup"><span data-stu-id="5a034-175">High</span></span>        | <span data-ttu-id="5a034-176">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-176">Open</span></span>               |
| <span data-ttu-id="5a034-177">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-177">Open</span></span>        | <span data-ttu-id="5a034-178">해결됨</span><span class="sxs-lookup"><span data-stu-id="5a034-178">Closed</span></span>     | <span data-ttu-id="5a034-179">낮음</span><span class="sxs-lookup"><span data-stu-id="5a034-179">Low</span></span>         | <span data-ttu-id="5a034-180">닫힘(오류)</span><span class="sxs-lookup"><span data-stu-id="5a034-180">Closed (Error)</span></span>     |
| <span data-ttu-id="5a034-181">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-181">Open</span></span>        | <span data-ttu-id="5a034-182">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-182">Open</span></span>       | <span data-ttu-id="5a034-183">높은</span><span class="sxs-lookup"><span data-stu-id="5a034-183">High</span></span>        | <span data-ttu-id="5a034-184">열기</span><span class="sxs-lookup"><span data-stu-id="5a034-184">Open</span></span>               |
| <span data-ttu-id="5a034-185">~~열기~~</span><span class="sxs-lookup"><span data-stu-id="5a034-185">~~Open~~</span></span>    | <span data-ttu-id="5a034-186">~~열기~~</span><span class="sxs-lookup"><span data-stu-id="5a034-186">~~Open~~</span></span>   | <span data-ttu-id="5a034-187">~~낮음~~</span><span class="sxs-lookup"><span data-stu-id="5a034-187">~~Low~~</span></span>     | <span data-ttu-id="5a034-188">~~닫힘(오류)~~</span><span class="sxs-lookup"><span data-stu-id="5a034-188">~~Closed (Error)~~</span></span> |

<span data-ttu-id="5a034-189">테이블의 네 번째 및 마지막 행은 잘못되었기 때문에 텍스트에 취소선이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-189">The fourth and last rows in the table have strike through text because they're invalid.</span></span> <span data-ttu-id="5a034-190">이제 추가할 코드는 수위가 낮을 때 상류 수문이 절대 열리지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-190">The code you're adding now should make sure the high water gate is never opened when the water is low.</span></span>  <span data-ttu-id="5a034-191">이러한 상태는 단일 switch 식으로 코딩할 수 있습니다(`false`가 "닫힘"을 나타냄을 명심하세요).</span><span class="sxs-lookup"><span data-stu-id="5a034-191">Those states can be coded as a single switch expression (remember that `false` indicates "Closed"):</span></span>

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="ThirdImplementation":::

<span data-ttu-id="5a034-192">이 버전을 시험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="5a034-192">Try this version.</span></span> <span data-ttu-id="5a034-193">테스트가 통과되며 코드의 유효성이 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-193">Your tests pass, validating the code.</span></span> <span data-ttu-id="5a034-194">전체 테이블은 입력과 결과의 가능한 조합을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-194">The full table shows the possible combinations of inputs and results.</span></span> <span data-ttu-id="5a034-195">즉, 개발자는 테이블을 빠르게 살펴보고 가능한 모든 입력이 포함된 것을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-195">That means you and other developers can quickly look at the table and see that you've covered all the possible inputs.</span></span> <span data-ttu-id="5a034-196">컴파일러를 사용하면 훨씬 더 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-196">Even easier, the compiler can help as well.</span></span> <span data-ttu-id="5a034-197">이전 코드를 추가한 후 컴파일러가 다음과 같은 경고를 생성하는 것을 볼 수 있습니다. *CS8524* 는 switch 식에 가능한 모든 입력이 포함되지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-197">After you add the previous code, you can see that the compiler generates a warning: *CS8524* indicates the switch expression doesn't cover all possible inputs.</span></span> <span data-ttu-id="5a034-198">이 경고가 발생하는 이유는 입력 중 하나가 `enum` 형식이기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-198">The reason for that warning is that one of the inputs is an `enum` type.</span></span> <span data-ttu-id="5a034-199">컴파일러는 "가능한 모든 입력"을 기본 형식(일반적으로 `int`)의 모든 입력으로 해석합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-199">The compiler interprets "all possible inputs" as all inputs from the underlying type, typically an `int`.</span></span> <span data-ttu-id="5a034-200">이 `switch` 식은 `enum`에서 선언된 값만 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-200">This `switch` expression only checks the values declared in the `enum`.</span></span> <span data-ttu-id="5a034-201">경고를 제거하려면 식의 마지막 암(arm)에 대해 catch-all 무시 패턴을 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-201">To remove the warning, you can add a catch-all discard pattern for the last arm of the expression.</span></span> <span data-ttu-id="5a034-202">이 조건은 잘못된 입력을 나타내므로 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-202">This condition throws an exception, because it indicates invalid input:</span></span>

```csharp
_  => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="5a034-203">위의 switch arm은 모든 입력과 일치하므로 `switch` 식에서 마지막에 와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-203">The preceding switch arm must be last in your `switch` expression because it matches all inputs.</span></span> <span data-ttu-id="5a034-204">앞 순서로 옮겨 실험해 보세요.</span><span class="sxs-lookup"><span data-stu-id="5a034-204">Experiment by moving it earlier in the order.</span></span> <span data-ttu-id="5a034-205">그러면 패턴의 연결할 수 없는 코드를 나타내는 컴파일러 오류 *CS8510* 이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-205">That causes a compiler error *CS8510* for unreachable code in a pattern.</span></span>  <span data-ttu-id="5a034-206">switch 식의 자연적 구조를 사용하면 컴파일러가 가능한 실수에 대한 오류 및 경고를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-206">The natural structure of switch expressions enables the compiler to generate errors and warnings for possible mistakes.</span></span> <span data-ttu-id="5a034-207">"safety net" 컴파일러를 사용하면 더 적은 반복으로 올바른 코드를 보다 쉽게 만들 수 있으며, switch arm을 와일드카드와 조합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-207">The compiler "safety net" makes it easier for you to create correct code in fewer iterations, and the freedom to combine switch arms with wildcards.</span></span> <span data-ttu-id="5a034-208">컴파일러는 조합으로 인해 예상하지 못한 연결 불가능한 arm이 발생하는 경우 오류를 생성하고, 필요하지 않은 arm을 제거하는 경우 경고를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-208">The compiler will issue errors if your combination results in unreachable arms you didn't expect, and warnings if you remove an arm that's needed.</span></span>

<span data-ttu-id="5a034-209">첫 번째 변경은 명령이 수문 닫기인 모든 arm을 결합하는 것입니다. 이는 항상 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-209">The first change is to combine all the arms where the command is to close the gate; that's always allowed.</span></span> <span data-ttu-id="5a034-210">switch 식의 첫 번째 arm으로 다음 코드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-210">Add the following code as the first arm in your switch expression:</span></span>

```csharp
(false, _, _) => false,
```

<span data-ttu-id="5a034-211">이전 switch arm을 추가한 후 명령이 `false`인 각 arm에 하나씩 4개의 컴파일러 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-211">After you add the previous switch arm, you'll get four compiler errors, one on each of the arms where the command is `false`.</span></span> <span data-ttu-id="5a034-212">이러한 arm은 새로 추가된 arm에 이미 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-212">Those arms are already covered by the newly added arm.</span></span> <span data-ttu-id="5a034-213">이 네 줄은 안전하게 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-213">You can safely remove those four lines.</span></span> <span data-ttu-id="5a034-214">이 새로운 switch arm은 이 조건을 대체하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-214">You intended this new switch arm to replace those conditions.</span></span>

<span data-ttu-id="5a034-215">다음으로 명령이 수문 열기인 네 개의 arm을 단순화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-215">Next, you can simplify the four arms where the command is to open the gate.</span></span> <span data-ttu-id="5a034-216">수위가 높은 두 경우 모두 수문을 열 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-216">In both cases where the water level is high, the gate can be opened.</span></span> <span data-ttu-id="5a034-217">(한 경우에는 수문이 이미 열려 있습니다.) 수위가 낮은 한 경우는 예외를 throw하고 다른 경우는 발생하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-217">(In one, it's already open.) One case where the water level is low throws an exception, and the other shouldn't happen.</span></span> <span data-ttu-id="5a034-218">갑문이 이미 잘못된 상태인 경우 동일한 예외를 안전하게 throw해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-218">It should be safe to throw the same exception if the water lock is already in an invalid state.</span></span> <span data-ttu-id="5a034-219">이러한 arm에 대해 다음과 같은 단순화를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-219">You can make the following simplifications for those arms:</span></span>

```csharp
(true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
```

<span data-ttu-id="5a034-220">테스트를 다시 실행하면 통과됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-220">Run your tests again, and they pass.</span></span> <span data-ttu-id="5a034-221">`SetHighGate` 메서드의 최종 버전은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-221">Here's the final version of the `SetHighGate` method:</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalImplementaton":::

## <a name="implement-patterns-yourself"></a><span data-ttu-id="5a034-222">직접 패턴 구현</span><span class="sxs-lookup"><span data-stu-id="5a034-222">Implement patterns yourself</span></span>

<span data-ttu-id="5a034-223">방법을 살펴보았으므로 이제 `SetLowGate` 및 `SetWaterLevel` 메서드를 직접 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-223">Now that you've seen the technique, fill in the `SetLowGate` and `SetWaterLevel` methods yourself.</span></span>  <span data-ttu-id="5a034-224">먼저 다음 코드를 추가하여 이러한 메서드에 대한 잘못된 작업을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-224">Start by adding the following code to test invalid operations on those methods:</span></span>

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="FinalTestCode":::

<span data-ttu-id="5a034-225">애플리케이션을 다시 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-225">Run your application again.</span></span> <span data-ttu-id="5a034-226">새 테스트가 실패하는 것을 볼 수 있고, 운하 갑문이 잘못된 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-226">You can see the new tests fail, and the canal lock gets into an invalid state.</span></span> <span data-ttu-id="5a034-227">나머지 메서드를 직접 구현해 보세요.</span><span class="sxs-lookup"><span data-stu-id="5a034-227">Try to implement the remaining methods yourself.</span></span> <span data-ttu-id="5a034-228">하류 수문을 설정하는 메서드는 상류 수문을 설정하는 메서드와 비슷해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-228">The method to set the lower gate should be similar to the method to set the upper gate.</span></span> <span data-ttu-id="5a034-229">수위를 변경하는 메서드에 포함된 검사는 서로 다르지만 비슷한 구조를 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-229">The method that changes the water level has different checks, but should follow a similar structure.</span></span> <span data-ttu-id="5a034-230">수위를 설정하는 메서드에 동일한 프로세스를 사용하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-230">You may find it helpful to use the same process for the method that sets the water level.</span></span> <span data-ttu-id="5a034-231">다음 네 개의 입력 모두로 시작합니다. 양쪽 수문의 상태, 수위의 현재 상태, 요청된 새 수위.</span><span class="sxs-lookup"><span data-stu-id="5a034-231">Start with all four inputs: The state of both gates, the current state of the water level, and the requested new water level.</span></span> <span data-ttu-id="5a034-232">switch 식은 다음으로 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-232">The switch expression should start with:</span></span>

```csharp
CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
    // elided
};
```

<span data-ttu-id="5a034-233">입력할 switch arm은 총 16개입니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-233">You'll have 16 total switch arms to fill in.</span></span> <span data-ttu-id="5a034-234">그런 다음 테스트하고 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-234">Then, test and simplify.</span></span>

<span data-ttu-id="5a034-235">만든 메서드가 다음과 비슷합니까?</span><span class="sxs-lookup"><span data-stu-id="5a034-235">Did you make methods something like this?</span></span>

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalExercise":::

<span data-ttu-id="5a034-236">테스트에 통과되어야 하며, 운하 갑문이 안전하게 작동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-236">Your tests should pass, and the canal lock should operate safely.</span></span>

## <a name="summary"></a><span data-ttu-id="5a034-237">요약</span><span class="sxs-lookup"><span data-stu-id="5a034-237">Summary</span></span>

<span data-ttu-id="5a034-238">이 자습서에서는 개체의 내부 상태에 변경 내용을 적용하기 전에 패턴 일치를 사용하여 해당 상태를 확인하는 방법을 배웠습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-238">In this tutorial, you learned to use pattern matching to check the internal state of an object before applying any changes to that state.</span></span> <span data-ttu-id="5a034-239">속성의 조합을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-239">You can check combinations of properties.</span></span> <span data-ttu-id="5a034-240">이러한 전환을 위한 테이블을 빌드한 후 코드를 테스트한 다음 가독성 및 유지 관리를 위해 단순화하세요.</span><span class="sxs-lookup"><span data-stu-id="5a034-240">Once you've built tables for any of those transitions, you test your code, then simplify for readability and maintainability.</span></span> <span data-ttu-id="5a034-241">이러한 초기 리팩터링은 내부 상태의 유효성을 검사하거나 다른 API 변경을 관리하는 추가 리팩터링을 시사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-241">These initial refactorings may suggest further refactorings that validate internal state or manage other API changes.</span></span> <span data-ttu-id="5a034-242">이 자습서에서는 클래스와 개체를 더 많은 데이터 지향 및 패턴 기반 접근 방식과 결합하여 이러한 클래스를 구현했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a034-242">This tutorial combined classes and objects with a more data-oriented, pattern-based approach to implement those classes.</span></span>
