---
title: C#의 상속
description: C# 라이브러리 및 애플리케이션에서 상속 사용 방법 알아보기
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 70db8716bea84984ad56d79fa9e26aab3a8182fa
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063512"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="57fc9-103">C# 및 .NET의 상속</span><span class="sxs-lookup"><span data-stu-id="57fc9-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="57fc9-104">이 자습서에서는 C#의 상속에 대해 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="57fc9-105">상속은 특정 기능(데이터 및 동작)을 제공하는 기본 클래스를 정의하고 해당 기능을 상속하거나 재정의하는 파생 클래스를 정의할 수 있는 개체 지향 프로그래밍 언어의 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="57fc9-106">사전 요구 사항</span><span class="sxs-lookup"><span data-stu-id="57fc9-106">Prerequisites</span></span>

<span data-ttu-id="57fc9-107">이 자습서에서는 .NET Core SDK를 설치했다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="57fc9-108">다운로드하려면 [.NET Core 다운로드](https://dotnet.microsoft.com/download) 페이지를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="57fc9-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="57fc9-109">코드 편집기도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-109">You also need a code editor.</span></span> <span data-ttu-id="57fc9-110">원하는 어떤 코드 편집기도 사용 가능하지만 이 자습서에서는 [Visual Studio Code](https://code.visualstudio.com)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="57fc9-111">예제 실행</span><span class="sxs-lookup"><span data-stu-id="57fc9-111">Running the examples</span></span>

<span data-ttu-id="57fc9-112">이 자습서의 예제를 만들고 실행하기 위해 명령줄에서 [dotnet](../../core/tools/dotnet.md) 유틸리티를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="57fc9-113">각 예제에 대해 다음 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="57fc9-114">이 예제를 저장할 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="57fc9-115">명령 프롬프트에 [dotnet new console](../../core/tools/dotnet-new.md)을 입력하여 새로운 .NET Core 프로젝트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="57fc9-116">예제의 코드를 복사한 후 코드 편집기에 붙여 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="57fc9-117">명령줄에서 [dotnet restore](../../core/tools/dotnet-restore.md) 명령을 입력하여 프로젝트의 종속성을 로드하거나 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="57fc9-118">[dotnet run](../../core/tools/dotnet-run.md) 명령을 입력하여 예제를 컴파일하고 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="57fc9-119">배경: 상속이란?</span><span class="sxs-lookup"><span data-stu-id="57fc9-119">Background: What is inheritance?</span></span>

<span data-ttu-id="57fc9-120">*상속*은 개체 지향 프로그래밍의 기본적인 특성 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="57fc9-121">부모 클래스의 동작을 다시 사용(상속), 확장 또는 수정하는 자식 클래스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="57fc9-122">멤버가 상속되는 클래스를 *기본 클래스*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="57fc9-123">기본 클래스의 멤버를 상속하는 클래스를 *파생 클래스*라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="57fc9-124">C# 및 .NET은 *단일 상속*만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="57fc9-125">즉, 하나의 클래스가 단일 클래스에서만 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="57fc9-126">그러나 상속은 전이적이므로 형식 집합에 대해 상속 계층을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="57fc9-127">즉, 형식 `D`는 형식 `C`에서 상속할 수 있으며, 이 형식은 `B` 형식에서 상속하고, 이 형식은 기본 클래스 형식 `A`에서 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="57fc9-128">상속은 전이적이므로 형식 `A`의 멤버를 형식 `D`에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="57fc9-129">기본 클래스의 모든 멤버가 파생 클래스에서 상속되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="57fc9-130">다음 멤버는 상속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-130">The following members are not inherited:</span></span>

- <span data-ttu-id="57fc9-131">[정적 생성자](../programming-guide/classes-and-structs/static-constructors.md): 클래스의 정적 데이터를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="57fc9-132">[인스턴스 생성자](../programming-guide/classes-and-structs/constructors.md): 클래스의 새 인스턴스를 만들기 위해 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="57fc9-133">각 클래스는 자체 생성자를 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="57fc9-134">[종료자](../programming-guide/classes-and-structs/destructors.md): 클래스의 인스턴스를 삭제하기 위해 런타임의 가비지 수집기에 의해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="57fc9-135">기본 클래스의 다른 모든 멤버는 파생 클래스에서 상속되지만 표시 가능 여부는 해당 액세스 가능성에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="57fc9-136">멤버의 액세스 가능성은 다음과 같이 파생 클래스의 표시 여부에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="57fc9-137">[개인](../language-reference/keywords/private.md) 멤버는 기본 클래스에 중첩된 파생 클래스에서만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="57fc9-138">그렇지 않으면 파생 클래스에서 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="57fc9-139">다음 예제에서 `A.B`는 `A`에서 파생되는 중첩 클래스이고 `C`는 `A`에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="57fc9-140">개인 `A.value` 필드는 A.B에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="57fc9-141">그러나 `C.GetValue` 메서드에서 주석을 제거하고 예제를 컴파일하려고 하면 컴파일러 오류 CS0122: "보호 수준 때문에 'A.value'에 액세스할 수 없습니다."가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="57fc9-142">[Protected](../language-reference/keywords/protected.md) 멤버는 파생 클래스에서만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="57fc9-143">[Internal](../language-reference/keywords/internal.md) 멤버는 기본 클래스와 동일한 어셈블리에 있는 파생 클래스에서만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="57fc9-144">기본 클래스와는 다른 어셈블리에 있는 파생 클래스에서는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="57fc9-145">[Public](../language-reference/keywords/public.md) 멤버는 파생 클래스에서 표시되고 파생 클래스의 공용 인터페이스에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="57fc9-146">상속된 public 멤버는 파생 클래스에서 정의된 것처럼 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="57fc9-147">다음 예제에서 클래스 `A`는 `Method1`이라는 메서드를 정의하고 클래스 `B`는 클래스 `A`에서 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="57fc9-148">그런 다음 이 예제에서는 마치 `B`에 대한 인스턴스 메서드인 것처럼 `Method1`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="57fc9-149">파생 클래스는 대체 구현을 제공하여 상속된 멤버를 *재정의*할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="57fc9-150">멤버를 재정의하기 위해서는 기본 클래스의 멤버가 [virtual](../language-reference/keywords/virtual.md) 키워드로 표시되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="57fc9-151">기본적으로 기본 클래스 멤버는 `virtual`로 표시되지 않으며 재정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="57fc9-152">다음 예제와 같이 비가상 멤버를 재정의하려고 하면 컴파일러 오류 CS0506: "\<member>: 상속된 ‘\<member>’ 멤버는 virtual, abstract 또는 override로 표시되지 않았으므로 재정의할 수 없습니다.”가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="57fc9-153">일부 경우에 파생 클래스는 기본 클래스 구현을 *반드시* 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="57fc9-154">[abstract](../language-reference/keywords/abstract.md) 키워드로 표시된 기본 클래스 멤버의 경우 파생 클래스에서 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="57fc9-155">다음 예제를 컴파일하려고 하면 클래스 `B`가 `A.Method1`에 대한 구현을 제공하지 않으므로 컴파일러 오류 CS0534, “&lt;class&gt;는 상속된 추상 멤버 &lt;member&gt;를 구현하지 않습니다.”가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="57fc9-156">상속은 클래스 및 인터페이스에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="57fc9-157">다른 형식 범주(구조체, 대리자 및 열거형)은 상속을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="57fc9-158">이러한 규칙 때문에 다음 예제와 같은 코드를 컴파일하려고 하면 컴파일러 오류 CS0527이 발생합니다. "인터페이스 목록에 있는 'ValueType' 형식이 인터페이스가 아닙니다."</span><span class="sxs-lookup"><span data-stu-id="57fc9-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="57fc9-159">이 오류 메시지는 구조체가 구현하는 인터페이스를 정의할 수 있지만 상속은 지원되지 않음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="57fc9-160">암시적 상속</span><span class="sxs-lookup"><span data-stu-id="57fc9-160">Implicit inheritance</span></span>

<span data-ttu-id="57fc9-161">단일 상속을 통해 상속할 수 있는 형식을 제외하고, .NET 형식 시스템의 모든 형식은 <xref:System.Object> 또는 여기에서 파생된 형식에서 암시적으로 상속합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="57fc9-162"><xref:System.Object>의 공통 기능은 모든 형식에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="57fc9-163">암시적 상속의 의미를 살펴보기 위해 빈 클래스 정의에 해당하는 새 클래스 `SimpleClass`를 정의해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="57fc9-164">그런 다음, 리플렉션(형식의 메타데이터를 검사하여 해당 형식에 대한 정보를 가져올 수 있음)을 사용하여 `SimpleClass` 형식에 속한 멤버의 목록을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="57fc9-165">`SimpleClass` 클래스에 어떤 멤버도 정의되지 않은 경우에도 예제의 출력에는 실제로 9개의 멤버가 있는 것으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="57fc9-166">이러한 멤버 중 하나는 C# 컴파일러에서 `SimpleClass` 형식에 대해 자동으로 제공하는 매개 변수가 없는(또는 기본) 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="57fc9-167">나머지 8개 멤버는 .NET 형식 시스템의 모든 클래스 및 인터페이스가 마지막에 암시적으로 상속하는 형식인 <xref:System.Object>의 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="57fc9-168"><xref:System.Object> 클래스에서 암시적으로 상속되므로 다음 메서드를 `SimpleClass` 클래스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="57fc9-169">공용 `ToString` 메서드: `SimpleClass` 개체를 해당 문자열 표현으로 변환하고 정규화된 형식 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="57fc9-170">이 경우 `ToString` 메서드는 문자열 "SimpleClass"를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="57fc9-171">두 개체가 같은지를 테스트하는 세 가지 메서드: 공용 인스턴스 `Equals(Object)` 메서드, 공용 정적 `Equals(Object, Object)` 메서드, 공용 정적 `ReferenceEquals(Object, Object)` 메서드.</span><span class="sxs-lookup"><span data-stu-id="57fc9-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="57fc9-172">기본적으로 이러한 메서드는 참조 같음을 테스트합니다. 즉, 두 개체 변수가 같으려면 같은 개체를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="57fc9-173">공용 `GetHashCode` 메서드: 형식의 인스턴스가 해시된 컬렉션에 사용될 수 있도록 하는 값을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="57fc9-174">공용 `GetType` 메서드: `SimpleClass` 형식을 나타내는 <xref:System.Type> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="57fc9-175">보호된 <xref:System.Object.Finalize%2A> 메서드: 개체의 메모리를 가비지 수집기에 의해 회수되기 전에 관리되지 않는 리소스를 해제하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="57fc9-176">보호된 <xref:System.Object.MemberwiseClone%2A> 메서드: 현재 개체의 단순 복제를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="57fc9-177">암시적 상속으로 인해 `SimpleClass` 개체에서 상속된 모든 멤버를 실제로 `SimpleClass` 클래스에 정의된 멤버인 것처럼 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="57fc9-178">예를 들어 다음 예제에서는 `SimpleClass` 가 <xref:System.Object> 에서 상속하는 `SimpleClass.ToString` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="57fc9-179">다음 표에는 C#으로 만들 수 있는 형식 및 이러한 형식이 암시적으로 상속하는 형식 범주가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="57fc9-180">각 기본 형식은 암시적으로 파생된 형식에 대한 상속을 통해 다른 멤버 집합을 사용할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="57fc9-181">형식 범주</span><span class="sxs-lookup"><span data-stu-id="57fc9-181">Type category</span></span> | <span data-ttu-id="57fc9-182">다음에서 암시적으로 상속</span><span class="sxs-lookup"><span data-stu-id="57fc9-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="57fc9-183">class</span><span class="sxs-lookup"><span data-stu-id="57fc9-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="57fc9-184">struct</span><span class="sxs-lookup"><span data-stu-id="57fc9-184">struct</span></span>        | <span data-ttu-id="57fc9-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="57fc9-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="57fc9-186">enum</span><span class="sxs-lookup"><span data-stu-id="57fc9-186">enum</span></span>          | <span data-ttu-id="57fc9-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="57fc9-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="57fc9-188">대리자(delegate)</span><span class="sxs-lookup"><span data-stu-id="57fc9-188">delegate</span></span>      | <span data-ttu-id="57fc9-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="57fc9-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="57fc9-190">상속 및 "~이다(is a)" 관계</span><span class="sxs-lookup"><span data-stu-id="57fc9-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="57fc9-191">일반적으로 상속은 기본 클래스와 하나 이상의 파생 클래스 간 "~이다(is a)" 관계를 나타내는 데 사용됩니다. 여기서 파생 클래스는 기본 클래스의 특수화된 버전입니다. 즉, 파생 클래스는 기본 클래스의 한 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="57fc9-192">예를 들어 `Publication` 클래스는 임의 종류의 출판물을 나타내고 `Book` 및 `Magazine` 클래스는 특정 유형의 출판물을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="57fc9-193">클래스 또는 구조체는 하나 이상의 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="57fc9-194">인터페이스 구현은 종종 단일 상속을 위한 해결 방법 또는 구조체에 상속을 사용하는 방법으로 제공되지만, 인터페이스 및 해당 구현 형식 사이에서 상속과는 다른 관계(“~할 수 있다(can do)” 관계)를 나타내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="57fc9-195">인터페이스는 해당 인터페이스를 구현 형식에서 사용 가능하게 만드는 기능 일부(예: 같은지 테스트하는 기능, 개체를 비교하거나 정렬하는 기능 또는 문화권별 구문 분석 및 서식 지정을 지원하는 기능)를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="57fc9-196">"~이다(is a)"는 형식과 해당 형식의 특정 인스턴스화 사이의 관계를 나타내기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="57fc9-197">다음 예제에서 `Automobile`은 세 가지 고유한 읽기 전용 속성, 즉 자동차의 제조업체인 `Make`, 자동차의 종류인 `Model`, 제조 연도인 `Year`를 갖는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="57fc9-198">또한 `Automobile` 클래스에는 해당 인수가 속성 값에 할당된 생성자가 있으며, <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 재정의하여 `Automobile` 클래스가 아닌 `Automobile` 인스턴스를 고유하게 식별하는 문자열을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="57fc9-199">이 경우 특정 자동차 제조업체 및 모델을 나타내기 위해 상속을 사용하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="57fc9-200">예를 들어 Packard Motor Car Company에서 제조한 자동차임을 나타내기 위해 `Packard` 형식을 정의할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="57fc9-201">대신, 다음 예제와 같이 해당 클래스 생성자에 적절한 값을 사용하여 `Automobile` 개체를 만들어 이러한 속성을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="57fc9-202">상속을 기준으로 하는 ~이다(is a) 관계는 기본 클래스와 기본 클래스에 추가 멤버를 더하거나 기본 클래스에 없는 추가 기능을 필요로 하는 파생 클래스에 가장 잘 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="57fc9-203">기본 클래스 및 파생 클래스 디자인</span><span class="sxs-lookup"><span data-stu-id="57fc9-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="57fc9-204">기본 클래스와 해당 파생 클래스를 디자인하는 프로세스를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="57fc9-205">이 섹션에서는 책, 잡지, 신문, 저널, 기사 등과 같은 모든 종류의 출판물을 나타내는 `Publication` 기본 클래스를 정의합니다. 또한 `Publication` 클래스에서 파생되는 `Book` 클래스도 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="57fc9-206">`Magazine`, `Journal`, `Newspaper` 및 `Article`과 같은 다른 파생 클래스를 정의하도록 예제를 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="57fc9-207">기본 게시 클래스</span><span class="sxs-lookup"><span data-stu-id="57fc9-207">The base Publication class</span></span>

<span data-ttu-id="57fc9-208">`Publication` 클래스를 디자인할 때 결정해야 하는 몇 가지 디자인은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="57fc9-209">기본 `Publication` 클래스에 포함할 멤버, `Publication` 멤버에서 메서드 구현을 제공하는지 여부 또는 `Publication`이 해당 파생 클래스에 대한 템플릿으로 사용되는 추상 기본 클래스인지 여부</span><span class="sxs-lookup"><span data-stu-id="57fc9-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="57fc9-210">이 경우 `Publication` 클래스는 메서드 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="57fc9-211">[추상 기본 클래스 및 파생 클래스 디자인](#abstract) 섹션에는 추상 기본 클래스를 사용하여 파생 클래스가 재정의해야 하는 메서드를 정의하는 예제가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="57fc9-212">파생 클래스는 파생 형식에 적합한 모든 구현을 자유롭게 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="57fc9-213">코드를 다시 사용하는 기능(즉, 여러 파생 클래스가 기본 클래스 메서드의 선언 및 구현을 공유하며 재정의할 필요가 없음)은 비추상 기본 클래스의 장점입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="57fc9-214">따라서 일부 또는 대부분의 특수화된 `Publication` 형식에서 해당 코드를 공유할 가능성이 높은 경우 `Publication`에 멤버를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="57fc9-215">기본 클래스 구현을 효율적으로 제공하지 못하면 기본 클래스에서 단일 구현이 아니라 파생 클래스에서 거의 동일한 멤버 구현을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="57fc9-216">여러 위치에서 중복된 코드를 유지해야 하면 버그가 발생하기 쉬워집니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="57fc9-217">코드 재사용을 최대화하고 논리적이고 직관적인 상속 계층 구조를 만들려면 모두 또는 대부분의 출판물에 공통되는 데이터 및 기능만 `Publication` 클래스에 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="57fc9-218">그러면 파생 클래스는 나타내는 특정 종류를 출판물에 고유한 멤버를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="57fc9-219">클래스 계층 구조 확장 범위.</span><span class="sxs-lookup"><span data-stu-id="57fc9-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="57fc9-220">단순히 하나의 기본 클래스와 하나 이상의 파생 클래스가 아닌 세 개 이상의 클래스로 구성된 계층 구조를 개발하려고 하나요?</span><span class="sxs-lookup"><span data-stu-id="57fc9-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="57fc9-221">예를 들어 `Publication`은 `Magazine`, `Journal` 및 `Newspaper`의 기본 클래스인 `Periodical`의 기본 클래스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="57fc9-222">예제에서는 `Publication` 클래스와 `Book` 파생 클래스가 각각 하나씩 구성된 작은 계층 구조를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="57fc9-223">이 예제는 쉽게 확장하여 `Publication`에서 파생되는 많은 수의 추가 클래스(예: `Magazine` 및 `Article`)를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-223">You could easily extend the example to create a number of additional classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="57fc9-224">기본 클래스의 인스턴스화가 타당한지 여부.</span><span class="sxs-lookup"><span data-stu-id="57fc9-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="57fc9-225">타당하지 않은 경우 [abstract](../language-reference/keywords/abstract.md) 키워드를 클래스에 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="57fc9-226">그렇지 않으면 해당 클래스 생성자를 호출하여 `Publication` 클래스를 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="57fc9-227">클래스 생성자에 대한 직접 호출에 의해 `abstract` 키워드로 표시된 클래스를 인스턴스화하려고 하면 C# 컴파일러는 오류 CS0144, "추상 클래스 또는 인터페이스의 인스턴스를 만들 수 없습니다."를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="57fc9-228">리플렉션을 사용하여 클래스를 인스턴스화하려고 하면 리플렉션 메서드가 <xref:System.MemberAccessException> 을 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="57fc9-229">기본적으로 기본 클래스는 해당 클래스 생성자를 호출하여 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="57fc9-230">클래스 생성자를 명시적으로 정의할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="57fc9-231">생성자가 기본 클래스의 소스 코드에 없는 경우 C# 컴파일러는 기본(매개 변수 없는) 생성자를 자동으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="57fc9-232">예를 들어 `Publication` 클래스를 인스턴스화할 수 없도록 [abstract](../language-reference/keywords/abstract.md)로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="57fc9-233">`abstract` 메서드가 없는 `abstract` 클래스는 이 클래스가 몇 가지 구체적인 클래스(예: `Book`, `Journal`) 간에 공유되는 추상 개념을 나타낸다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="57fc9-234">파생 클래스에서 특정 멤버의 기본 클래스 구현을 상속해야 하는지 여부, 파생 클래스에 기본 클래스 구현을 재정의할 수 있는 옵션이 있는지 여부 또는 파생 클래스에서 구현을 제공해야 하는지 여부.</span><span class="sxs-lookup"><span data-stu-id="57fc9-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="57fc9-235">[abstract](../language-reference/keywords/abstract.md) 키워드를 사용하여 파생 클래스에서 구현을 제공하도록 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="57fc9-236">[virtual](../language-reference/keywords/virtual.md) 키워드를 사용하여 파생 클래스에서 기본 클래스 메서드를 재정의할 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="57fc9-237">기본적으로 기본 클래스에 정의된 메서드는 재정의 가능하지 *않습니다*.</span><span class="sxs-lookup"><span data-stu-id="57fc9-237">By default, methods defined in the base class are *not* overridable.</span></span>

  <span data-ttu-id="57fc9-238">`Publication` 클래스에는 `abstract` 메서드가 없지만 클래스 자체는 `abstract`입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="57fc9-239">파생 클래스가 상속 계층 구조의 최종 클래스를 나타내고 자체적으로 추가 파생 클래스에 대한 기본 클래스로 사용될 수 없는지 여부.</span><span class="sxs-lookup"><span data-stu-id="57fc9-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="57fc9-240">기본적으로 모든 클래스는 기본 클래스로 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="57fc9-241">[sealed](../language-reference/keywords/sealed.md) 키워드를 적용하여 클래스가 추가 클래스에 대한 기본 클래스로 사용될 수 없음을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="57fc9-242">sealed 클래스에서 파생하려고 하면 컴파일러 오류 CS0509 "sealed 형식 '\<typeName>'에서 파생될 수 없습니다."를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="57fc9-243">예를 들어 파생 클래스를 `sealed`로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="57fc9-244">다음 예제에서는 `Publication` 클래스에 대한 소스 코드와 `Publication.PublicationType` 속성이 반환하는 `PublicationType` 열거형을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="57fc9-245"><xref:System.Object>에서 상속하는 멤버 외에 `Publication` 클래스는 다음과 같은 고유한 멤버 및 멤버 재정의를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="57fc9-246">생성자</span><span class="sxs-lookup"><span data-stu-id="57fc9-246">A constructor</span></span>

  <span data-ttu-id="57fc9-247">`Publication` 클래스는 `abstract`이므로 다음 예제와 같은 코드에서 직접 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="57fc9-248">그러나 `Book` 클래스에 대한 소스 코드가 나타내는 것처럼 해당 인스턴스 생성자를 파생 클래스 생성자에서 직접 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="57fc9-249">출판물과 관련된 두 가지 속성</span><span class="sxs-lookup"><span data-stu-id="57fc9-249">Two publication-related properties</span></span>

  <span data-ttu-id="57fc9-250">`Title`은 `Publication` 생성자를 호출하여 해당 값이 제공되는 읽기 전용 <xref:System.String> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="57fc9-251">`Pages`는 출판물에 포함된 총 페이지 수를 나타내는 읽기/쓰기 <xref:System.Int32> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="57fc9-252">값은 `totalPages`라는 private 필드에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="57fc9-253">값은 양수여야 하며 양수가 아니면 <xref:System.ArgumentOutOfRangeException> 이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="57fc9-254">출판사 관련 멤버</span><span class="sxs-lookup"><span data-stu-id="57fc9-254">Publisher-related members</span></span>

  <span data-ttu-id="57fc9-255">두 개의 읽기 전용 속성 `Publisher` 및 `Type`입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="57fc9-256">해당 값은 원래 `Publication` 클래스 생성자를 호출하여 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="57fc9-257">출판 관련 멤버</span><span class="sxs-lookup"><span data-stu-id="57fc9-257">Publishing-related members</span></span>

  <span data-ttu-id="57fc9-258">두 가지 메서드 `Publish` 및 `GetPublicationDate`가 출판일을 설정하고 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="57fc9-259">`Publish` 메서드는 호출될 때 private `published` 플래그를 `true`로 설정하고 전달된 날짜를 private `datePublished` 필드에 대한 인수로 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="57fc9-260">`GetPublicationDate` 메서드는 `published` 플래그가 `false`이면 문자열 "NYP"를 반환하고, `true`이면 `datePublished` 필드 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="57fc9-261">저작권 관련 멤버</span><span class="sxs-lookup"><span data-stu-id="57fc9-261">Copyright-related members</span></span>

  <span data-ttu-id="57fc9-262">`Copyright` 메서드는 저작권 소유자의 이름과 저작권 연도를 인수로 사용한 후 `CopyrightName` 및 `CopyrightDate` 속성에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="57fc9-263">`ToString` 메서드 재정의</span><span class="sxs-lookup"><span data-stu-id="57fc9-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="57fc9-264">형식이 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 재정의하지 않으면 한 인스턴스를 다른 인스턴스와 구분하는 데 별로 도움이 되지 않는 형식의 정규화된 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="57fc9-265">`Publication` 클래스는 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 을 재정의하여 `Title` 속성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="57fc9-266">다음 그림에서는 기본 `Publication` 클래스와 암시적으로 상속된 해당 <xref:System.Object> 클래스 간의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Object 및 Publication 클래스](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="57fc9-268">`Book` 클래스</span><span class="sxs-lookup"><span data-stu-id="57fc9-268">The `Book` class</span></span>

<span data-ttu-id="57fc9-269">`Book` 클래스는 책을 특수한 출판문 형식으로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="57fc9-270">다음 예제에서는 `Book` 클래스에 대한 소스 코드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="57fc9-271">`Publication`에서 상속하는 멤버 외에 `Book` 클래스는 다음과 같은 고유한 멤버 및 멤버 재정의를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="57fc9-272">2개의 생성자</span><span class="sxs-lookup"><span data-stu-id="57fc9-272">Two constructors</span></span>

  <span data-ttu-id="57fc9-273">두 `Book` 생성자는 3가지 공용 매개 변수를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="57fc9-274">두 *title* 및 *publisher*는 `Publication` 생성자의 매개 변수에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="57fc9-275">세 번째는 변경할 수 없는 공용 `Author` 속성에 저장되는 *author*입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="57fc9-276">한 생성자에는 `ISBN` auto 속성에 저장되는 *isbn* 매개 변수가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="57fc9-277">첫 번째 생성자는 [this](../language-reference/keywords/this.md) 키워드를 사용하여 다른 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="57fc9-278">생성자 연결(chaining)은 생성자를 정의하는 일반적인 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="57fc9-279">가장 많은 수의 매개 변수를 사용하여 생성자를 호출하면 더 적은 수의 매개 변수를 사용하는 생성자가 기본값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="57fc9-280">두 번째 생성자는 [base](../language-reference/keywords/base.md) 키워드를 사용하여 기본 클래스 생성자에 제목 및 출판사 이름을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="57fc9-281">소스 코드에서 기본 클래스 생성자를 명시적으로 호출하지 않으면 C# 컴파일러는 기본 클래스의 기본 생성자 또는 매개 변수 없는 생성자에 대한 호출을 자동으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="57fc9-282">읽기 전용 `ISBN` 속성: 고유한 10 또는 13자리 숫자인 `Book` 개체의 국제 표준 도서 번호를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="57fc9-283">ISBN은 `Book` 생성자 중 하나에 인수로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="57fc9-284">ISBN은 컴파일러에서 자동 생성되는 private 지원 필드에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="57fc9-285">읽기 전용 `Author` 속성.</span><span class="sxs-lookup"><span data-stu-id="57fc9-285">A read-only `Author` property.</span></span> <span data-ttu-id="57fc9-286">저자 이름은 두 `Book` 생성자의 인수로 제공되고 속성에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="57fc9-287">두 개의 읽기 전용 가격 관련 속성 `Price` 및 `Currency`.</span><span class="sxs-lookup"><span data-stu-id="57fc9-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="57fc9-288">해당 값은 `SetPrice` 메서드 호출에 인수로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="57fc9-289">`Currency` 속성은 세 자리 ISO 통화 기호입니다(예: 미국 달러의 경우 USD).</span><span class="sxs-lookup"><span data-stu-id="57fc9-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="57fc9-290">ISO 통화 기호는 <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> 속성에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="57fc9-291">이러한 두 속성은 모두 외부적으로 읽기 전용이지만 둘 다 `Book` 클래스의 코드로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="57fc9-292">`SetPrice` 메서드는 `Price` 및 `Currency` 속성의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="57fc9-293">이러한 값은 동일한 해당 속성으로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="57fc9-294">`ToString` 메서드(`Publication`에서 상속), <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 및 <xref:System.Object.GetHashCode%2A> 메서드(<xref:System.Object>에서 상속)에 대해 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="57fc9-295">재정의되지 않으면 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드는 참조 같음 여부를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="57fc9-296">즉, 두 개체 변수는 같은 개체를 참조하는 경우 동일한 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="57fc9-297">반면에 `Book` 클래스에서 두 개의 `Book` 개체에 동일한 ISBN이 있는 경우 이 두 개체는 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="57fc9-298"><xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드를 재정의할 경우 런타임이 효율적인 검색을 위해 해시된 컬렉션에 항목을 저장하는 데 사용하는 값을 반환하는 <xref:System.Object.GetHashCode%2A> 메서드도 재정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="57fc9-299">해시 코드는 같음 테스트와 일치하는 값을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="57fc9-300">두 `Book` 개체의 ISBN 속성이 같으면 `true`를 반환하도록 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>를 재정의했으므로 `ISBN` 속성에서 반환된 문자열의 <xref:System.String.GetHashCode%2A> 메서드를 호출하여 계산된 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="57fc9-301">다음 그림에서는 `Book` 클래스와 해당 기본 클래스인 `Publication` 클래스 간 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Publication 및 Book 클래스](media/book-class.jpg)

<span data-ttu-id="57fc9-303">이제 다음 예제와 같이 `Book` 개체를 인스턴스화하고, 고유 멤버 및 상속된 멤버를 모두 호출하고, `Publication` 형식 또는 `Book` 형식의 매개 변수가 필요한 메서드에 인수로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="57fc9-304">추상 기본 클래스 및 파생 클래스 디자인</span><span class="sxs-lookup"><span data-stu-id="57fc9-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="57fc9-305">앞의 예제에서는 파생 클래스에서 코드를 공유할 수 있도록 여러 메서드 구현을 제공하는 기본 클래스를 정의했습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="57fc9-306">그러나 대부분의 경우 기본 클래스는 구현을 제공할 것으로 예상되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="57fc9-307">대신, 기본 클래스는 *추상 메서드*를 선언하는 *추상 클래스*이며, 각 파생 클래스에서 구현해야 하는 멤버를 정의하는 템플릿으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="57fc9-308">일반적으로 추상 기본 클래스에서 각 파생 형식의 구현은 해당 형식에 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="57fc9-309">클래스에서 출판물에 공통된 기능의 구현을 제공했지만, `Publication` 개체를 인스턴스화하는 것은 의미가 없으므로 클래스를 abstract 키워드로 표시했습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="57fc9-310">예를 들어 닫힌 2차원 기하 도형 각각에 2개의 속성, 즉 도형의 내부 크기를 나타내는 area 속성과 도형 가장자리의 거리를 나타내는 perimeter 속성이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="57fc9-311">그러나 이러한 속성이 계산되는 방식은 전적으로 도형에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="57fc9-312">예를 들어 원의 둘레(또는 원주)를 계산하는 공식은 삼각형의 둘레를 계산하는 공식과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="57fc9-313">`Shape` 클래스는 `abstract` 메서드가 있는 `abstract` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="57fc9-314">이는 파생 클래스에서 동일한 기능을 공유한다고 나타내지만, 이러한 파생 클래스는 해당 기능을 다르게 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="57fc9-315">다음 예제에서는 두 속성 `Area` 및 `Perimeter`를 정의하는 `Shape`라는 추상 기본 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="57fc9-316">클래스를 [abstract](../language-reference/keywords/abstract.md) 키워드로 표시하는 것 외에도, 각 인스턴스 멤버도 [abstract](../language-reference/keywords/abstract.md) 키워드로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="57fc9-317">이 경우 `Shape` 도 정규화된 이름은 아닌 형식의 이름을 반환하도록 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 메서드를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="57fc9-318">아울러 두 정적 멤버 `GetArea` 및 `GetPerimeter`를 정의합니다. 이러한 정적 멤버는 호출자가 파생 클래스 인스턴스의 면적 및 둘레를 쉽게 검색할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="57fc9-319">파생 클래스의 인스턴스를 이러한 메서드 중 하나에 전달하면 런타임에서 파생 클래스의 메서드 재정의를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="57fc9-320">그러면 `Shape`에서 특정 도형을 나타내는 일부 클래스를 파생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="57fc9-321">다음 예제에서는 3개의 클래스인 `Triangle`, `Rectangle` 및 `Circle`을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="57fc9-322">각각은 해당 특정 도형에 고유한 수식을 사용하여 면적 및 둘레를 컴퓨팅합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="57fc9-323">일부 파생 클래스는 나타내는 도형마다 고유한 `Rectangle.Diagonal` 및 `Circle.Diameter`와 같은 속성도 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="57fc9-324">다음 예제에서는 `Shape`에서 파생된 개체를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="57fc9-325">또한 `Shape`에서 파생된 개체의 배열을 인스턴스화하고 반환 `Shape` 속성 값을 래핑하는 `Shape` 클래스의 정적 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="57fc9-326">런타임에서는 파생 형식의 재정의된 속성에서 값을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="57fc9-327">또한 이 예제에서는 배열의 각 `Shape` 개체를 해상 파생 형식으로 캐스팅하고, 캐스팅이 성공하면 `Shape`의 해당 특정 하위 클래스 속성을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="57fc9-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="57fc9-328">참조</span><span class="sxs-lookup"><span data-stu-id="57fc9-328">See also</span></span>

- [<span data-ttu-id="57fc9-329">상속(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="57fc9-329">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
