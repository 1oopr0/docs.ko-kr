---
description: 컴파일러 오류 CS1540
title: 컴파일러 오류 CS1540
ms.date: 07/20/2015
f1_keywords:
- CS1540
helpviewer_keywords:
- CS1540
ms.assetid: f35bbeb9-e2b2-4644-a7e6-cc2dbce1bd44
ms.openlocfilehash: 747999b263c78725183d5027e4e308e03771c30b
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91188670"
---
# <a name="compiler-error-cs1540"></a><span data-ttu-id="7ddc1-103">컴파일러 오류 CS1540</span><span class="sxs-lookup"><span data-stu-id="7ddc1-103">Compiler Error CS1540</span></span>

<span data-ttu-id="7ddc1-104">'type1' 형식의 한정자를 통해 보호된 멤버 'member'에 액세스할 수 없습니다. 한정자는 'type2' 형식이거나 여기에서 파생된 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-104">Cannot access protected member 'member' via a qualifier of type 'type1'; the qualifier must be of type 'type2' (or derived from it)</span></span>  
  
 <span data-ttu-id="7ddc1-105">파생 [클래스](../keywords/class.md)는 기본 클래스 인스턴스를 통해 기본 클래스의 보호된 멤버에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-105">A derived [class](../keywords/class.md) cannot access protected members of its base class through an instance of the base class.</span></span> <span data-ttu-id="7ddc1-106">파생 클래스에서 선언된 기본 클래스 인스턴스는 런타임에 동일한 기본 클래스에서 파생되었지만 파생 클래스와 달리 관련이 없는 다른 형식의 인스턴스일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-106">An instance of the base class declared in the derived class might, at run time, be an instance of another type that is derived from the same base but is not otherwise related to the derived class.</span></span> <span data-ttu-id="7ddc1-107">보호된 멤버는 파생 형식을 통해서만 액세스할 수 있기 때문에 런타임에 유효하지 않을 수 있는 보호된 멤버에 액세스하려는 모든 시도는 컴파일러에서 유효하지 않은 것으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-107">Because protected members can be accessed only by derived types, any attempts to access protected members that might not be valid at run time are marked by the compiler as not valid.</span></span>  
  
 <span data-ttu-id="7ddc1-108">다음 예제의 `Employee` 클래스에서 `emp2` 및 `emp3`은 컴파일 시간에 둘 다 `Person` 형식이지만 `emp2`는 런타임에 `Manager` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-108">In the `Employee` class in the following example, `emp2` and `emp3` both have type `Person` at compile time, but `emp2` has type `Manager` at run time.</span></span> <span data-ttu-id="7ddc1-109">`Employee`는 `Manager`에서 파생되지 않았기 때문에 `Manager` 클래스 인스턴스를 통해 기본 클래스 `Person`의 보호된 멤버에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-109">Because `Employee` is not derived from `Manager`, it cannot access the protected members of the base class, `Person`, through an instance of the `Manager` class.</span></span> <span data-ttu-id="7ddc1-110">컴파일러는 두 `Person` 개체의 런타임 형식을 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-110">The compiler cannot determine what the run-time type of the two `Person` objects will be.</span></span> <span data-ttu-id="7ddc1-111">따라서 `emp2`에서 호출하는 경우와 `emp3`에서 호출하는 경우 둘 다에서 컴파일러 오류 CS1540이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="7ddc1-111">Therefore, both the call from `emp2` and the call from `emp3` cause compiler error CS1540.</span></span>  
  
```csharp  
using System;  
using System.Text;  
  
namespace CS1540  
{  
    class Program1  
    {  
        static void Main()  
        {  
            Employee.PreparePayroll();  
        }  
    }  
  
    class Person  
    {  
        protected virtual void CalculatePay()
        {  
            Console.WriteLine("CalculatePay in Person class.");  
        }  
    }  
  
    class Manager : Person  
    {  
        protected override void CalculatePay()
        {  
            Console.WriteLine("CalculatePay in Manager class.");
  
        }  
    }  
  
    class Employee : Person  
    {  
        public static void PreparePayroll()  
        {  
            Employee emp1 = new Employee();  
            Person emp2 = new Manager();  
            Person emp3 = new Employee();  
            // The following line calls the method in the Employee base class,  
            // Person.  
            emp1.CalculatePay();
  
            // The following lines cause compiler error CS1540. The compiler
            // cannot determine at compile time what the run-time types of
            // emp2 and emp3 will be.  
            //emp2.CalculatePay();
            //emp3.CalculatePay();  
  
        }  
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="7ddc1-112">참고 항목</span><span class="sxs-lookup"><span data-stu-id="7ddc1-112">See also</span></span>

- [<span data-ttu-id="7ddc1-113">상속</span><span class="sxs-lookup"><span data-stu-id="7ddc1-113">Inheritance</span></span>](../../programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="7ddc1-114">다형성</span><span class="sxs-lookup"><span data-stu-id="7ddc1-114">Polymorphism</span></span>](../../programming-guide/classes-and-structs/polymorphism.md)
- [<span data-ttu-id="7ddc1-115">액세스 한정자</span><span class="sxs-lookup"><span data-stu-id="7ddc1-115">Access Modifiers</span></span>](../../programming-guide/classes-and-structs/access-modifiers.md)
- [<span data-ttu-id="7ddc1-116">추상/봉인된 클래스 및 클래스 멤버</span><span class="sxs-lookup"><span data-stu-id="7ddc1-116">Abstract and Sealed Classes and Class Members</span></span>](../../programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
