---
description: 컴파일러 오류 CS0029
title: 컴파일러 오류 CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 4f6a1f9bfc16ebaaecf38645de377b9b29bbbf8e
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465028"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="4f8ad-103">컴파일러 오류 CS0029</span><span class="sxs-lookup"><span data-stu-id="4f8ad-103">Compiler Error CS0029</span></span>

<span data-ttu-id="4f8ad-104">암시적으로 ‘type’ 형식을 ‘type’ 형식으로 변환할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="4f8ad-105">컴파일러에 명시적 변환이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="4f8ad-106">예를 들어 r-value를 l-value와 동일한 형식으로 캐스팅해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="4f8ad-107">또는 특정 연산자 오버로드를 지원하려면 변환 루틴을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="4f8ad-108">변환은 한 형식의 변수를 다른 형식의 변수에 할당할 때 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="4f8ad-109">서로 다른 형식의 변수 간에 할당을 수행하는 경우 컴파일러에서 대입 연산자의 오른쪽 형식을 대입 연산자의 왼쪽 형식으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="4f8ad-110">다음 코드를 예로 들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="4f8ad-111">`i = lng;`는 할당을 수행하지만 대입 연산자의 왼쪽과 오른쪽에 있는 변수의 데이터 형식이 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="4f8ad-112">할당 전에 컴파일러에서 long 형식인 `lng` 변수를 int로 암시적으로 변환합니다. 명시적으로 컴파일러에 이 변환을 수행하도록 지시하는 코드가 없으므로 이 변환은 암시적입니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="4f8ad-113">이 코드의 문제는 이 변환이 축소 변환으로 간주되며, 데이터 손실 가능성이 있기 때문에 컴파일러에서 암시적 축소 변환을 허용하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="4f8ad-114">축소 변환은 변환할 데이터 형식보다 작은 메모리 스토리지 공간을 사용하는 데이터 형식으로 변환할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="4f8ad-115">예를 들어 long을 int로 변환하는 것은 축소 변환으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="4f8ad-116">long은 8바이트의 메모리를 사용하고 int는 4바이트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="4f8ad-117">데이터 손실이 어떻게 발생할 수 있는지 확인하려면 다음 샘플을 고려해보세요.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="4f8ad-118">현재 `lng` 변수에 포함된 값은 너무 커서 `i` 변수에 저장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="4f8ad-119">이 값을 int 형식으로 변환하면 데이터의 일부가 손실되고 변환된 값은 변환 전의 값과 같지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="4f8ad-120">확대 변환은 축소 변환의 반대입니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="4f8ad-121">확대 변환에서는 변환할 데이터 형식보다 많은 메모리 스토리지 공간을 사용하는 데이터 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="4f8ad-122">확대 변환의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="4f8ad-123">이 코드 샘플과 첫 번째 코드 샘플 간의 차이점을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="4f8ad-124">이번에는 `lng` 변수가 대입 연산자의 왼쪽에 있으므로 할당 대상이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="4f8ad-125">컴파일러에서 int 형식인 `i` 변수를 long 형식으로 암시적으로 변환해야 할당을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="4f8ad-126">4바이트의 메모리를 사용하는 형식(int)을 8바이트의 메모리를 사용하는 형식(long)으로 변환하기 때문에 확대 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="4f8ad-127">암시적 확대 변환은 데이터 손실 가능성이 없기 때문에 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="4f8ad-128">int에 저장될 수 있는 모든 값은 long에도 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="4f8ad-129">암시적 축소 변환이 허용되지 않는 것을 알고 있으므로 이 코드를 컴파일할 수 있으려면 데이터 형식을 명시적으로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="4f8ad-130">명시적 변환은 캐스팅을 사용하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="4f8ad-131">캐스팅은 C#에서 한 데이터 형식을 다른 데이터 형식으로 변환하는 작업을 설명하는 데 사용되는 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="4f8ad-132">코드를 컴파일하려면 다음 구문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="4f8ad-133">코드의 셋째 줄에서 할당 전에 long 형식인 `lng` 변수를 int로 명시적으로 변환하도록 컴파일러에 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="4f8ad-134">축소 변환 시에는 데이터 손실 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="4f8ad-135">축소 변환을 사용할 때는 주의해야 하며, 코드가 컴파일되더라도 런타임 시 예기치 않은 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="4f8ad-136">지금까지 값 형식에 대해서만 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-136">This discussion has only been for value types.</span></span> <span data-ttu-id="4f8ad-137">값 형식을 사용하는 경우 변수에 저장된 데이터로 직접 작업합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="4f8ad-138">그러나 .NET에는 참조 형식도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-138">However, .NET also has reference types.</span></span> <span data-ttu-id="4f8ad-139">참조 형식을 사용하는 경우 실제 데이터가 아니라 변수에 대한 참조로 작업합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="4f8ad-140">참조 형식의 예로 클래스, 인터페이스, 배열 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="4f8ad-141">컴파일러에서 특정 변환을 허용하거나 적절한 변환 연산자가 구현된 경우를 제외하고 한 참조 형식을 다른 참조 형식으로 암시적 또는 명시적으로 변환할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="4f8ad-142">다음 샘플에서는 CS0029를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="4f8ad-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="4f8ad-143">참고 항목</span><span class="sxs-lookup"><span data-stu-id="4f8ad-143">See also</span></span>

- [<span data-ttu-id="4f8ad-144">사용자 정의 전환 연산자</span><span class="sxs-lookup"><span data-stu-id="4f8ad-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
