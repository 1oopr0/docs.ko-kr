---
title: C# 형식 및 변수 - C# 언어 둘러보기
description: C#에서 형식 정의 및 변수 선언에 대한 자세한 정보
ms.date: 04/24/2020
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: a14291d1eec4d090b0275875326c5a580e5abe9d
ms.sourcegitcommit: cb27c01a8b0b4630148374638aff4e2221f90b22
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/09/2020
ms.locfileid: "86174129"
---
# <a name="types-and-variables"></a><span data-ttu-id="62e67-103">형식 및 변수</span><span class="sxs-lookup"><span data-stu-id="62e67-103">Types and variables</span></span>

<span data-ttu-id="62e67-104">C#에는 두 가지 종류의 형식, 즉 *값 형식*과 *참조 형식*이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="62e67-105">값 형식의 변수에는 해당 데이터가 직접 포함되지만 참조 형식의 변수에는 데이터(개체라고도 함)에 대한 참조가 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="62e67-106">참조 형식에서는 두 개의 변수가 같은 개체를 참조할 수 있으므로 한 변수에 대한 작업이 다른 변수에서 참조하는 개체에 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-106">With reference types, it's possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="62e67-107">값 형식에서는 변수가 자체적으로 데이터 사본을 갖고 있으며 한 변수에 대한 작업이 다른 변수에 영향을 미칠 수 없습니다(`ref` 및 `out` 매개 변수 변수 제외).</span><span class="sxs-lookup"><span data-stu-id="62e67-107">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="62e67-108">C#의 값 형식은 *단순 형식*, *열거형 형식*, *구조체 형식* 및 *null 허용 값 형식*으로 세분화됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-108">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="62e67-109">C#의 참조 형식은 *클래스 형식*, *인터페이스 형식*, *배열 형식* 및 *대리자 형식*으로 세분화됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-109">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="62e67-110">다음 개요는 C#의 형식 시스템에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-110">The following outline provides an overview of C#'s type system.</span></span>

- <span data-ttu-id="62e67-111">[값 형식][ValueTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-111">[Value types][ValueTypes]</span></span>
  - <span data-ttu-id="62e67-112">[단순 형식][SimpleTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-112">[Simple types][SimpleTypes]</span></span>
    - <span data-ttu-id="62e67-113">부호 있는 정수: `sbyte`, `short`, `int`,`long`</span><span class="sxs-lookup"><span data-stu-id="62e67-113">Signed integral: `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="62e67-114">부호 없는 정수: `byte`, `ushort`, `uint`,`ulong`</span><span class="sxs-lookup"><span data-stu-id="62e67-114">Unsigned integral: `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="62e67-115">유니코드 문자: `char`</span><span class="sxs-lookup"><span data-stu-id="62e67-115">Unicode characters: `char`</span></span>
    - <span data-ttu-id="62e67-116">IEEE 이진 부동 소수점: `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="62e67-116">IEEE binary floating-point: `float`, `double`</span></span>
    - <span data-ttu-id="62e67-117">고정밀 10진수 부동 소수점: `decimal`</span><span class="sxs-lookup"><span data-stu-id="62e67-117">High-precision decimal floating-point: `decimal`</span></span>
    - <span data-ttu-id="62e67-118">부울: `bool`</span><span class="sxs-lookup"><span data-stu-id="62e67-118">Boolean: `bool`</span></span>
  - <span data-ttu-id="62e67-119">[열거형 형식][EnumTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-119">[Enum types][EnumTypes]</span></span>
    - <span data-ttu-id="62e67-120">`enum E {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-120">User-defined types of the form `enum E {...}`</span></span>
  - <span data-ttu-id="62e67-121">[구조체 형식][StructTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-121">[Struct types][StructTypes]</span></span>
    - <span data-ttu-id="62e67-122">`struct S {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-122">User-defined types of the form `struct S {...}`</span></span>
  - <span data-ttu-id="62e67-123">[Nullable 값 형식][NullableTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-123">[Nullable value types][NullableTypes]</span></span>
    - <span data-ttu-id="62e67-124">`null` 값을 갖는 다른 모든 값 형식의 확장</span><span class="sxs-lookup"><span data-stu-id="62e67-124">Extensions of all other value types with a `null` value</span></span>
  - <span data-ttu-id="62e67-125">[튜플 값 형식][TupleTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-125">[Tuple value types][TupleTypes]</span></span>
    - <span data-ttu-id="62e67-126">`(T1, T2, ...)` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-126">User-defined types of the form `(T1, T2, ...)`</span></span>
- <span data-ttu-id="62e67-127">[참조 형식][ReferenceTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-127">[Reference types][ReferenceTypes]</span></span>
  - <span data-ttu-id="62e67-128">[클래스 형식][ClassTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-128">[Class types][ClassTypes]</span></span>
    - <span data-ttu-id="62e67-129">다른 모든 형식의 기본 클래스: `object`</span><span class="sxs-lookup"><span data-stu-id="62e67-129">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="62e67-130">유니코드 문자열: `string`</span><span class="sxs-lookup"><span data-stu-id="62e67-130">Unicode strings: `string`</span></span>
    - <span data-ttu-id="62e67-131">`class C {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-131">User-defined types of the form `class C {...}`</span></span>
  - <span data-ttu-id="62e67-132">[인터페이스 형식][InterfaceTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-132">[Interface types][InterfaceTypes]</span></span>
    - <span data-ttu-id="62e67-133">`interface I {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-133">User-defined types of the form `interface I {...}`</span></span>
  - <span data-ttu-id="62e67-134">[배열 형식][ArrayTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-134">[Array types][ArrayTypes]</span></span>
    - <span data-ttu-id="62e67-135">단일 차원 및 다차원(예: `int[]` 및`int[,]`)</span><span class="sxs-lookup"><span data-stu-id="62e67-135">Single- and multi-dimensional, for example, `int[]` and `int[,]`</span></span>
  - <span data-ttu-id="62e67-136">[대리자 형식][DelegateTypes]</span><span class="sxs-lookup"><span data-stu-id="62e67-136">[Delegate types][DelegateTypes]</span></span>
    - <span data-ttu-id="62e67-137">`delegate int D(...)` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-137">User-defined types of the form `delegate int D(...)`</span></span>

[ValueTypes]: ../language-reference/builtin-types/value-types.md
[SimpleTypes]: ../language-reference/builtin-types/value-types.md#built-in-value-types
[EnumTypes]: ../language-reference/builtin-types/enum.md
[StructTypes]: ../language-reference/builtin-types/struct.md
[NullableTypes]: ../language-reference/builtin-types/nullable-value-types.md
[TupleTypes]: ../language-reference/builtin-types/value-tuples.md
[ReferenceTypes]: ../language-reference/keywords/reference-types.md
[ClassTypes]: ../language-reference/keywords/class.md
[InterfaceTypes]: ../language-reference/keywords/interface.md
[DelegateTypes]: ../language-reference/keywords/delegate.md
[ArrayTypes]: ../programming-guide/arrays/index.md

<span data-ttu-id="62e67-138">숫자 형식에 대한 자세한 내용은 [정수 형식](../language-reference/builtin-types/integral-numeric-types.md) 및 [부동 소수점 형식 표](../language-reference/builtin-types/floating-point-numeric-types.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62e67-138">For more information about numeric types, see [Integral types](../language-reference/builtin-types/integral-numeric-types.md) and [Floating-point types table](../language-reference/builtin-types/floating-point-numeric-types.md).</span></span>

<span data-ttu-id="62e67-139">C#의 `bool` 형식은 부울 값, 즉 `true` 또는 `false`를 나타내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-139">C#'s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="62e67-140">C#의 문자 및 문자열 처리에서는 유니코드 인코딩이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="62e67-141">`char` 형식은 UTF-16 코드 단위를 나타내고, `string` 형식은 UTF-16 코드 단위 시퀀스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="62e67-142">C# 프로그램에서는 *형식 선언*을 사용하여 새 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-142">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="62e67-143">형식 선언은 새 형식의 이름과 멤버를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-143">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="62e67-144">사용자 정의가 가능한 C#의 5가지 형식 범주는 클래스 형식, 구조체 형식, 인터페이스 형식, 열거형 형식 및 대리자 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-144">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="62e67-145">`class` 형식은 데이터 멤버(필드) 및 함수 멤버(메서드, 속성 및 기타)를 포함하는 데이터 구조를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-145">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="62e67-146">클래스 형식은 단일 상속 및 다형성과 파생된 클래스가 기본 클래스를 확장하고 특수화할 수 있는 메커니즘을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-146">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="62e67-147">`struct` 형식은 데이터 멤버 및 함수 멤버로 구조체를 나타내는 클래스 형식과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-147">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="62e67-148">그러나 클래스와 달리 구조체는 값 형식이며 일반적으로 힙 할당이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-148">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="62e67-149">구조체 형식은 사용자 지정 상속을 지원하지 않으며 모든 구조체 형식은 `object` 형식으로부터 암시적으로 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-149">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="62e67-150">`interface` 형식은 계약을 공용 함수 멤버의 명명된 집합으로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-150">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="62e67-151">`interface`를 구현하는 `class` 또는 `struct`는 인터페이스의 함수 멤버 구현을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-151">A `class` or `struct` that implements an `interface` must provide implementations of the interface's function members.</span></span> <span data-ttu-id="62e67-152">`interface`는 여러 기본 인터페이스에서 상속될 수 있으며 `class` 또는 `struct`는 여러 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-152">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="62e67-153">`delegate` 형식은 특정 매개 변수 목록 및 반환 형식이 있는 메서드에 대한 참조를 나타내는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-153">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="62e67-154">대리자는 메서드를 변수에 할당되고 매개 변수로 전달될 수 있는 엔터티로 취급할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-154">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="62e67-155">대리자는 함수 언어에서 제공하는 함수 형식과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-155">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="62e67-156">대리자는 다른 언어의 함수 포인터와 개념이 비슷하지만</span><span class="sxs-lookup"><span data-stu-id="62e67-156">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="62e67-157">함수 포인터와 달리 대리자는 개체 지향적이며 형식이 안전한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="62e67-158">`class`, `struct`, `interface` 및 `delegate` 형식은 모두 제네릭을 지원하므로 다른 형식으로 매개 변수화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-158">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="62e67-159">`enum` 형식은 명명된 상수가 있는 고유한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-159">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="62e67-160">모든 `enum` 형식은 8가지 정수 형식 중 하나인 내부 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-160">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="62e67-161">`enum` 형식의 값 집합은 내부 형식의 값 집합과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-161">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="62e67-162">C#은 형식의 단일 차원 및 다차원 배열을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-162">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="62e67-163">위에 나열된 형식과 달리, 배열 형식은 사용하기 전에 먼저 선언할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-163">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="62e67-164">대신, 배열 형식은 형식 이름을 대괄호로 묶어 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-164">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="62e67-165">예를 들어 `int[]`는`int`의 1차원 배열이고, `int[,]`는 `int`의 2차원 배열이고 `int[][]`는 `int`의 1차원 배열의 1차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-165">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="62e67-166">null 허용 값 형식도 사용하기 전에 먼저 선언할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-166">Nullable value types also don't have to be declared before they can be used.</span></span> <span data-ttu-id="62e67-167">null을 허용하지 않는 값 형식 `T`의 경우, 대응되는 null 허용 값 형식 `T?`가 있으며 이는 추가 값 `null`을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-167">For each non-nullable value type `T`, there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="62e67-168">예를 들어 `int?`는 32비트 정수 또는 값 `null`을 보유할 수 있는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-168">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="62e67-169">C#의 형식 시스템은 모든 형식의 값이 `object`로 취급될 수 있도록 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-169">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="62e67-170">C#의 모든 형식은 `object` 클래스 형식에서 직접 또는 간접적으로 파생되고 `object`는 모든 형식의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-170">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="62e67-171">참조 형식의 값은 `object`로 인식함으로써 간단히 개체로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-171">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="62e67-172">값 형식의 값은 *boxing* 및 *unboxing 작업*을 수행하여 개체로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-172">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="62e67-173">다음 예제에서 `int` 값은 `object`로 변환되었다가 다시 `int`로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-173">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="62e67-174">값 형식의 값이 `object` 참조에 할당되면 값을 보유하기 위해 "box"가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-174">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="62e67-175">이 상자는 참조 형식의 인스턴스이며 해당 상자에 값이 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-175">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="62e67-176">반대로 `object` 참조가 값 형식으로 캐스트될 때 참조된 `object`가 올바른 값 형식의 상자인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-176">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="62e67-177">확인에 성공하면 상자의 값이 값 형식에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-177">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="62e67-178">C# 통합 형식 시스템은 결과적으로 값 형식이 "요청 시" `object` 참조로 처리됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-178">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="62e67-179">통합 때문에 `object` 형식을 사용하는 범용 라이브러리는 참조 형식과 값 형식을 모두 포함하여 `object`에서 파생되는 모든 유형에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-179">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="62e67-180">C#에는 필드, 배열 요소, 지역 변수 및 매개 변수를 포함하는 여러 종류의 *변수*가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-180">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="62e67-181">변수는 스토리지 위치를 나타내고, 모든 변수는 아래와 같이 변수에 저장될 수 있는 값을 결정하는 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="62e67-181">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="62e67-182">Null을 허용하지 않는 값 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-182">Non-nullable value type</span></span>
  - <span data-ttu-id="62e67-183">정확한 해당 형식의 값</span><span class="sxs-lookup"><span data-stu-id="62e67-183">A value of that exact type</span></span>
- <span data-ttu-id="62e67-184">Null 허용 값 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-184">Nullable value type</span></span>
  - <span data-ttu-id="62e67-185">`null` 값 또는 정확한 해당 형식의 값</span><span class="sxs-lookup"><span data-stu-id="62e67-185">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="62e67-186">object</span><span class="sxs-lookup"><span data-stu-id="62e67-186">object</span></span>
  - <span data-ttu-id="62e67-187">`null` 참조, 참조 형식의 개체에 대한 참조 또는 값 형식의 boxed 값에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="62e67-187">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="62e67-188">클래스 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-188">Class type</span></span>
  - <span data-ttu-id="62e67-189">`null` 참조, 해당 클래스 형식의 인스턴스에 대한 참조 또는 해당 클래스 형식에서 파생된 클래스의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="62e67-189">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="62e67-190">인터페이스 유형</span><span class="sxs-lookup"><span data-stu-id="62e67-190">Interface type</span></span>
  - <span data-ttu-id="62e67-191">`null` 참조, 해당 인터페이스 형식을 구현하는 클래스 형식의 인스턴스에 대한 참조 또는 해당 인터페이스 형식을 구현하는 값 형식의 boxed 값에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="62e67-191">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="62e67-192">배열 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-192">Array type</span></span>
  - <span data-ttu-id="62e67-193">`null` 참조, 해당 배열 형식의 인스턴스에 대한 참조 또는 호환되는 배열 형식의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="62e67-193">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="62e67-194">대리자 형식</span><span class="sxs-lookup"><span data-stu-id="62e67-194">Delegate type</span></span>
  - <span data-ttu-id="62e67-195">`null` 참조 또는 호환되는 대리자 형식의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="62e67-195">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="62e67-196">[이전](program-structure.md)
> [다음](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="62e67-196">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
