---
title: C# 둘러보기 - C# 가이드
description: C#을 처음 사용하시나요? 언어의 기본 사항에 대해 알아봅니다.
ms.date: 08/06/2020
ms.openlocfilehash: 42c4ff59a520a1b99bbb2fb01d79d8902e16bdd5
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063551"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="9507f-104">C# 언어 둘러보기</span><span class="sxs-lookup"><span data-stu-id="9507f-104">A tour of the C# language</span></span>

<span data-ttu-id="9507f-105">C#(“씨샵”이라고 발음합니다.)은 형식이 안전한 최신 개체 지향 프로그래밍 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="9507f-106">C#은 C 언어 제품군에서 시작되었으며 C, C++, Java 및 JavaScript 프로그래머에게 친숙할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="9507f-107">이 둘러보기에서는 C# 8 이상 언어의 주요 구성 요소를 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="9507f-108">대화형 예제를 통해 언어를 살펴보려면 [C# 소개](../tutorials/intro-to-csharp/index.md) 자습서를 사용해 보세요.</span><span class="sxs-lookup"><span data-stu-id="9507f-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="9507f-109">C#은 개체 지향, \*\*\*\*\*\* 구성 요소 지향 프로그래밍 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="9507f-110">C#은 이러한 개념을 직접적으로 지원하는 언어 구문을 제공함으로써 소프트웨어 구성 요소를 만들고 사용할 수 있는 자연 언어로 자리매김하게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="9507f-111">원본 이후로 C#은 새로운 워크로드를 지원하기 위한 기능 및 새로운 소프트웨어 디자인 사례를 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="9507f-112">몇 가지 C# 기능은 강력하고 안정적인 애플리케이션을 구축하는 데 도움을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="9507f-113">[\*\*\*\*\*\* 가비지 수집](../../standard/garbage-collection/index.md)은 연결할 수 없는 사용되지 않는 개체가 있는 메모리를 자동으로 회수합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="9507f-114">[\*\*\*\*\*\* 예외 처리](../programming-guide/exceptions/index.md)는 오류 검색 및 복구에 대한 구조적이고 확장 가능한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="9507f-115">[\*\*\*\*\*\* 람다 식](../programming-guide/statements-expressions-operators/lambda-expressions.md)은 함수형 프로그래밍 기술을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-115">[***Lambda expressions***](../programming-guide/statements-expressions-operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="9507f-116">[\*\*\*\*\*\* 쿼리 구문](../linq/index.md)은 모든 원본의 데이터로 작업하기 위한 일반적인 패턴을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="9507f-117">[\*\*\*\*\*\* 비동기 작업](../programming-guide/concepts/async/index.md)에 대한 언어 지원은 분산 시스템을 빌드하기 위한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="9507f-118">[\*\*\*\*\*\* 패턴 일치](..//pattern-matching.md)는 최신 분산 시스템의 알고리즘과 데이터를 쉽게 구분하는 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="9507f-119">C#에는 [\*\*\*\*\*\* 통합 형식 시스템](../programming-guide/types/index.md)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="9507f-120">`int` 및 `double`과 같은 기본 형식을 포함하는 모든 C# 형식은 단일 루트 `object`에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="9507f-121">모든 형식은 일반 작업 집합을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-121">All types share a set of common operations.</span></span> <span data-ttu-id="9507f-122">모든 형식의 값을 일관된 방식으로 저장 및 전송하고 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="9507f-123">또한 C#은 사용자 정의 참조 형식 및 값 형식을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="9507f-124">C#은 개체의 동적 할당 및 경량 구조체의 인라인 스토리지를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="9507f-125">C#은 시간 경과에 따라 프로그램 및 라이브러리가 호환 가능한 방식으로 개선될 수 있도록 \*\*\*\*\*\* 버전 관리를 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="9507f-126">버전 관리 고려 사항의 직접적인 영향을 받은 C# 설계의 측면에는 별도의 `virtual` 및 `override` 한정자, 메서드 오버로드 확인 규칙 및 명시적 인터페이스 멤버 선언에 대한 지원이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="9507f-127">Hello World</span><span class="sxs-lookup"><span data-stu-id="9507f-127">Hello world</span></span>

<span data-ttu-id="9507f-128">“Hello, World” 프로그램은 프로그래밍 언어를 소개하는 데 일반적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="9507f-129">C#에서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="9507f-130">“Hello, World” 프로그램은 `System` 네임스페이스를 참조하는 `using` 지시문으로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="9507f-131">네임스페이스는 계층적으로 C# 프로그램 및 라이브러리를 구성하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="9507f-132">네임스페이스에는 형식 및 다른 네임스페이스가 포함됩니다. 예를 들어 `System` 네임스페이스에는 많은 형식(예: 프로그램에 참조되는 `Console` 클래스) 및 많은 다른 네임스페이스(예: `IO` 및 `Collections`)가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="9507f-133">지정된 네임스페이스를 참조하는 `using` 지시문을 사용하여 해당 네임스페이스의 멤버인 형식을 정규화되지 않은 방식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="9507f-134">`using` 지시문 때문에, 프로그램은 `Console.WriteLine`을 `System.Console.WriteLine`의 약식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="9507f-135">“Hello, World” 프로그램에서 선언된 `Hello` 클래스에는 단일 멤버인 `Main` 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="9507f-136">`Main` 메서드는 `static` 한정자로 선언됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="9507f-137">인스턴스 메서드는 키워드 `this`를 사용하여 특정 바깥쪽 개체 인스턴스를 참조할 수 있지만 정적 메서드는 특정 개체에 대한 참조 없이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="9507f-138">관례상 `Main`이라는 정적 메서드가 C# 프로그램의 진입점으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="9507f-139">프로그램의 출력은 `System` 네임스페이스에 있는 `Console` 클래스의 `WriteLine` 메서드에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="9507f-140">이 클래스는 기본적으로는 컴파일러에서 자동으로 참조되는 표준 클래스 라이브러리를 통해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="9507f-141">형식 및 변수</span><span class="sxs-lookup"><span data-stu-id="9507f-141">Types and variables</span></span>

<span data-ttu-id="9507f-142">C#에는 두 가지 종류의 형식, 즉 *값 형식*과 *참조 형식*이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="9507f-143">값 형식의 변수에는 해당 데이터가 직접 포함되지만 참조 형식의 변수에는 데이터(개체라고도 함)에 대한 참조가 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="9507f-144">참조 형식에서는 두 개의 변수가 같은 개체를 참조할 수 있고 한 변수에 대한 작업이 다른 변수에서 참조하는 개체에 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="9507f-145">값 형식에서는 변수가 자체적으로 데이터 사본을 갖고 있으며 한 변수에 대한 작업이 다른 변수에 영향을 미칠 수 없습니다(`ref` 및 `out` 매개 변수 변수 제외).</span><span class="sxs-lookup"><span data-stu-id="9507f-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="9507f-146">\*\*\*\*\*\* 식별자는 변수 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="9507f-147">식별자는 공백이 없는 유니코드 문자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="9507f-148">식별자에 `@` 접두사가 있으면 C# 예약어일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="9507f-149">이는 다른 언어와 상호 작용할 때 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="9507f-150">C#의 값 형식은 *단순 형식*, *열거형 형식*, *구조체 형식* 및 *null 허용 값 형식*으로 세분화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="9507f-151">C#의 참조 형식은 *클래스 형식*, *인터페이스 형식*, *배열 형식* 및 *대리자 형식*으로 세분화됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="9507f-152">다음 개요는 C#의 형식 시스템에 대한 개요를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="9507f-153">값 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="9507f-154">단순 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="9507f-155">[부호 있는 정수](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span><span class="sxs-lookup"><span data-stu-id="9507f-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="9507f-156">[부호 없는 정수](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span><span class="sxs-lookup"><span data-stu-id="9507f-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="9507f-157">[유니코드 문자](/dotnet/standard/base-types/character-encoding-introduction): `char`(UTF-16 코드 단위)</span><span class="sxs-lookup"><span data-stu-id="9507f-157">[Unicode characters](/dotnet/standard/base-types/character-encoding-introduction): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="9507f-158">[IEEE 이진 부동 소수점](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span><span class="sxs-lookup"><span data-stu-id="9507f-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="9507f-159">[고정밀 10진수 부동 소수점](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="9507f-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="9507f-160">부울: `bool`은 부울 값, 즉 `true` 또는 `false`를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="9507f-161">열거형 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="9507f-162">`enum E {...}`의 사용자 정의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="9507f-163">`enum` 형식은 명명된 상수가 있는 고유한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="9507f-164">모든 `enum` 형식은 8가지 정수 형식 중 하나인 내부 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="9507f-165">`enum` 형식의 값 집합은 내부 형식의 값 집합과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="9507f-166">구조체 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="9507f-167">`struct S {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="9507f-168">Nullable 값 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="9507f-169">`null` 값을 갖는 다른 모든 값 형식의 확장</span><span class="sxs-lookup"><span data-stu-id="9507f-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="9507f-170">튜플 값 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-170">Tuple value types</span></span>](../tuples.md)
    - <span data-ttu-id="9507f-171">`(T1, T2, ...)` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="9507f-172">참조 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="9507f-173">클래스 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="9507f-174">다른 모든 형식의 기본 클래스: `object`</span><span class="sxs-lookup"><span data-stu-id="9507f-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="9507f-175">[유니코드 문자열](/dotnet/standard/base-types/character-encoding-introduction): `string`(UTF-16 코드 유닛 시퀀스)</span><span class="sxs-lookup"><span data-stu-id="9507f-175">[Unicode strings](/dotnet/standard/base-types/character-encoding-introduction): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="9507f-176">`class C {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="9507f-177">인터페이스 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="9507f-178">`interface I {...}` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="9507f-179">배열 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="9507f-180">단일 차원 및 다차원, 가변 배열(예: `int[]`, `int[,]` 및 `int[][]`)</span><span class="sxs-lookup"><span data-stu-id="9507f-180">Single- and multi-dimensional and jagged, for example, `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="9507f-181">대리자 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-181">Delegate types</span></span>](../language-reference/keywords/delegate.md)
    - <span data-ttu-id="9507f-182">`delegate int D(...)` 양식의 사용자 정의 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-182">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="9507f-183">C# 프로그램에서는 *형식 선언*을 사용하여 새 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-183">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="9507f-184">형식 선언은 새 형식의 이름과 멤버를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-184">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="9507f-185">사용자 정의가 가능한 C#의 5가지 형식 범주는 클래스 형식, 구조체 형식, 인터페이스 형식, 열거형 형식 및 대리자 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-185">Five of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

- <span data-ttu-id="9507f-186">`class` 형식은 데이터 멤버(필드) 및 함수 멤버(메서드, 속성 및 기타)를 포함하는 데이터 구조를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-186">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="9507f-187">클래스 형식은 단일 상속 및 다형성과 파생된 클래스가 기본 클래스를 확장하고 특수화할 수 있는 메커니즘을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-187">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="9507f-188">`struct` 형식은 데이터 멤버 및 함수 멤버로 구조체를 나타내는 클래스 형식과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-188">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="9507f-189">그러나 클래스와 달리 구조체는 값 형식이며 일반적으로 힙 할당이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-189">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="9507f-190">구조체 형식은 사용자 지정 상속을 지원하지 않으며 모든 구조체 형식은 `object` 형식으로부터 암시적으로 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-190">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="9507f-191">`interface` 형식은 계약을 공용 멤버의 명명된 집합으로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-191">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="9507f-192">`interface`를 구현하는 `class` 또는 `struct`는 인터페이스의 멤버 구현을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-192">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="9507f-193">`interface`는 여러 기본 인터페이스에서 상속될 수 있으며 `class` 또는 `struct`는 여러 인터페이스를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-193">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="9507f-194">`delegate` 형식은 특정 매개 변수 목록 및 반환 형식이 있는 메서드에 대한 참조를 나타내는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-194">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="9507f-195">대리자는 메서드를 변수에 할당되고 매개 변수로 전달될 수 있는 엔터티로 취급할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-195">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="9507f-196">대리자는 함수 언어에서 제공하는 함수 형식과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-196">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="9507f-197">대리자는 다른 언어의 함수 포인터와 개념이 비슷하지만</span><span class="sxs-lookup"><span data-stu-id="9507f-197">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="9507f-198">함수 포인터와 달리 대리자는 개체 지향적이며 형식이 안전한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-198">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="9507f-199">`class`, `struct`, `interface` 및 `delegate` 형식은 모두 제네릭을 지원하므로 다른 형식으로 매개 변수화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-199">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="9507f-200">C#은 형식의 단일 차원 및 다차원 배열을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-200">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="9507f-201">위에 나열된 형식과 달리, 배열 형식은 사용하기 전에 먼저 선언할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-201">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="9507f-202">대신, 배열 형식은 형식 이름을 대괄호로 묶어 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-202">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="9507f-203">예를 들어 `int[]`는`int`의 1차원 배열이고, `int[,]`는 `int`의 2차원 배열, `int[][]`는 `int`의 1차원 배열의 1차원 배열 또는 "가변" 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-203">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array or "jagged" array of `int`.</span></span>

<span data-ttu-id="9507f-204">nullable 형식에는 별도의 정의가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-204">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="9507f-205">null을 허용하지 않는 형식 `T`의 경우, 대응되는 nullable 형식 `T?`가 있으며 이는 추가 값 `null`을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-205">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="9507f-206">예를 들어 `int?`는 32비트 정수 또는 `null` 값을 보유할 수 있는 형식이고, `string?`은 모든 `string` 또는 `null` 값을 보유할 수 있는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-206">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="9507f-207">C#의 형식 시스템은 모든 형식의 값이 `object`로 취급될 수 있도록 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-207">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="9507f-208">C#의 모든 형식은 `object` 클래스 형식에서 직접 또는 간접적으로 파생되고 `object`는 모든 형식의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-208">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="9507f-209">참조 형식의 값은 `object`로 인식함으로써 간단히 개체로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-209">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="9507f-210">값 형식의 값은 *boxing* 및 *unboxing 작업*을 수행하여 개체로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-210">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="9507f-211">다음 예제에서 `int` 값은 `object`로 변환되었다가 다시 `int`로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-211">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="9507f-212">값 형식의 값이 `object` 참조에 할당되면 값을 보유하기 위해 "box"가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-212">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="9507f-213">이 상자는 참조 형식의 인스턴스이며 해당 상자에 값이 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-213">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="9507f-214">반대로 `object` 참조가 값 형식으로 캐스트될 때 참조된 `object`가 올바른 값 형식의 상자인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-214">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="9507f-215">확인에 성공하면 상자의 값이 값 형식에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-215">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="9507f-216">C# 통합 형식 시스템은 결과적으로 값 형식이 "요청 시" `object` 참조로 처리됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-216">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="9507f-217">통합 때문에 `object` 형식을 사용하는 범용 라이브러리는 참조 형식과 값 형식을 모두 포함하여 `object`에서 파생되는 모든 유형에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-217">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="9507f-218">C#에는 필드, 배열 요소, 지역 변수 및 매개 변수를 포함하는 여러 종류의 *변수*가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-218">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="9507f-219">변수는 저장소 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-219">Variables represent storage locations.</span></span> <span data-ttu-id="9507f-220">모든 변수에는 아래와 같이 해당 변수에 저장할 수 있는 값을 결정하는 유형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-220">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="9507f-221">Null을 허용하지 않는 값 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-221">Non-nullable value type</span></span>
  - <span data-ttu-id="9507f-222">정확한 해당 형식의 값</span><span class="sxs-lookup"><span data-stu-id="9507f-222">A value of that exact type</span></span>
- <span data-ttu-id="9507f-223">Null 허용 값 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-223">Nullable value type</span></span>
  - <span data-ttu-id="9507f-224">`null` 값 또는 정확한 해당 형식의 값</span><span class="sxs-lookup"><span data-stu-id="9507f-224">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="9507f-225">object</span><span class="sxs-lookup"><span data-stu-id="9507f-225">object</span></span>
  - <span data-ttu-id="9507f-226">`null` 참조, 참조 형식의 개체에 대한 참조 또는 값 형식의 boxed 값에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="9507f-226">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="9507f-227">클래스 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-227">Class type</span></span>
  - <span data-ttu-id="9507f-228">`null` 참조, 해당 클래스 형식의 인스턴스에 대한 참조 또는 해당 클래스 형식에서 파생된 클래스의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="9507f-228">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="9507f-229">인터페이스 유형</span><span class="sxs-lookup"><span data-stu-id="9507f-229">Interface type</span></span>
  - <span data-ttu-id="9507f-230">`null` 참조, 해당 인터페이스 형식을 구현하는 클래스 형식의 인스턴스에 대한 참조 또는 해당 인터페이스 형식을 구현하는 값 형식의 boxed 값에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="9507f-230">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="9507f-231">배열 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-231">Array type</span></span>
  - <span data-ttu-id="9507f-232">`null` 참조, 해당 배열 형식의 인스턴스에 대한 참조 또는 호환되는 배열 형식의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="9507f-232">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="9507f-233">대리자 형식</span><span class="sxs-lookup"><span data-stu-id="9507f-233">Delegate type</span></span>
  - <span data-ttu-id="9507f-234">`null` 참조 또는 호환되는 대리자 형식의 인스턴스에 대한 참조</span><span class="sxs-lookup"><span data-stu-id="9507f-234">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="9507f-235">프로그램 구조</span><span class="sxs-lookup"><span data-stu-id="9507f-235">Program structure</span></span>

<span data-ttu-id="9507f-236">C#의 핵심적인 조직 개념은 [\*\*\*\*\*\* 프로그램](../programming-guide/inside-a-program/index.md), [\*\*\*\*\*\* 네임스페이스](../programming-guide/namespaces/index.md), [\*\*\*\*\*\* 형식](../programming-guide/types/index.md), [\*\*\*\*\*\* 멤버](../programming-guide/classes-and-structs/members.md) 및 [\*\*\*\*\*\* 어셈블리](../../standard/assembly/index.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-236">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="9507f-237">프로그램은 멤버를 포함하고 네임스페이스로 구성될 수 있는 형식을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-237">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="9507f-238">클래스, 구조체 및 인터페이스는 형식의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-238">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="9507f-239">필드, 메서드, 속성 및 이벤트는 멤버의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-239">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="9507f-240">C# 프로그램을 컴파일하면 실제로 어셈블리로 패키지됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-240">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="9507f-241">어셈블리는 일반적으로 ***애플리케이션***을 구현하는지 또는 ***라이브러리***를 구현하는지에 따라 각각 파일 확장명 `.exe` 또는 `.dll`을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-241">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="9507f-242">간단한 예로, 다음 코드를 포함하는 어셈블리를 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="9507f-242">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="9507f-243">이 클래스의 정규화된 이름은 `Acme.Collections.Stack`입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-243">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="9507f-244">클래스에는 필드 `top`, 2개의 메서드 `Push` 및 `Pop`, 중첩된 클래스 `Entry` 등의 여러 멤버가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-244">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="9507f-245">`Entry` 클래스는 필드 `next` 및 필드 `data`, 생성자의 세 멤버가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-245">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="9507f-246">`Stack`은 제네릭 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-246">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="9507f-247">이는 사용 시 구체적인 형식으로 대체되는 `T` 형식 매개 변수 하나를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-247">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="9507f-248">스택은 "FILO"(선입후출) 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-248">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="9507f-249">스택의 맨 위에 새 요소가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-249">New elements are added to the top of the stack.</span></span> <span data-ttu-id="9507f-250">요소가 제거되면 스택의 맨 위에서 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-250">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="9507f-251">어셈블리에는 IL(중간 언어) 명령 형식의 실행 코드와 메타데이터 형식의 기호 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-251">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="9507f-252">어셈블리가 실행되기 전에, .NET 공용 언어 런타임의 JIT(Just-In-Time) 컴파일러가 어셈블리 안의 IL 코드를 해당 프로세서에 맞는 코드로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-252">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="9507f-253">어셈블리는 코드와 메타데이터를 모두 포함하는 기능의 자체 설명 단위이므로 C#에서는 `#include` 지시문과 헤더 파일이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-253">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="9507f-254">특정 어셈블리에 포함된 공용 형식 및 멤버는 프로그램을 컴파일할 때 해당 어셈블리를 참조하는 것만으로 C# 프로그램에서 사용 가능해집니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-254">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="9507f-255">예를 들어 이 프로그램에서는 `acme.dll` 어셈블리의 `Acme.Collections.Stack` 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-255">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="9507f-256">이 프로그램을 컴파일하려면 이전 예제에 정의된 스택 클래스를 포함하는 어셈블리를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-256">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="9507f-257">C# 프로그램은 여러 원본 파일에 저장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-257">C# programs can be stored in several source files.</span></span> <span data-ttu-id="9507f-258">C# 프로그램을 컴파일하면 모든 원본 파일이 함께 처리되고 서로를 제약 없이 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-258">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="9507f-259">개념적으로 처리되기 전에 모든 원본 파일이 하나의 대량 파일에 연결된 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-259">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="9507f-260">소수의 경우를 제외하고 선언 순서는 중요하지 않으므로 C#에서는 정방향 선언이 필요한 경우가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-260">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="9507f-261">C#은 소스 파일을 하나의 공용 형식만 선언하도록 제한하거나 소스 파일 이름이 소스 파일에 선언된 형식과 일치하도록 요구하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-261">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="9507f-262">이 둘러보기의 추가 문서에서는 이러한 조직 구성 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9507f-262">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="9507f-263">다음</span><span class="sxs-lookup"><span data-stu-id="9507f-263">Next</span></span>](types.md)
