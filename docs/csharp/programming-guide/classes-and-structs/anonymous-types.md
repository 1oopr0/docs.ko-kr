---
title: 익명 형식 - C# 프로그래밍 가이드
description: C#의 익명 형식은 명시적으로 형식을 정의할 필요 없이 읽기 전용 속성 집합을 개체로 캡슐화합니다. 컴파일러가 이름을 생성합니다.
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: f60c1ea4f3f029ec3b81a4197a711523ec372df9
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186161"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="5d27f-104">익명 형식(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="5d27f-104">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="5d27f-105">익명 형식을 사용하면 먼저 명시적으로 형식을 정의할 필요 없이 읽기 전용 속성 집합을 단일 개체로 편리하게 캡슐화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-105">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="5d27f-106">형식 이름은 컴파일러에 의해 생성되며 소스 코드 수준에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-106">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="5d27f-107">각 속성의 형식은 컴파일러에서 유추합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-107">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="5d27f-108">[new](../../language-reference/operators/new-operator.md) 연산자를 개체 이니셜라이저와 함께 사용하여 무명 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-108">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="5d27f-109">개체 이니셜라이저에 대한 자세한 내용은 [개체 및 컬렉션 이니셜라이저](./object-and-collection-initializers.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5d27f-109">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="5d27f-110">다음 예제에서는 `Amount` 및 `Message`라는 두 속성으로 초기화된 익명 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-110">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="5d27f-111">일반적으로 무명 형식은 소스 시퀀스에 있는 각 개체의 속성 하위 집합을 반환하기 위해 쿼리 식의 [select](../../language-reference/keywords/select-clause.md) 절에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-111">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="5d27f-112">쿼리에 대한 자세한 내용은 [C#의 LINQ](../../linq/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5d27f-112">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="5d27f-113">익명 형식은 하나 이상의 public 읽기 전용 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-113">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="5d27f-114">메서드 또는 이벤트와 같은 다른 종류의 클래스 멤버는 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-114">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="5d27f-115">속성을 초기화하는 데 사용되는 식은 `null`, 익명 함수 또는 포인터 형식일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-115">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="5d27f-116">가장 일반적인 시나리오는 다른 형식의 속성으로 익명 형식을 초기화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-116">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="5d27f-117">다음 예제에서는 `Product`라는 클래스가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-117">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="5d27f-118">`Product` 클래스에는 `Color` 및 `Price` 속성뿐만 아니라 관심 없는 다른 속성도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-118">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="5d27f-119">`products` 변수는 `Product` 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-119">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="5d27f-120">익명 형식 선언은 `new` 키워드로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-120">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="5d27f-121">선언에서는 `Product`의 두 속성만 사용하는 새 형식을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-121">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="5d27f-122">따라서 쿼리에 작은 양의 데이터가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-122">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="5d27f-123">익명 형식에 멤버 이름을 지정하지 않으면 컴파일러가 익명 형식 멤버에 해당 멤버를 초기화하는 데 사용된 속성과 동일한 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-123">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="5d27f-124">앞의 예제에 표시된 것처럼, 식으로 초기화되는 속성의 이름을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-124">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="5d27f-125">다음 예제에서 익명 형식의 속성 이름은 `Color` 및 `Price`입니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-125">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="5d27f-126">일반적으로 무명 형식을 사용하여 변수를 초기화할 때는 [var](../../language-reference/keywords/var.md)을 사용하여 변수를 암시적 형식 지역 변수로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-126">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="5d27f-127">컴파일러만 익명 형식의 기본 이름에 액세스할 수 있으므로 변수 선언에는 형식 이름을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-127">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="5d27f-128">`var`에 대한 자세한 내용은 [암시적 형식 지역 변수](./implicitly-typed-local-variables.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5d27f-128">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="5d27f-129">다음 예제에 표시된 것처럼, 암시적으로 형식화된 지역 변수와 암시적으로 형식화된 배열을 결합하여 익명으로 형식화된 요소의 배열을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-129">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="5d27f-130">설명</span><span class="sxs-lookup"><span data-stu-id="5d27f-130">Remarks</span></span>  

 <span data-ttu-id="5d27f-131">무명 형식은 [object](../../language-reference/builtin-types/reference-types.md)에서 직접 파생되고 [object](../../language-reference/builtin-types/reference-types.md)를 제외한 어떠한 형식으로도 캐스팅될 수 없는 [class](../../language-reference/keywords/class.md) 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-131">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="5d27f-132">컴파일러는 애플리케이션에서 해당 익명 형식에 액세스할 수 없더라도 각 익명 형식의 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-132">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="5d27f-133">공용 언어 런타임의 관점에서 익명 형식은 다른 참조 형식과 다를 바가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-133">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="5d27f-134">어셈블리에서 둘 이상의 익명 개체 이니셜라이저가 순서와 이름 및 형식이 동일한 속성의 시퀀스를 지정하는 경우 컴파일러는 개체를 동일한 형식의 인스턴스로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-134">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="5d27f-135">이러한 개체는 컴파일러에서 생성된 동일한 형식 정보를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-135">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="5d27f-136">익명 형식을 가지고 있으므로 필드, 속성, 이벤트 또는 메서드의 반환 형식은 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-136">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="5d27f-137">마찬가지로, 익명 형식을 가지고 있으므로 메서드, 속성, 생성자 또는 인덱서의 정식 매개 변수는 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-137">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="5d27f-138">익명 형식이나 익명 형식을 포함한 컬렉션을 메서드에 대한 인수로 전달하려면 매개 변수를 형식 개체로 선언하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-138">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="5d27f-139">그러나 이렇게 하면 강력한 형식화를 사용하는 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-139">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="5d27f-140">쿼리 결과를 저장하거나 메서드 경계 외부로 전달해야 하는 경우 익명 형식 대신 일반적인 명명된 구조체 또는 클래스 사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="5d27f-140">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="5d27f-141">익명 형식에 대한 <xref:System.Object.Equals%2A> 및 <xref:System.Object.GetHashCode%2A> 메서드는 속성의 `Equals` 및 `GetHashCode` 메서드 측면에서 정의되므로 동일한 익명 형식의 두 인스턴스는 해당 속성이 모두 동일한 경우에만 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="5d27f-141">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5d27f-142">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5d27f-142">See also</span></span>

- [<span data-ttu-id="5d27f-143">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="5d27f-143">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="5d27f-144">개체 이니셜라이저 및 컬렉션 이니셜라이저</span><span class="sxs-lookup"><span data-stu-id="5d27f-144">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="5d27f-145">C#에서 LINQ 시작</span><span class="sxs-lookup"><span data-stu-id="5d27f-145">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="5d27f-146">C#의 LINQ</span><span class="sxs-lookup"><span data-stu-id="5d27f-146">LINQ in C#</span></span>](../../linq/index.md)
