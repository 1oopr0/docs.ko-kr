---
title: 확장 메서드 - C# 프로그래밍 가이드
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 5db2797870b6c2e1998f17f1d8e4df8aa3f95c9e
ms.sourcegitcommit: a241301495a84cc8c64fe972330d16edd619868b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/01/2020
ms.locfileid: "84241411"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="16c27-102">확장명 메서드(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="16c27-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="16c27-103">확장명 메서드를 사용하면 새 파생 형식을 만들거나 다시 컴파일하거나 원래 형식을 수정하지 않고도 기존 형식에 메서드를 "추가"할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="16c27-104">확장 메서드는 정적 메서드이지만 확장 형식의 인스턴스 메서드인 것처럼 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="16c27-105">C#, F# 및 Visual Basic에서 작성된 클라이언트 코드의 경우 확장명 메서드를 호출하는 것과 형식에 정의된 메서드를 호출하는 데는 명백한 차이가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="16c27-106">가장 일반적인 확장명 메서드는 쿼리 기능을 기존 <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 및 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 형식에 추가하는 LINQ 표준 쿼리 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="16c27-107">표준 쿼리 연산자를 사용하려면 `using System.Linq` 지시문을 사용해서 먼저 범위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="16c27-108">그러면 <xref:System.Collections.Generic.IEnumerable%601>을 구현하는 모든 형식에 <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> 등의 인스턴스 메서드가 있는 것처럼 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="16c27-109"><xref:System.Collections.Generic.List%601> 또는 <xref:System.Array>와 같은 <xref:System.Collections.Generic.IEnumerable%601> 형식의 인스턴스 뒤에 "dot"를 입력하면 IntelliSense 문 완성에서 이러한 추가 메서드를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="16c27-110">OrderBy 예제</span><span class="sxs-lookup"><span data-stu-id="16c27-110">OrderBy Example</span></span>

<span data-ttu-id="16c27-111">다음 예제에서는 정수 배열에서 표준 쿼리 연산자 `OrderBy`를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="16c27-112">괄호 안의 식은 람다 식입니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="16c27-113">많은 표준 쿼리 연산자가 람다 식을 매개 변수로 사용하지만 확장명 메서드에 대한 요구 사항은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="16c27-114">자세한 내용은 [람다 식](../statements-expressions-operators/lambda-expressions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="16c27-115">확장명 메서드는 정적 메서드로 정의되지만 인스턴스 메서드 구문을 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="16c27-116">첫 번째 매개 변수는 메서드가 작동하는 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="16c27-117">매개 변수 앞에 [이](../../language-reference/keywords/this.md) 한정자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="16c27-118">확장 메서드는 `using` 지시문을 사용하여 명시적으로 네임스페이스를 소스 코드로 가져오는 경우에만 범위에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="16c27-119">다음 예제에서는 <xref:System.String?displayProperty=nameWithType> 클래스에 대해 정의된 확장 메서드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="16c27-120">이 확장 메서드는 제네릭이 아닌 비중첩 정적 클래스 내부에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="16c27-121">`WordCount` 지시문을 사용하여 `using` 확장 메서드를 범위로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="16c27-122">또한 다음 구문을 사용하여 애플리케이션에서 확장 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="16c27-123">코드에서 인스턴스 메서드 구문을 사용하여 확장 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="16c27-124">컴파일러에서 생성된 IL(중간 언어)이 코드를 정적 메서드 호출로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="16c27-125">실제로 캡슐화의 원칙을 위반하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="16c27-126">확장명 메서드는 확장하는 형식의 private 변수에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="16c27-127">자세한 내용은 [사용자 지정 확장 메서드를 구현 및 호출하는 방법](./how-to-implement-and-call-a-custom-extension-method.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="16c27-128">일반적으로 확장명 메서드를 직접 구현하는 것보다 호출하는 경우가 훨씬 많습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="16c27-129">확장 메서드는 인스턴스 메서드 구문을 사용하여 호출되므로 특별한 지식이 없어도 클라이언트 코드에서 확장 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="16c27-130">특정 형식의 확장 메서드를 사용하려면 해당 메서드가 정의된 네임스페이스에 대해 `using` 지시문을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="16c27-131">예를 들어 표준 쿼리 연산자를 사용하려면 다음 `using` 지시문을 코드에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="16c27-132">System.Core.dll에 대한 참조를 추가해야 할 수도 있습니다. 이제 표준 쿼리 연산자가 대부분의 <xref:System.Collections.Generic.IEnumerable%601> 형식에 사용할 수 있는 추가 메서드로 IntelliSense에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="16c27-133">컴파일 타임에 확장 메서드 바인딩</span><span class="sxs-lookup"><span data-stu-id="16c27-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="16c27-134">확장 메서드를 사용하여 클래스 또는 인터페이스를 확장할 수 있지만 재정의할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="16c27-135">이름과 시그니처가 인터페이스 또는 클래스 메서드와 동일한 확장 메서드는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="16c27-136">컴파일 시간에 확장 메서드는 항상 형식 자체에서 정의된 인스턴스 메서드보다 우선 순위가 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="16c27-137">즉, 형식에 `Process(int i)`라는 메서드가 있고 동일한 시그니처를 가진 확장 메서드가 있는 경우 컴파일러는 항상 인스턴스 메서드에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="16c27-138">컴파일러는 메서드 호출을 발견할 경우 먼저 형식의 인스턴스 메서드에서 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="16c27-139">일치 항목이 없으면 형식에 대해 정의된 확장 메서드를 검색하고 찾은 첫 번째 확장 메서드에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="16c27-140">다음 예제에서는 컴파일러가 바인딩할 확장명 메서드 또는 인스턴스 메서드를 확인하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="16c27-141">예제</span><span class="sxs-lookup"><span data-stu-id="16c27-141">Example</span></span>

<span data-ttu-id="16c27-142">다음 예제에서는 C# 컴파일러가 메서드 호출을 형식의 인스턴스 메서드 또는 확장명 메서드에 바인딩할 것인지 결정할 때 따르는 규칙을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="16c27-143">정적 클래스 `Extensions`는 `IMyInterface`를 구현하는 모든 형식에 대해 정의된 확장 메서드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="16c27-144">`A`, `B` 및 `C` 클래스는 모두 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="16c27-145">`MethodB` 확장 메서드는 이름과 시그니처가 클래스에서 이미 구현된 메서드와 정확하게 일치하므로 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="16c27-146">일치하는 시그니처를 가진 인스턴스 메서드를 찾을 수 없으면 컴파일러는 일치하는 확장명 메서드(있는 경우)에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="16c27-147">일반적인 사용 패턴</span><span class="sxs-lookup"><span data-stu-id="16c27-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="16c27-148">컬렉션 기능</span><span class="sxs-lookup"><span data-stu-id="16c27-148">Collection Functionality</span></span>

<span data-ttu-id="16c27-149">과거에는 지정된 형식에 대한 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 인터페이스를 구현하고 해당 형식의 컬렉션에 작동하는 기능을 포함하는 "컬렉션 클래스"를 만드는 것이 일반적이었습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="16c27-150">이 형식의 컬렉션 개체를 만들어도 아무런 문제가 없지만 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 확장을 사용하여 동일한 기능을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="16c27-151">확장은 해당 형식에 대한 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>를 구현하는 <xref:System.Array?displayProperty=nameWithType> 또는 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 같은 모든 컬렉션에서 기능을 호출할 수 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="16c27-152">Int32 배열을 사용하는 해당 예제는 [이 문서의 앞부분](#orderby-example)에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="16c27-153">레이어 관련 기능</span><span class="sxs-lookup"><span data-stu-id="16c27-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="16c27-154">양파형 아키텍처 또는 다른 계층화된 애플리케이션 디자인을 사용하는 경우 애플리케이션 경계에서 통신하는 데 사용할 수 있는 도메인 엔터티 또는 데이터 전송 개체의 집합을 사용하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="16c27-155">이러한 개체는 일반적으로 아무 기능이 없거나 애플리케이션의 모든 레이어에 적용되는 기능만 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="16c27-156">확장 메서드를 사용하여 다른 레이어에서 필요하지 않은 메서드를 사용하여 개체를 로드하지 않고 각 애플리케이션 레이어와 관련된 기능을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="16c27-157">미리 정의된 형식 확장</span><span class="sxs-lookup"><span data-stu-id="16c27-157">Extending Predefined Types</span></span>

<span data-ttu-id="16c27-158">재사용 가능한 기능을 만들어야 할 때 새 개체를 만드는 대신 기존 형식(예: .NET 또는 CLR 형식)을 확장하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="16c27-159">예를 들어 확장 메서드를 사용하지 않는 경우 SQL Server에 대해 쿼리를 실행하는 작업을 수행하기 위해 코드의 여러 위치에서 호출될 수 있는 `Engine` 또는 `Query` 클래스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="16c27-160">그러나 대신 확장 메서드를 사용하여 <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> 클래스를 확장하면 SQL Server에 연결된 모든 위치에서 해당 쿼리를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="16c27-161">다른 예로는 <xref:System.String?displayProperty=nameWithType> 클래스에 공통 기능 추가, <xref:System.IO.File?displayProperty=nameWithType> 및 <xref:System.IO.Stream?displayProperty=nameWithType> 개체의 데이터 처리 기능 확장, 특정 오류 처리 기능을 위한 <xref:System.Exception?displayProperty=nameWithType> 개체를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="16c27-162">이러한 사용 사례 유형은 상상력과 판단력에 의해서만 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="16c27-163">미리 정의된 형식의 확장은 메서드에 값으로 전달되는 `struct` 형식에는 사용하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="16c27-164">구조체의 모든 변경 내용이 구조체의 복사본에 적용되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="16c27-165">이러한 변경 내용은 확장 메서드가 만들어진 이후에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="16c27-166">C# 7.2부터 확장 메서드의 첫 번째 인수에 `ref` 한정자를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="16c27-167">`ref` 한정자를 추가하면 첫 번째 인수가 참조로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="16c27-168">이렇게 하면 확장되는 구조체의 상태를 변경하는 확장 메서드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="16c27-169">일반 지침</span><span class="sxs-lookup"><span data-stu-id="16c27-169">General Guidelines</span></span>

<span data-ttu-id="16c27-170">개체의 코드를 수정하거나 적절하고 가능할 때마다 새 형식을 파생하는 것을 여전히 선호할 수 있지만 확장 메서드는 .NET 에코시스템 전체에서 재사용 가능한 기능을 만들기 위한 중요한 옵션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="16c27-171">사용자가 원래 소스를 제어하지 않는 경우, 파생 개체가 부적절하거나 불가능한 경우 또는 기능을 적용 가능한 범위 이상으로 노출하지 않아야 하는 경우에는 확장 메서드를 선택하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="16c27-172">파생 형식에 대한 자세한 내용은 [상속](./inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="16c27-173">기존 메서드를 사용하여 소스 코드를 제어할 수 없는 형식을 확장하는 경우 형식의 구현이 변경되어 확장명 메서드가 손상될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="16c27-174">지정된 형식에 대해 확장 메서드를 구현하는 경우 다음 사항에 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="16c27-175">시그니처가 형식에 정의된 메서드와 동일한 확장 메서드는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="16c27-176">확장 메서드는 네임스페이스 수준에서 범위로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="16c27-177">예를 들어 `Extensions`라는 단일 네임스페이스에 확장 메서드를 포함하는 여러 개의 정적 클래스가 있는 경우 `using Extensions;` 지시문을 통해 모두 범위로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="16c27-178">구현된 클래스 라이브러리의 경우 어셈블리의 버전 번호가 증가되는 것을 방지하기 위해 확장 메서드를 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="16c27-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="16c27-179">소스 코드를 소유하고 있는 라이브러리에 중요 기능을 추가하려는 경우 어셈블리 버전 관리를 위한 .NET 지침을 따르세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="16c27-180">자세한 내용은 [어셈블리 버전 관리](../../../standard/assembly/versioning.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="16c27-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="16c27-181">참조</span><span class="sxs-lookup"><span data-stu-id="16c27-181">See also</span></span>

- [<span data-ttu-id="16c27-182">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="16c27-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="16c27-183">병렬 프로그래밍 샘플(많은 예제 확장 메서드 포함)</span><span class="sxs-lookup"><span data-stu-id="16c27-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="16c27-184">람다 식</span><span class="sxs-lookup"><span data-stu-id="16c27-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="16c27-185">표준 쿼리 연산자 개요</span><span class="sxs-lookup"><span data-stu-id="16c27-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="16c27-186">인스턴스 매개 변수의 변환 규칙 및 그에 따른 영향</span><span class="sxs-lookup"><span data-stu-id="16c27-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="16c27-187">언어 간 확장 메서드 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="16c27-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="16c27-188">확장 메서드 및 대리자 변환</span><span class="sxs-lookup"><span data-stu-id="16c27-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="16c27-189">확장 메서드 바인딩 및 오류 보고</span><span class="sxs-lookup"><span data-stu-id="16c27-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
