---
title: 대리자 사용 - C# 프로그래밍 가이드
description: 대리자를 사용하는 방법을 알아봅니다. 대리자는 메서드를 안전하게 캡슐화하는 개체 지향적이고 형식이 안전하며 보안이 유지되는 형식입니다.
ms.date: 07/20/2015
helpviewer_keywords:
- delegates [C#], how to use
ms.assetid: 99a2fc27-a32e-4a34-921c-e65497520eec
ms.openlocfilehash: a9b625b8c0785ed2f446be27c11dc76108bc4bce
ms.sourcegitcommit: 6f58a5f75ceeb936f8ee5b786e9adb81a9a3bee9
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/28/2020
ms.locfileid: "87302154"
---
# <a name="using-delegates-c-programming-guide"></a><span data-ttu-id="61c88-104">대리자 사용(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="61c88-104">Using Delegates (C# Programming Guide)</span></span>

<span data-ttu-id="61c88-105">[대리자](../../language-reference/builtin-types/reference-types.md)는 C 및 C++의 함수 포인터처럼 메서드를 안전하게 캡슐화하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-105">A [delegate](../../language-reference/builtin-types/reference-types.md) is a type that safely encapsulates a method, similar to a function pointer in C and C++.</span></span> <span data-ttu-id="61c88-106">함수 포인터와는 달리 대리자는 개체 지향적이고 형식이 안전하며 보안이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-106">Unlike C function pointers, delegates are object-oriented, type safe, and secure.</span></span> <span data-ttu-id="61c88-107">대리자의 형식은 대리자의 이름으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-107">The type of a delegate is defined by the name of the delegate.</span></span> <span data-ttu-id="61c88-108">다음 예제에서는 [string](../../language-reference/builtin-types/reference-types.md)을 인수로 사용하고 [void](../../language-reference/builtin-types/void.md)를 반환하는 메서드를 캡슐화할 수 있는 `Del` 대리자를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-108">The following example declares a delegate named `Del` that can encapsulate a method that takes a [string](../../language-reference/builtin-types/reference-types.md) as an argument and returns [void](../../language-reference/builtin-types/void.md):</span></span>

[!code-csharp[csProgGuideDelegates#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#21)]

<span data-ttu-id="61c88-109">대리자 개체는 일반적으로 대리자가 래핑할 메서드의 이름을 제공하거나 [익명 함수](../statements-expressions-operators/anonymous-functions.md)를 사용하여 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-109">A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an [anonymous function](../statements-expressions-operators/anonymous-functions.md).</span></span> <span data-ttu-id="61c88-110">대리자를 인스턴스화하고 나면 대리자에 대한 메서드 호출이 대리자에 의해 해당 메서드로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-110">Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</span></span> <span data-ttu-id="61c88-111">호출자가 대리자에게 전달한 매개 변수가 메서드로 전달되며 메서드의 반환 값(있는 경우)이 대리자에 의해 호출자로 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-111">The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</span></span> <span data-ttu-id="61c88-112">이 과정을 대리자 호출이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-112">This is known as invoking the delegate.</span></span> <span data-ttu-id="61c88-113">인스턴스화된 대리자는 래핑된 메서드 자체인 것처럼 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-113">An instantiated delegate can be invoked as if it were the wrapped method itself.</span></span> <span data-ttu-id="61c88-114">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="61c88-114">For example:</span></span>

[!code-csharp[csProgGuideDelegates#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#22)]  

[!code-csharp[csProgGuideDelegates#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#23)]

<span data-ttu-id="61c88-115">대리자 형식은 .NET의 <xref:System.Delegate> 클래스에서 파생되며,</span><span class="sxs-lookup"><span data-stu-id="61c88-115">Delegate types are derived from the <xref:System.Delegate> class in .NET.</span></span> <span data-ttu-id="61c88-116">[봉인](../../language-reference/keywords/sealed.md)되어 있으므로 <xref:System.Delegate>에서는 파생될 수 없으며 해당 클래스에서 사용자 지정 클래스를 파생할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-116">Delegate types are [sealed](../../language-reference/keywords/sealed.md)—they cannot be derived from— and it is not possible to derive custom classes from <xref:System.Delegate>.</span></span> <span data-ttu-id="61c88-117">인스턴스화된 대리자는 개체이므로 매개 변수로 전달하거나 속성에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-117">Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</span></span> <span data-ttu-id="61c88-118">따라서 메서드가 대리자를 매개 변수로 허용하고 나중에 대리자를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-118">This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</span></span> <span data-ttu-id="61c88-119">비동기 콜백이라는 이러한 방식은 긴 프로세스 완료 시 호출자에게 알림을 제공하는 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-119">This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</span></span> <span data-ttu-id="61c88-120">이러한 방식으로 대리자를 사용하면 대리자를 사용하는 코드가 사용 중인 메서드의 구현을 확인하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-120">When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</span></span> <span data-ttu-id="61c88-121">이 기능은 캡슐화 인터페이스에서 제공하는 기능과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-121">The functionality is similar to the encapsulation interfaces provide.</span></span>

<span data-ttu-id="61c88-122">콜백은 사용자 지정 비교 메서드를 정의하고 해당 대리자를 정렬 메서드로 전달할 때도 일반적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-122">Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</span></span> <span data-ttu-id="61c88-123">이 경우 호출자의 코드를 정렬 알고리즘의 일부분으로 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-123">It allows the caller's code to become part of the sort algorithm.</span></span> <span data-ttu-id="61c88-124">다음 예제 메서드는 `Del` 형식을 매개 변수로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-124">The following example method uses the `Del` type as a parameter:</span></span>

[!code-csharp[csProgGuideDelegates#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#24)]

<span data-ttu-id="61c88-125">위에서 작성된 대리자를 해당 메서드로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-125">You can then pass the delegate created above to that method:</span></span>

[!code-csharp[csProgGuideDelegates#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#25)]

<span data-ttu-id="61c88-126">그러면 콘솔에 다음 출력이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-126">and receive the following output to the console:</span></span>

```console
The number is: 3
```

<span data-ttu-id="61c88-127">대리자를 추상화로 사용하는 경우 `MethodWithCallback`이 콘솔을 직접 호출할 필요가 없으며 콘솔을 호출하기 위해 이 메서드를 지정하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-127">Using the delegate as an abstraction, `MethodWithCallback` does not need to call the console directly—it does not have to be designed with a console in mind.</span></span> <span data-ttu-id="61c88-128">`MethodWithCallback`은 단순히 문자열을 준비하여 다른 메서드로 전달할 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-128">What `MethodWithCallback` does is simply prepare a string and pass the string to another method.</span></span> <span data-ttu-id="61c88-129">위임된 메서드는 매개 변수를 필요한 수만큼 사용할 수 있으므로 이러한 방식은 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-129">This is especially powerful since a delegated method can use any number of parameters.</span></span>

<span data-ttu-id="61c88-130">인스턴스 메서드를 래핑하기 위한 대리자를 생성할 때 해당 대리자는 인스턴스와 메서드를 모두 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-130">When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</span></span> <span data-ttu-id="61c88-131">대리자는 래핑 대상 메서드 이외의 인스턴스 형식은 알 수 없으므로 해당 개체에 대리자 서명과 일치하는 메서드가 있으면 모든 개체 형식을 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-131">A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</span></span> <span data-ttu-id="61c88-132">정적 메서드를 래핑하기 위해 생성하는 대리자는 메서드만 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-132">When a delegate is constructed to wrap a static method, it only references the method.</span></span> <span data-ttu-id="61c88-133">다음의 선언을 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="61c88-133">Consider the following declarations:</span></span>

[!code-csharp[csProgGuideDelegates#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#26)]

<span data-ttu-id="61c88-134">이제는 위에 나와 있는 정적 `DelegateMethod`와 함께 3개 메서드를 `Del` 인스턴스로 래핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-134">Along with the static `DelegateMethod` shown previously, we now have three methods that can be wrapped by a `Del` instance.</span></span>

<span data-ttu-id="61c88-135">대리자는 호출 시 둘 이상의 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-135">A delegate can call more than one method when invoked.</span></span> <span data-ttu-id="61c88-136">이러한 호출을 멀티캐스트라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-136">This is referred to as multicasting.</span></span> <span data-ttu-id="61c88-137">대리자의 메서드 목록(호출 목록)에 메서드를 더 추가하려는 경우 더하기 또는 더하기 대입 연산자('+' 또는 '+=')를 사용하여 대리자만 두 개 더 추가하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-137">To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</span></span> <span data-ttu-id="61c88-138">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="61c88-138">For example:</span></span>

[!code-csharp[csProgGuideDelegates#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#27)]

<span data-ttu-id="61c88-139">이 시점에서 `allMethodsDelegate`의 호출 목록에는 `Method1`, `Method2`, `DelegateMethod`의 3개 메서드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-139">At this point `allMethodsDelegate` contains three methods in its invocation list—`Method1`, `Method2`, and `DelegateMethod`.</span></span> <span data-ttu-id="61c88-140">원래 대리자 3개(`d1`, `d2`, `d3`)는 그대로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-140">The original three delegates, `d1`, `d2`, and `d3`, remain unchanged.</span></span> <span data-ttu-id="61c88-141">`allMethodsDelegate`를 호출하면 3개 메서드가 모두 순서대로 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-141">When `allMethodsDelegate` is invoked, all three methods are called in order.</span></span> <span data-ttu-id="61c88-142">대리자가 참조 매개 변수를 사용하는 경우 참조는 각 3개 메서드에 순서대로 전달되며 메서드 하나의 변경 내용은 다음 메서드에도 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-142">If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</span></span> <span data-ttu-id="61c88-143">메서드 중 하나라도 메서드 내에서 catch되지 않은 예외를 throw하면 해당 예외가 대리자의 호출자에게 해당 예외가 전달되며 호출 목록의 후속 메서드는 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-143">When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</span></span> <span data-ttu-id="61c88-144">반환 값 및/또는 out 매개 변수를 포함하는 대리자는 마지막으로 호출한 메서드의 반환 값과 매개 변수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-144">If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</span></span> <span data-ttu-id="61c88-145">호출 목록에서 메서드를 제거하려면 [빼기 또는 빼기 대입 연산자](../../language-reference/operators/subtraction-operator.md)(`-` 또는 `-=`)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-145">To remove a method from the invocation list, use the [subtraction or subtraction assignment operators](../../language-reference/operators/subtraction-operator.md) (`-` or `-=`).</span></span> <span data-ttu-id="61c88-146">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="61c88-146">For example:</span></span>

[!code-csharp[csProgGuideDelegates#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#28)]

<span data-ttu-id="61c88-147">대리자 형식은 `System.Delegate`에서 파생되므로 해당 클래스로 정의되는 메서드와 속성을 대리자에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-147">Because delegate types are derived from `System.Delegate`, the methods and properties defined by that class can be called on the delegate.</span></span> <span data-ttu-id="61c88-148">예를 들어 대리자의 호출 목록에 있는 메서드 수를 확인하려는 경우 다음과 같이 코드를 작성하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-148">For example, to find the number of methods in a delegate's invocation list, you may write:</span></span>

[!code-csharp[csProgGuideDelegates#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#29)]

<span data-ttu-id="61c88-149">호출 목록에 메서드가 둘 이상 포함된 대리자는 <xref:System.MulticastDelegate>의 하위 클래스인 `System.Delegate`에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-149">Delegates with more than one method in their invocation list derive from <xref:System.MulticastDelegate>, which is a subclass of `System.Delegate`.</span></span> <span data-ttu-id="61c88-150">두 클래스가 모두 `GetInvocationList`를 지원하므로 위의 코드는 두 경우에 모두 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-150">The above code works in either case because both classes support `GetInvocationList`.</span></span>

<span data-ttu-id="61c88-151">멀티캐스트 대리자는 이벤트 처리에서 광범위하게 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-151">Multicast delegates are used extensively in event handling.</span></span> <span data-ttu-id="61c88-152">이벤트 소스 개체는 해당 이벤트를 받도록 등록된 받는 사람 개체에 이벤트 알림을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-152">Event source objects send event notifications to recipient objects that have registered to receive that event.</span></span> <span data-ttu-id="61c88-153">이벤트를 등록하기 위해 받는 사람은 이벤트를 처리하도록 설계된 메서드를 만든 다음 해당 메서드의 대리자를 만들어 이벤트 소스로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-153">To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</span></span> <span data-ttu-id="61c88-154">소스는 이벤트 발생 시 대리자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-154">The source calls the delegate when the event occurs.</span></span> <span data-ttu-id="61c88-155">그러면 대리자가 받는 사람에 대해 이벤트 처리 메서드를 호출하여 이벤트 데이터를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-155">The delegate then calls the event handling method on the recipient, delivering the event data.</span></span> <span data-ttu-id="61c88-156">지정된 이벤트의 대리자 형식은 이벤트 소스에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-156">The delegate type for a given event is defined by the event source.</span></span> <span data-ttu-id="61c88-157">자세한 내용은 [이벤트](../events/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="61c88-157">For more, see [Events](../events/index.md).</span></span>

<span data-ttu-id="61c88-158">컴파일 시간에 할당된 서로 다른 형식의 두 대리자를 비교하면 컴파일 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-158">Comparing delegates of two different types assigned at compile-time will result in a compilation error.</span></span> <span data-ttu-id="61c88-159">대리자 인스턴스가 정적 `System.Delegate` 형식이면 비교는 허용되지만 런타임에서 false가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-159">If the delegate instances are statically of the type `System.Delegate`, then the comparison is allowed, but will return false at run time.</span></span> <span data-ttu-id="61c88-160">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="61c88-160">For example:</span></span>

[!code-csharp[csProgGuideDelegates#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#30)]

## <a name="see-also"></a><span data-ttu-id="61c88-161">참고 항목</span><span class="sxs-lookup"><span data-stu-id="61c88-161">See also</span></span>

- [<span data-ttu-id="61c88-162">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="61c88-162">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="61c88-163">대리자</span><span class="sxs-lookup"><span data-stu-id="61c88-163">Delegates</span></span>](./index.md)
- [<span data-ttu-id="61c88-164">대리자의 가변성 사용</span><span class="sxs-lookup"><span data-stu-id="61c88-164">Using Variance in Delegates</span></span>](../concepts/covariance-contravariance/using-variance-in-delegates.md)
- [<span data-ttu-id="61c88-165">대리자의 가변성</span><span class="sxs-lookup"><span data-stu-id="61c88-165">Variance in Delegates</span></span>](../concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="61c88-166">Func 및 Action 제네릭 대리자에 가변성 사용</span><span class="sxs-lookup"><span data-stu-id="61c88-166">Using Variance for Func and Action Generic Delegates</span></span>](../concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)
- [<span data-ttu-id="61c88-167">이벤트</span><span class="sxs-lookup"><span data-stu-id="61c88-167">Events</span></span>](../events/index.md)
