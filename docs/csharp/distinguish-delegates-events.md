---
title: 대리자 및 이벤트
description: 대리자와 이벤트 간의 차이점 및 .NET Core의 이러한 기능을 사용하는 경우를 각각 알아봅니다.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 193a9b0fe0e0c36deb6552449c92135057412225
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/03/2020
ms.locfileid: "89414671"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="aed1d-103">대리자 및 이벤트를 구별</span><span class="sxs-lookup"><span data-stu-id="aed1d-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="aed1d-104">이전</span><span class="sxs-lookup"><span data-stu-id="aed1d-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="aed1d-105">.NET Core 플랫폼을 처음 사용하는 개발자는 `delegates` 기반 디자인과 `events` 기반 디자인 중에서 결정할 때 종종 어려움을 겪습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="aed1d-106">두 언어 기능이 유사하므로 대리자 또는 이벤트를 선택하는 것이 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-106">The choice of delegates or events is often difficult, because the two language features are similar.</span></span> <span data-ttu-id="aed1d-107">이벤트는 대리자에 대한 언어 지원을 사용하여 작성되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="aed1d-108">둘 다 런타임에 바인딩 시나리오를 제공합니다. 즉, 런타임에만 알려지는 메서드를 호출하여 구성 요소가 통신하는 시나리오가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="aed1d-109">모두 단일 및 다중 구독자 메서드를 지원하는데,</span><span class="sxs-lookup"><span data-stu-id="aed1d-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="aed1d-110">이를 단일 캐스트 및 멀티캐스트 지원이라고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="aed1d-111">둘 다 처리기 추가 및 제거에 대해 유사한 구문을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="aed1d-112">마지막으로 이벤트를 발생시키고 대리자를 호출하는 작업에서 정확히 동일한 메서드 호출 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="aed1d-113">또한 `?.` 연산자와 함께 사용하도록 동일한 `Invoke()` 메서드 구문을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="aed1d-114">이러한 모든 유사성으로 인해 언제 어떤 언어 기능을 사용할지를 결정하기가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="aed1d-115">이벤트 수신은 선택 사항임</span><span class="sxs-lookup"><span data-stu-id="aed1d-115">Listening to Events is Optional</span></span>

<span data-ttu-id="aed1d-116">사용할 언어 기능을 결정할 때 가장 중요하게 고려할 사항은 연결된 구독자가 있어야 하는지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="aed1d-117">코드에서 구독자가 제공하는 코드를 호출해야 하는 경우에는 콜백을 구현해야 할 때 대리자 기반 디자인을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates when you need to implement callback.</span></span> <span data-ttu-id="aed1d-118">코드에서 구독자를 호출하지 않고 모든 작업을 완료할 수 있는 경우에는 이벤트 기반 디자인을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="aed1d-119">이 섹션 중 작성된 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-119">Consider the examples built during this section.</span></span> <span data-ttu-id="aed1d-120">`List.Sort()`를 사용하여 작성한 코드에서 요소를 제대로 정렬하려면 비교자 함수가 제공되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="aed1d-121">반환할 요소를 결정하려면 대리자와 함께 LINQ 쿼리를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="aed1d-122">둘 다 대리자로 작성된 디자인을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="aed1d-123">`Progress` 이벤트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-123">Consider the `Progress` event.</span></span> <span data-ttu-id="aed1d-124">이 이벤트는 작업의 진행률을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-124">It reports progress on a task.</span></span>
<span data-ttu-id="aed1d-125">수신기가 있는지 여부에 관계없이 작업이 계속 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="aed1d-126">`FileSearcher`는 또 다른 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="aed1d-127">연결된 이벤트 구독자가 없는 경우에도 검색된 모든 파일을 계속 검색하고 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="aed1d-128">UX 컨트롤은 이벤트를 수신하는 구독자가 없는 경우에도 여전히 올바르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="aed1d-129">둘 다 이벤트 기반 디자인을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="aed1d-130">반환 값에 대리자 필요</span><span class="sxs-lookup"><span data-stu-id="aed1d-130">Return Values Require Delegates</span></span>

<span data-ttu-id="aed1d-131">또 다른 고려 사항은 대리자 메서드에 필요한 메서드 프로토타입입니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="aed1d-132">지금까지 살펴본 대로 이벤트에 사용된 대리자는 모두 void 반환 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="aed1d-133">또한 이벤트 인수 개체의 속성을 수정하여 이벤트 소스에 다시 정보를 전달하는 이벤트 처리기를 만드는 관용구가 있음을 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="aed1d-134">이러한 관용구도 작업을 수행하기는 하지만 메서드에서 값을 반환하는 것만큼 자연스럽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="aed1d-135">이러한 두 가지 추론은 종종 존재할 수 있습니다. 대리자 메서드가 값을 반환하는 경우 어떤 방식으로든 알고리즘에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="aed1d-136">이벤트에 프라이빗 호출이 있음</span><span class="sxs-lookup"><span data-stu-id="aed1d-136">Events Have Private Invocation</span></span>

<span data-ttu-id="aed1d-137">이벤트가 포함된 클래스가 아닌 다른 클래스는 이벤트 수신기를 추가하고 제거할 수만 있습니다. 이벤트가 포함된 클래스만 이벤트를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="aed1d-138">이벤트는 일반적으로 공용 클래스 멤버입니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-138">Events are typically public class members.</span></span>
<span data-ttu-id="aed1d-139">반면 대리자는 종종 매개 변수로 전달되고 프라이빗 클래스 멤버로 저장됩니다(저장되는 경우).</span><span class="sxs-lookup"><span data-stu-id="aed1d-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="aed1d-140">종종 이벤트 수신기의 수명이 길어짐</span><span class="sxs-lookup"><span data-stu-id="aed1d-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="aed1d-141">이 이벤트 수신기는 수명이 길수록 근거가 약간 약해집니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-141">That event listeners have longer lifetimes is a slightly weaker justification.</span></span> <span data-ttu-id="aed1d-142">그러나 이벤트 소스가 오랜 시간 동안 이벤트를 발생시킬 경우에는 이벤트 기반 디자인이 더 자연스러울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="aed1d-143">많은 시스템에서 UX 컨트롤의 이벤트 기반 디자인 예제를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-143">You can see examples of event-based design for UX controls on many systems.</span></span> <span data-ttu-id="aed1d-144">이벤트를 구독하면 이벤트 소스가 프로그램의 수명 주기 전체에 걸쳐 이벤트를 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="aed1d-145">이벤트가 더 이상 필요하지 않은 경우 이벤트 구독을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="aed1d-146">대리자가 메서드의 인수로 사용되고 해당 메서드가 반환된 후에는 대리자가 사용되지 않는 많은 대리자 기반 디자인과 비교해 보세요.</span><span class="sxs-lookup"><span data-stu-id="aed1d-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="aed1d-147">신중하게 평가</span><span class="sxs-lookup"><span data-stu-id="aed1d-147">Evaluate Carefully</span></span>

<span data-ttu-id="aed1d-148">위의 고려 사항은 엄격한 규칙이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="aed1d-149">대신 특정 용도에 가장 적합한 선택 항목을 결정하는 데 도움이 되는 지침을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="aed1d-150">유사하기 때문에 둘 다를 프로토타입화할 수도 있고 작업에 더 자연스러운 항목을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="aed1d-151">둘 다 런타임에 바인딩 시나리오도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="aed1d-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="aed1d-152">최상의 디자인을 전달하는 기능을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="aed1d-152">Use the one that communicates your design the best.</span></span>
