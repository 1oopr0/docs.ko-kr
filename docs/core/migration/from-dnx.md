---
title: DNX에서 .NET Core CLI로 마이그레이션
description: DNX 도구 사용에서 .NET Core CLI 도구로 마이그레이션합니다.
ms.date: 06/20/2016
ms.openlocfilehash: e5ebbab2551cf750a5b1136e7b1d4b67816c3b03
ms.sourcegitcommit: bf5c5850654187705bc94cc40ebfb62fe346ab02
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/23/2020
ms.locfileid: "91071120"
---
# <a name="migrating-from-dnx-to-net-core-cli-projectjson"></a><span data-ttu-id="ca0ca-103">DNX에서.NET Core CLI(project.json)로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="ca0ca-103">Migrating from DNX to .NET Core CLI (project.json)</span></span>

## <a name="overview"></a><span data-ttu-id="ca0ca-104">개요</span><span class="sxs-lookup"><span data-stu-id="ca0ca-104">Overview</span></span>

<span data-ttu-id="ca0ca-105">.NET Core 및 ASP.NET Core 1.0의 RC1 릴리스에서 DNX 도구를 발표했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-105">The RC1 release of .NET Core and ASP.NET Core 1.0 introduced DNX tooling.</span></span> <span data-ttu-id="ca0ca-106">.NET Core 및 ASP.NET Core 1.0의 RC2 릴리스에서 DNX에서 .NET Core CLI로 전환했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-106">The RC2 release of .NET Core and ASP.NET Core 1.0 moved from DNX to the .NET Core CLI.</span></span>

<span data-ttu-id="ca0ca-107">가볍게 복습하는 의미에서 DNX에 대해 정리해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-107">As a slight refresher, let's recap what DNX was about.</span></span> <span data-ttu-id="ca0ca-108">DNX는 .NET Core, 좀 더 구체적으로 말해서 ASP.NET Core 1.0 애플리케이션 빌드에 사용된 런타임 및 도구 집합이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-108">DNX was a runtime and a toolset used to build .NET Core and, more specifically, ASP.NET Core 1.0 applications.</span></span> <span data-ttu-id="ca0ca-109">DNX는 3개의 주요 부분으로 구성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-109">It consisted of 3 main pieces:</span></span>

1. <span data-ttu-id="ca0ca-110">DNVM - DNX를 얻기 위한 설치 스크립트</span><span class="sxs-lookup"><span data-stu-id="ca0ca-110">DNVM - an install script for obtaining DNX</span></span>
2. <span data-ttu-id="ca0ca-111">DNX(Dotnet 실행 런타임) - 코드를 실행하는 런타임</span><span class="sxs-lookup"><span data-stu-id="ca0ca-111">DNX (Dotnet Execution Runtime) - the runtime that executes your code</span></span>
3. <span data-ttu-id="ca0ca-112">DNU(Dotnet 개발자 유틸리티) - 종속성을 관리하고 애플리케이션을 빌드 및 게시하기 위한 도구</span><span class="sxs-lookup"><span data-stu-id="ca0ca-112">DNU (Dotnet Developer Utility) - tooling for managing dependencies, building and publishing your applications</span></span>

<span data-ttu-id="ca0ca-113">CLI의 도입에 따라 이제 위의 모든 요소는 단일 도구 집합의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-113">With the introduction of the CLI, all of the above are now part of a single toolset.</span></span> <span data-ttu-id="ca0ca-114">그러나 DNX는 RC1 시기에 사용 가능했으므로 이를 사용해 빌드한 프로젝트가 있고, 새 CLI 도구에서 해당 프로젝트를 이동하고자 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-114">However, since DNX was available in RC1 timeframe, you might have projects that were built using it that you would want to move off to the new CLI tooling.</span></span>

<span data-ttu-id="ca0ca-115">이 마이그레이션 가이드에서는 DNX에서 .NET Core CLI로 프로젝트를 마이그레이션하는 방법의 필수 사항을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-115">This migration guide will cover the essentials on how to migrate projects off of DNX and onto .NET Core CLI.</span></span> <span data-ttu-id="ca0ca-116">.NET Core에서 막 프로젝트를 시작하는 경우 이 문서를 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-116">If you are just starting a project on .NET Core from scratch, you can freely skip this document.</span></span>

## <a name="main-changes-in-the-tooling"></a><span data-ttu-id="ca0ca-117">도구의 주요 변경 사항</span><span class="sxs-lookup"><span data-stu-id="ca0ca-117">Main changes in the tooling</span></span>

<span data-ttu-id="ca0ca-118">먼저 설명해야 할 몇 가지 일반적인 도구 변경 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-118">There are some general changes in the tooling that should be outlined first.</span></span>

### <a name="no-more-dnvm"></a><span data-ttu-id="ca0ca-119">더 이상 DNVM 없음</span><span class="sxs-lookup"><span data-stu-id="ca0ca-119">No more DNVM</span></span>

<span data-ttu-id="ca0ca-120">DNVM(*DotNet Version Manager*)은 컴퓨터에 DNX를 설치하는 데 사용된 bash/PowerShell 스크립트였습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-120">DNVM, short for *DotNet Version Manager* was a bash/PowerShell script used to install a DNX on your machine.</span></span> <span data-ttu-id="ca0ca-121">DNVM을 통해 사용자는 지정한 피드(또는 기본 피드)에서 필요한 DNX를 가져와 특정 DNX를 "활성"으로 표시하여 특정 세션의 $PATH에 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-121">It helped users get the DNX they need from the feed they specified (or default ones) as well as mark a certain DNX "active", which would put it on the $PATH for the given session.</span></span> <span data-ttu-id="ca0ca-122">이렇게 하면 다양한 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-122">This would allow you to use the various tools.</span></span>

<span data-ttu-id="ca0ca-123">DNVM은 기능 집합이 .NET Core CLI에 포함된 변경 사항과 중복되므로 단종되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-123">DNVM was discontinued because its feature set was made redundant by changes coming in the .NET Core CLI.</span></span>

<span data-ttu-id="ca0ca-124">CLI는 다음과 같은 두 가지 주요 방법으로 패키지됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-124">The CLI comes packaged in two main ways:</span></span>

1. <span data-ttu-id="ca0ca-125">지정된 플랫폼에 대한 기본 설치 관리자</span><span class="sxs-lookup"><span data-stu-id="ca0ca-125">Native installers for a given platform</span></span>
2. <span data-ttu-id="ca0ca-126">다른 상황(예: CI 서버)에 대한 설치 스크립트</span><span class="sxs-lookup"><span data-stu-id="ca0ca-126">Install script for other situations (like CI servers)</span></span>

<span data-ttu-id="ca0ca-127">이러한 점에서 DNVM 설치 기능이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-127">Given this, the DNVM install features are not needed.</span></span> <span data-ttu-id="ca0ca-128">그러나 런타임 선택 기능은 어떤가요?</span><span class="sxs-lookup"><span data-stu-id="ca0ca-128">But what about the runtime selection features?</span></span>

<span data-ttu-id="ca0ca-129">특정 버전의 패키지를 종속성에 추가하여 `project.json`에서 런타임을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-129">You reference a runtime in your `project.json` by adding a package of a certain version to your dependencies.</span></span> <span data-ttu-id="ca0ca-130">이 변경으로 애플리케이션은 새로운 런타임 비트를 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-130">With this change, your application will be able to use the new runtime bits.</span></span> <span data-ttu-id="ca0ca-131">이러한 비트를 컴퓨터로 가져오는 것은 CLI와 마찬가지입니다. 지원되는 기본 설치 관리자 중 하나 또는 설치 스크립트를 통해 런타임을 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-131">Getting these bits to your machine is the same as with the CLI: you install the runtime via one of the native installers it supports or via its install script.</span></span>

### <a name="different-commands"></a><span data-ttu-id="ca0ca-132">다양한 명령</span><span class="sxs-lookup"><span data-stu-id="ca0ca-132">Different commands</span></span>

<span data-ttu-id="ca0ca-133">DNX를 사용한 경우 세 부분(DNX, DNU 또는 DNVM) 중 하나에서 몇 가지 명령을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-133">If you were using DNX, you used some commands from one of its three parts (DNX, DNU or DNVM).</span></span> <span data-ttu-id="ca0ca-134">CLI에서는 이러한 명령 중 몇 개는 변경되고, 일부는 사용할 수 없으며, 일부는 동일하지만 의미 체계가 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-134">With the CLI, some of these commands change, some are not available and some are the same but have slightly different semantics.</span></span>

<span data-ttu-id="ca0ca-135">다음 표에서는 DNX/DNU 명령 및 해당 CLI 명령 간의 매핑을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-135">The table below shows the mapping between the DNX/DNU commands and their CLI counterparts.</span></span>

| <span data-ttu-id="ca0ca-136">DNX 명령</span><span class="sxs-lookup"><span data-stu-id="ca0ca-136">DNX command</span></span>                    | <span data-ttu-id="ca0ca-137">CLI 명령</span><span class="sxs-lookup"><span data-stu-id="ca0ca-137">CLI command</span></span>    | <span data-ttu-id="ca0ca-138">설명</span><span class="sxs-lookup"><span data-stu-id="ca0ca-138">Description</span></span>                                                                                                     |
|--------------------------------|----------------|-----------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="ca0ca-139">dnx run</span><span class="sxs-lookup"><span data-stu-id="ca0ca-139">dnx run</span></span>                        | `dotnet run`     | <span data-ttu-id="ca0ca-140">소스에서 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-140">Run code from source.</span></span>                                                                                           |
| <span data-ttu-id="ca0ca-141">dnu build</span><span class="sxs-lookup"><span data-stu-id="ca0ca-141">dnu build</span></span>                      | `dotnet build`   | <span data-ttu-id="ca0ca-142">코드의 IL 바이너리를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-142">Build an IL binary of your code.</span></span>                                                                                |
| <span data-ttu-id="ca0ca-143">dnu pack</span><span class="sxs-lookup"><span data-stu-id="ca0ca-143">dnu pack</span></span>                       | `dotnet pack`    | <span data-ttu-id="ca0ca-144">코드의 NuGet 패키지를 패키지합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-144">Package up a NuGet package of your code.</span></span>                                                                        |
| <span data-ttu-id="ca0ca-145">dnx \[command](예: "dnx web")</span><span class="sxs-lookup"><span data-stu-id="ca0ca-145">dnx \[command] (for example, "dnx web")</span></span> | <span data-ttu-id="ca0ca-146">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="ca0ca-146">N/A\*</span></span>          | <span data-ttu-id="ca0ca-147">DNX 세계에서 project.json에 정의된 대로 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-147">In DNX world, run a command as defined in the project.json.</span></span>                                                     |
| <span data-ttu-id="ca0ca-148">dnu install</span><span class="sxs-lookup"><span data-stu-id="ca0ca-148">dnu install</span></span>                    | <span data-ttu-id="ca0ca-149">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="ca0ca-149">N/A\*</span></span>          | <span data-ttu-id="ca0ca-150">DNX 세계에서 종속성으로 패키지를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-150">In the DNX world, install a package as a dependency.</span></span>                                                            |
| <span data-ttu-id="ca0ca-151">dnu restore</span><span class="sxs-lookup"><span data-stu-id="ca0ca-151">dnu restore</span></span>                    | `dotnet restore` | <span data-ttu-id="ca0ca-152">Project.json에 지정된 종속성을 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-152">Restore dependencies specified in your project.json.</span></span> <span data-ttu-id="ca0ca-153">([참고 참조](#dotnet-restore-note))</span><span class="sxs-lookup"><span data-stu-id="ca0ca-153">([see note](#dotnet-restore-note))</span></span>                                                            |
| <span data-ttu-id="ca0ca-154">dnu publish</span><span class="sxs-lookup"><span data-stu-id="ca0ca-154">dnu publish</span></span>                    | `dotnet publish` | <span data-ttu-id="ca0ca-155">배포할 애플리케이션을 세 가지 형식(이식 가능, 이식 가능과 네이티브, 독립 실행형) 중 하나로 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-155">Publish your application for deployment in one of the three forms (portable, portable with native and standalone).</span></span> |
| <span data-ttu-id="ca0ca-156">dnu wrap</span><span class="sxs-lookup"><span data-stu-id="ca0ca-156">dnu wrap</span></span>                       | <span data-ttu-id="ca0ca-157">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="ca0ca-157">N/A\*</span></span>          | <span data-ttu-id="ca0ca-158">DNX 세계에서 csproj의 project.json을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-158">In DNX world, wrap a project.json in csproj.</span></span>                                                                    |
| <span data-ttu-id="ca0ca-159">dnu commands</span><span class="sxs-lookup"><span data-stu-id="ca0ca-159">dnu commands</span></span>                   | <span data-ttu-id="ca0ca-160">해당 없음\*</span><span class="sxs-lookup"><span data-stu-id="ca0ca-160">N/A\*</span></span>          | <span data-ttu-id="ca0ca-161">DNX 세계에서 전역적으로 설치된 명령을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-161">In DNX world, manage the globally installed commands.</span></span>                                                           |

<span data-ttu-id="ca0ca-162">(\*) - 이 기능은 설계상 CLI에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-162">(\*) - these features are not supported in the CLI by design.</span></span>

## <a name="dnx-features-that-are-not-supported"></a><span data-ttu-id="ca0ca-163">지원되지 않는 DNX 기능</span><span class="sxs-lookup"><span data-stu-id="ca0ca-163">DNX features that are not supported</span></span>

<span data-ttu-id="ca0ca-164">위의 표에서 알 수 있듯이, 적어도 당분간은 CLI에서 지원하지 않기로 한 DNX 세계의 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-164">As the table above shows, there are features from the DNX world that we decided not to support in the CLI, at least for the time being.</span></span> <span data-ttu-id="ca0ca-165">이 섹션에서는 그러한 기능 중 가장 중요한 것을 살펴보고, 지원 중단 배후의 원리, 그리고 그러한 기능이 필요한 경우의 해결 방법을 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-165">This section will go through the most important ones and outline the rationale behind not supporting them as well as workarounds if you do need them.</span></span>

### <a name="global-commands"></a><span data-ttu-id="ca0ca-166">전역 명령</span><span class="sxs-lookup"><span data-stu-id="ca0ca-166">Global commands</span></span>

<span data-ttu-id="ca0ca-167">DNU는 "명령 전역"이라는 개념과 함께 제공되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-167">DNU came with a concept called "global commands".</span></span> <span data-ttu-id="ca0ca-168">이는 애플리케이션 실행을 위해 지정한 DNX를 호출하는 셸 스크립트와 함께 NuGet 패키지로 패키지된 콘솔 애플리케이션이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-168">These were, essentially, console applications packaged up as NuGet packages with a shell script that would invoke the DNX you specified to run the application.</span></span>

<span data-ttu-id="ca0ca-169">CLI는 이 개념을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-169">The CLI does not support this concept.</span></span> <span data-ttu-id="ca0ca-170">대신 친숙한 `dotnet <command>` 구문을 사용하여 호출할 수 있는 프로젝트별 명령을 추가하는 개념을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-170">It does, however, support the concept of adding per-project commands that can be invoked using the familiar `dotnet <command>` syntax.</span></span>

### <a name="installing-dependencies"></a><span data-ttu-id="ca0ca-171">종속성 설치</span><span class="sxs-lookup"><span data-stu-id="ca0ca-171">Installing dependencies</span></span>

<span data-ttu-id="ca0ca-172">v1부터 .NET Core CLI에는 종속성 설치를 위한 `install` 명령이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-172">As of v1, the .NET Core CLI doesn't have an `install` command for installing dependencies.</span></span> <span data-ttu-id="ca0ca-173">NuGet에서 패키지를 설치하려면 이를 종속성으로 `project.json` 파일에 추가한 후 `dotnet restore`([참고 참조](#dotnet-restore-note))를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-173">In order to install a package from NuGet, you would need to add it as a dependency to your `project.json` file and then run `dotnet restore` ([see note](#dotnet-restore-note)).</span></span>

### <a name="running-your-code"></a><span data-ttu-id="ca0ca-174">코드 실행</span><span class="sxs-lookup"><span data-stu-id="ca0ca-174">Running your code</span></span>

<span data-ttu-id="ca0ca-175">코드를 실행하는 두 가지 중요한 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-175">There are two main ways to run your code.</span></span> <span data-ttu-id="ca0ca-176">하나는 소스에서 `dotnet run`으로 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-176">One is from source, with `dotnet run`.</span></span> <span data-ttu-id="ca0ca-177">`dnx run`과는 달리, 이 경우 메모리 내 컴파일을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-177">Unlike `dnx run`, this will not do any in-memory compilation.</span></span> <span data-ttu-id="ca0ca-178">실제로 `dotnet build`를 호출하여 코드를 빌드하고 빌드된 바이너리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-178">It will actually invoke `dotnet build` to build your code and then run the built binary.</span></span>

<span data-ttu-id="ca0ca-179">또 다른 방법은 `dotnet` 자체를 사용하여 코드를 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-179">Another way is using the `dotnet` itself to run your code.</span></span> <span data-ttu-id="ca0ca-180">이는 어셈블리에 경로를 제공하여 수행됩니다(`dotnet path/to/an/assembly.dll`).</span><span class="sxs-lookup"><span data-stu-id="ca0ca-180">This is done by providing a path to your assembly: `dotnet path/to/an/assembly.dll`.</span></span>

## <a name="migrating-your-dnx-project-to-net-core-cli"></a><span data-ttu-id="ca0ca-181">DNX 프로젝트를 .NET Core CLI로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="ca0ca-181">Migrating your DNX project to .NET Core CLI</span></span>

<span data-ttu-id="ca0ca-182">코드로 작업할 때 새 명령을 사용하는 것 외에도 DNX에서 마이그레이션할 때 세 가지 중요한 사항이 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-182">In addition to using new commands when working with your code, there are three major things left in migrating from DNX:</span></span>

1. <span data-ttu-id="ca0ca-183">CLI를 사용할 수 있도록 `global.json` 파일을 마이그레이션합니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="ca0ca-183">Migrate the `global.json` file if you have it to be able to use CLI.</span></span>
2. <span data-ttu-id="ca0ca-184">프로젝트 파일(`project.json`) 자체를 CLI 도구로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-184">Migrating the project file (`project.json`) itself to the CLI tooling.</span></span>
3. <span data-ttu-id="ca0ca-185">DNX API를 해당 BCL API로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-185">Migrating off of any DNX APIs to their BCL counterparts.</span></span>

### <a name="changing-the-globaljson-file"></a><span data-ttu-id="ca0ca-186">Global.json 파일 변경</span><span class="sxs-lookup"><span data-stu-id="ca0ca-186">Changing the global.json file</span></span>

<span data-ttu-id="ca0ca-187">`global.json` 파일은 RC1 및 RC2(또는 그 이상) 프로젝트 모두에 대한 솔루션 파일 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-187">The `global.json` file acts like a solution file for both the RC1 and RC2 (or later) projects.</span></span> <span data-ttu-id="ca0ca-188">RC1 버전과 그 이후 버전에서 .NET Core CLI(및 Visual Studio)를 구별하기 위해 `"sdk": { "version" }` 속성을 사용하여 프로젝트가 RC1인지 또는 그 이후 버전인지를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-188">In order for the .NET Core CLI (as well as Visual Studio) to differentiate between RC1 and later versions, they use the `"sdk": { "version" }` property to make the distinction which project is RC1 or later.</span></span> <span data-ttu-id="ca0ca-189">`global.json`에 이 노드가 없는 경우 최신으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-189">If `global.json` doesn't have this node at all, it is assumed to be the latest.</span></span>

<span data-ttu-id="ca0ca-190">`global.json` 파일을 업데이트하려면 속성을 제거하거나 사용할 정확한 도구 버전으로 설정합니다(이 경우**1.0.0-preview2-003121**).</span><span class="sxs-lookup"><span data-stu-id="ca0ca-190">In order to update the `global.json` file, either remove the property or set it to the exact version of the tools that you wish to use, in this case **1.0.0-preview2-003121**:</span></span>

```json
{
    "sdk": {
        "version": "1.0.0-preview2-003121"
    }
}
```

### <a name="migrating-the-project-file"></a><span data-ttu-id="ca0ca-191">프로젝트 파일 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="ca0ca-191">Migrating the project file</span></span>

<span data-ttu-id="ca0ca-192">CLI와 DNX는 둘 다 `project.json` 파일 기반의 동일한 기본 프로젝트 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-192">The CLI and DNX both use the same basic project system based on `project.json` file.</span></span> <span data-ttu-id="ca0ca-193">프로젝트 파일의 구문 및 의미 체계는 시나리오에 따른 약간의 차이를 제외하면 상당 부분 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-193">The syntax and the semantics of the project file are pretty much the same, with small differences based on the scenarios.</span></span> <span data-ttu-id="ca0ca-194">또한 [스키마 파일](http://json.schemastore.org/project)에서 확인할 수 있는 몇 가지 스키마 변경 내용이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-194">There are also some changes to the schema which you can see in the [schema file](http://json.schemastore.org/project).</span></span>

<span data-ttu-id="ca0ca-195">콘솔 애플리케이션을 작성하는 경우 프로젝트 파일에 다음 조각을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-195">If you are building a console application, you need to add the following snippet to your project file:</span></span>

```json
"buildOptions": {
    "emitEntryPoint": true
}
```

<span data-ttu-id="ca0ca-196">이렇게 하면 `dotnet build`는 애플리케이션의 진입점을 내보내서 코드 실행이 효과적으로 수행되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-196">This instructs `dotnet build` to emit an entry point for your application, effectively making your code runnable.</span></span> <span data-ttu-id="ca0ca-197">클래스 라이브러리를 빌드하는 경우 위 섹션을 생략하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-197">If you are building a class library, simply omit the above section.</span></span> <span data-ttu-id="ca0ca-198">물론 위 코드 조각을 `project.json` 파일에 추가한 후 정적 진입점을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-198">Of course, once you add the above snippet to your `project.json` file, you need to add a static entry point.</span></span> <span data-ttu-id="ca0ca-199">DNX에서 나오면 DNX가 지원하는 DI를 더 이상 사용할 수 없으므로 `static void Main()`이 기본 .NET 진입점이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-199">With the move off DNX, the DI services it provided are no longer available and thus this needs to be a basic .NET entry point: `static void Main()`.</span></span>

<span data-ttu-id="ca0ca-200">`project.json`에 "commands" 섹션이 있는 경우 이를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-200">If you have a "commands" section in your `project.json`, you can remove it.</span></span> <span data-ttu-id="ca0ca-201">DNU 명령으로 사용되었던 명령 중 일부(예: Entity Framework CLI 명령)는 CLI에 프로젝트별 확장으로 이식됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-201">Some of the commands that used to exist as DNU commands, such as Entity Framework CLI commands, are being ported to be per-project extensions to the CLI.</span></span> <span data-ttu-id="ca0ca-202">프로젝트에서 사용하는 명령을 빌드한 경우 이를 CLI 확장으로 교체해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-202">If you built your own commands that you are using in your projects, you need to replace them with CLI extensions.</span></span> <span data-ttu-id="ca0ca-203">이 경우 `project.json`의 `commands` 노드를 `tools` 노드로 교체하고, 도구 종속성을 나열해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-203">In this case, the `commands` node in `project.json` needs to be replaced by the `tools` node and it needs to list the tools dependencies.</span></span>

<span data-ttu-id="ca0ca-204">이러한 작업이 완료되면 어떤 이식성 유형을 앱에 사용할지를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-204">After these things are done, you need to decide which type of portability you wish for you app.</span></span> <span data-ttu-id="ca0ca-205">.NET Core에서는 선택 가능한 폭넓은 이식성 옵션이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-205">With .NET Core, we have invested into providing a spectrum of portability options that you can choose from.</span></span> <span data-ttu-id="ca0ca-206">예를 들어 완전히 *이식 가능한* 애플리케이션을 원할 수도 있고 *자체 포함* 애플리케이션을 원할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-206">For instance, you may want to have a fully *portable* application or you may want to have a *self-contained* application.</span></span> <span data-ttu-id="ca0ca-207">이식 가능한 애플리케이션 옵션은 .NET Framework 애플리케이션 작업과 유사하며, 대상 컴퓨터(.NET Core)에서 실행하기 위한 공유 구성 요소가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-207">The portable application option is more like .NET Framework applications work: it needs a shared component to execute it on the target machine (.NET Core).</span></span> <span data-ttu-id="ca0ca-208">자체 포함 애플리케이션의 경우 .NET Core를 대상에 설치할 필요가 없지만, 지원할 각 OS에 대해 하나의 애플리케이션을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-208">The self-contained application doesn't require .NET Core to be installed on the target, but you have to produce one application for each OS you wish to support.</span></span> <span data-ttu-id="ca0ca-209">이러한 이식성 형식 등에 대해서는 [애플리케이션 이식성 유형](../deploying/index.md) 문서에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-209">These portability types and more are discussed in the [application portability type](../deploying/index.md) document.</span></span>

<span data-ttu-id="ca0ca-210">원하는 이식성 형식을 호출하면 대상 프레임워크를 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-210">Once you make a call on what type of portability you want, you need to change your targeted framework(s).</span></span> <span data-ttu-id="ca0ca-211">.NET Core용 애플리케이션을 작성한 경우 대상 프레임워크로 `dnxcore50`을 사용할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-211">If you were writing applications for .NET Core, you were most likely using `dnxcore50` as  your targeted framework.</span></span> <span data-ttu-id="ca0ca-212">새로운 [.NET 표준](../../standard/net-standard.md)이 가져온 CLI 및 변경 사항과 함께 프레임워크는 다음 중 하나여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-212">With the CLI and the changes that the new [.NET Standard](../../standard/net-standard.md) brought, the framework needs to be one of the following:</span></span>

1. <span data-ttu-id="ca0ca-213">`netcoreapp1.0`- .NET Core에서 애플리케이션을 작성하는 경우(ASP.NET Core 애플리케이션 포함)</span><span class="sxs-lookup"><span data-stu-id="ca0ca-213">`netcoreapp1.0` - if you are writing applications on .NET Core (including ASP.NET Core applications)</span></span>
2. <span data-ttu-id="ca0ca-214">`netstandard1.6`- .NET Core용 클래스 라이브러리를 작성하는 경우</span><span class="sxs-lookup"><span data-stu-id="ca0ca-214">`netstandard1.6` - if you are writing class libraries for .NET Core</span></span>

<span data-ttu-id="ca0ca-215">`dnx451` 같은 다른 `dnx` 대상을 사용 중인 경우에도 역시 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-215">If you are using other `dnx` targets, like `dnx451` you will need to change those as well.</span></span> <span data-ttu-id="ca0ca-216">`dnx451`을`net451` 로 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-216">`dnx451` should be changed to `net451`.</span></span>
<span data-ttu-id="ca0ca-217">자세한 내용은 [.NET 표준](../../standard/net-standard.md) 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-217">Please refer to the [.NET Standard](../../standard/net-standard.md) topic for more information.</span></span>

<span data-ttu-id="ca0ca-218">`project.json`이 거의 준비되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-218">Your `project.json` is now mostly ready.</span></span> <span data-ttu-id="ca0ca-219">종속성 목록을 살펴보고, 특히 ASP.NET Core 종속성을 사용하는 경우 종속성을 새 버전으로 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-219">You need to go through your dependencies list and update the dependencies to their newer versions, especially if you are using ASP.NET Core dependencies.</span></span> <span data-ttu-id="ca0ca-220">별도의 BCL API용 패키지를 사용한 경우 [애플리케이션 이식성 유형](../deploying/index.md) 문서에 설명된 대로 런타임 패키지를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-220">If you were using separate packages for BCL APIs, you can use the runtime package as explained in the [application portability type](../deploying/index.md) document.</span></span>

<span data-ttu-id="ca0ca-221">준비가 되면 `dotnet restore`([참고 참조](#dotnet-restore-note))로 복원을 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-221">Once you are ready, you can try restoring with `dotnet restore` ([see note](#dotnet-restore-note)).</span></span> <span data-ttu-id="ca0ca-222">종속성의 버전에 따라, NuGet이 위의 대상 프레임워크 중 하나에 대한 종속성을 확인할 수 없는 경우 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-222">Depending on the version of your dependencies, you may encounter errors if NuGet cannot resolve the dependencies for one of the targeted frameworks above.</span></span> <span data-ttu-id="ca0ca-223">이는 "시점" 문제입니다. 시간이 지나면서 이러한 프레임워크를 지원하는 패키지가 점점 더 많아질 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-223">This is a "point-in-time" problem; as time progresses, more and more packages will include support for these frameworks.</span></span> <span data-ttu-id="ca0ca-224">지금은 `framework` 노드 내에서 `imports` 문을 사용하여, 프레임워크를 대상으로 하는 패키지를 복원할 수 있는 NuGet을 "imports" 문 내에 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-224">For now, if you run into this, you can use the `imports` statement within the `framework` node to specify to NuGet that it can restore the packages targeting the framework within the "imports" statement.</span></span>
<span data-ttu-id="ca0ca-225">이 경우 표시되는 복원 오류는 어떤 프레임워크를 가져와야 하는지에 대한 충분한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-225">The restoring errors you get in this case should provide enough information to tell you which frameworks you need to import.</span></span> <span data-ttu-id="ca0ca-226">잘 모르는 경우 일반적으로 `imports` 문에서 `dnxcore50` 및 `portable-net45+win8`을 지정하면 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-226">If you are slightly lost or new to this, in general, specifying `dnxcore50` and `portable-net45+win8` in the `imports` statement should do the trick.</span></span> <span data-ttu-id="ca0ca-227">다음의 JSON 코드 조각은 이를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-227">The JSON snippet below shows how this looks like:</span></span>

```json
    "frameworks": {
        "netcoreapp1.0": {
            "imports": ["dnxcore50", "portable-net45+win8"]
        }
    }
```

<span data-ttu-id="ca0ca-228">`dotnet build`를 실행하면 너무 많지는 않더라도 궁극적인 빌드 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-228">Running `dotnet build` will show any eventual build errors, though there shouldn't be too many of them.</span></span> <span data-ttu-id="ca0ca-229">코드를 빌드하여 적절히 실행한 후에는 Runner로 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-229">After your code is building and running properly, you can test it out with the runner.</span></span> <span data-ttu-id="ca0ca-230">`dotnet <path-to-your-assembly>`를 실행하고 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="ca0ca-230">Execute `dotnet <path-to-your-assembly>` and see it run.</span></span>

<a name="dotnet-restore-note"></a>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]
